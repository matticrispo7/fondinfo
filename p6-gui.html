<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Gui con Qt</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/qt/slogan.png"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Caratteristiche di Qt</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Sviluppo con meno codice</strong><ul>
<li><em>Design OO</em>: classi intuitive, riusabili ed estendibili</li>
<li>Sviluppo <em>visuale</em> o <em>dichiarativo</em> di gui</li>
<li>Personalizzazione aspetto delle app con <em>CSS</em></li>
</ul>
</li>
<li><strong>Sviluppo libero e multipiattaforma</strong><ul>
<li><em>Qt Project</em>: codice open source (Nokia → Digia)</li>
<li><em>Qt Creator</em>: ambiente integrato di sviluppo</li>
</ul>
</li>
<li><strong>App portabili e avanzate</strong>: buone prestazioni con poche risorse<ul>
<li>Sistemi desktop: Windows, MacOS, Linux …</li>
<li>Mobile/embedded: Android, iOS, Symbian, BlackBerry QNX, MeeGo-JollaOS, Tizen, Ubuntu Touch, Raspberry Pi …</li>
<li>KDE, KOffice, VLC, Google Earth, Skype (Linux), Mathematica…</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Libreria modulare</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Qt Core: classi base, stringhe ecc.</li>
<li><strong>Qt GUI</strong>: supporto grafica 2D<ul>
<li>Integraz. OpenGL, anti-aliasing, trasparenza, trasformaz. vettoriali</li>
</ul>
</li>
<li><strong>Qt Widgets</strong>: insieme di <em>widget</em> evoluti<ul>
<li>Usabilità, esperienza più soddisfacente per utente</li>
</ul>
</li>
<li>Qt Multimedia, Qt Multimedia Widgets</li>
<li>Qt Network</li>
<li>Qt QML, Qt Quick, Qt Quick Controls, Qt Quick Layouts</li>
<li>Qt SQL</li>
<li>Qt Test</li>
<li>Qt WebKit, Qt WebKit Widgets</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Bottoni e display</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/qt/buttons.jpg" /></p>
<p><img alt="" src="images/qt/displays.jpg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Input</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/calendar-example.png">
        <figcaption>Esempio, con QCalendarWidget</figcaption>
      </figure><p><img alt="" src="images/qt/inputs.jpg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Viste di elementi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/qt/views.jpg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Contenitori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/qt/single-page-containers.jpg" /></p>
<p><img alt="" src="images/qt/multi-page-containers.jpg" /></p>
<blockquote></blockquote>
<p>Inoltre: QMenu, QMenuBar, QToolBar, QStatusBar</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Finestre di dialogo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/qt/feedback-dialogs.jpg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>File e stampa</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/qt/file-print-dialogs.jpg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Colori e font</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/qt/color-font-dialogs.jpg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Stili</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Qt sfrutta le primitive grafiche della piattaforma<ul>
<li>Efficienza, aspetto familiare</li>
<li>Ma possibile stile personalizzato!</li>
<li><code>QApplication::setStyle(new QWindowsStyle);</code></li>
<li><code>QApplication::setStyleSheet</code></li>
<li><code>QWidget::setStyleSheet</code></li>
</ul>
</li>
</ul>
<p><img alt="" src="images/qt/styles.png" /></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Disposizione dei widget</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Visualizzare un widget</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/notepad-1.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>#include &lt;QApplication&gt;
#include &lt;QTextEdit&gt;

int main(int argc, char* argv[]) {
    QApplication app{argc, argv};

    QTextEdit text_edit;
    text_edit.show();

    return app.exec();  // event management
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Creare un nuovo widget</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Estendere <strong><code>QWidget</code></strong>, o una sua sottoclasse<ul>
<li>Creare nuovi campi e metodi, sovrascrivere metodi <em>virtual</em></li>
<li>Altrimenti, <strong>ereditate</strong> le caratteristiche della classe base</li>
</ul>
</li>
<li>Incapsulare parti dell'interfaccia utente<ul>
<li>Nuovo widget: <strong>composto</strong> da widget elementari</li>
<li>Resto dell'applicazione non ha bisogno di conoscere i dettagli</li>
</ul>
</li>
<li>Nuovo widget riusabile<ul>
<li>Nella stessa applicazione o in altri progetti</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sottoclasse di QWidget</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/notepad-2.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>class Notepad : public QWidget {
public:
    Notepad();

private:
    QTextEdit* text_edit;      // simple widgets:
    QPushButton* exit_button;  // encapsulated as private fields
};
</code></pre>
<ul>
<li>Da <em>Qt Creator</em>:<ul>
<li><em>Create Project →  Applications →  Qt Gui Application</em></li>
<li><em>Base class</em>: <code>QWidget</code> -- <em>Generate form</em>: <code>no</code></li>
</ul>
</li>
<li><strong>C++11</strong>: aggiungere al file <code>.pro</code> (di progetto): <code>CONFIG += C++11</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Costruire la GUI</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/notepad-2.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>Notepad::Notepad() {
    // construtor: build the GUI
    // QObject::tr translates GUI texts (see Qt Linguist)

    text_edit = new QTextEdit;
    exit_button = new QPushButton{tr("Quit")};

    // widgets in a vertical layout
    auto layout = new QVBoxLayout;
    layout-&gt;addWidget(text_edit);
    layout-&gt;addWidget(exit_button);

    setLayout(layout); // QWidget
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Layout principali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Qt usa il meccanismo dei <em>layout</em> per disporre i widget</li>
<li>Ci sono tre classi di layout pricipali<ul>
<li><code>QHBoxLayout</code></li>
<li><code>QVBoxLayout</code></li>
<li><code>QGridLayout</code></li>
</ul>
</li>
<li>Per installare un layout su un widget, dobbiamo invocare il metodo <code>setLayout</code> del widget</li>
<li>Il layout gestisce l'area <em>interna</em> al widget</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Layout compositi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/notepad-layout.png"><img src="images/qt/notepad-nostretch.png">
        <figcaption>With and without <code>addStretch()</code></figcaption>
      </figure><ul>
<li>È possibile inserire un layout dentro un altro</li>
<li>Es. Layout aggiuntivo a destra, con bottoni in verticale</li>
</ul>
<pre class="prettyprint" data-lang="C++"><code>// ctor
auto button_layout = new QVBoxLayout;
button_layout-&gt;addWidget(open_button);
button_layout-&gt;addWidget(save_button);
button_layout-&gt;addWidget(exit_button);
button_layout-&gt;addStretch();

auto main_layout = new QHBoxLayout;
main_layout-&gt;addWidget(text_edit);
main_layout-&gt;addLayout(button_layout);
setLayout(main_layout);
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Click dei bottoni</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Definire gli slot</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>class Notepad : public QWidget {
    // add support for signals and slots...
    Q_OBJECT
public:
    Notepad();
    // slots, to connect with signals
    void open();
    void save();
    void exit();
private:
    QTextEdit* text_edit = new QTextEdit;
    QPushButton* open_button = new QPushButton{tr("&amp;Open")};
    QPushButton* save_button = new QPushButton{tr("&amp;Save")};
    QPushButton* exit_button = new QPushButton{tr("E&amp;xit")};
};
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Connettere segnali e slot</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>Notepad::Notepad() {
    // ... at the end of ctor ...
    connect(open_button, &amp;QPushButton::clicked, this, &amp;Notepad::open);
    connect(save_button, &amp;QPushButton::clicked, this, &amp;Notepad::save);
    connect(exit_button, &amp;QPushButton::clicked, this, &amp;Notepad::exit);
}
</code></pre>
<p><img alt="" src="images/qt/notepad-connections.svg" /></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Accoppiamento tra segnali e slot</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/abstract-connections.png">
        
      </figure><ul>
<li><strong>Accoppiamento lasco</strong><ul>
<li>Un oggetto emette un <em>segnale</em>, ma non sa quali <em>slot</em> lo ricevono</li>
<li>Molti segnali ad un singolo slot, un segnale a molti slot</li>
</ul>
</li>
<li><strong>Type safe</strong><ul>
<li>La <em>firma</em> del segnale (numero e tipo di parametri) deve corrispondere a quella degli  slot collegati</li>
<li>Se la firma di uno slot è più corta, trascura degli argomenti che riceve</li>
<li>Compilatore rileva errori</li>
</ul>
</li>
<li><strong>Estensione alla sintassi C++</strong><ul>
<li>Segnali e slot sono una estensione specifica di Qt alla sintassi del C++</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Aprire un file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>void Notepad::open() {
    // choose the input file
    auto filename = QFileDialog::getOpenFileName(this);
    if (filename != "") {
        ifstream in{filename.toStdString()};
        if (in.good()) {
            // read the whole text
            string content; getline(in, content, '\0');
            text_edit-&gt;setText(content.c_str());
        } else {
            QMessageBox::critical(this, tr("Error"),
                                  tr("Could not open file"));
        }
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Salvare in un file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>void Notepad::save() {
    // choose the output file
    auto filename = QFileDialog::getSaveFileName(this);
    if (filename != "") {
        ofstream out{filename.toStdString()};
        if (out.good()) {
            // write the whole text
            auto text = text_edit-&gt;toPlainText();
            out &lt;&lt; text.toStdString();
        } else {
            QMessageBox::critical(this, tr("Error"),
                                  tr("Could not save file"));
        }
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Chiudere l'app</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>void Notepad::exit() {
    auto button = QMessageBox::question(
        this,
        tr("Notepad - Quit"),
        tr("Do you really want to quit?"),
        QMessageBox::Yes | QMessageBox::No);

    if (button == QMessageBox::Yes) {
        window()-&gt;close();
    }
}

// See documentation (F1): QMessageBox, QInputDialog, QDialog
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Finestra principale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/mainwindow.png">
        
      </figure><ul>
<li><code>QMainWindow</code>: widget complesso, con un proprio layout particolare, per aggiungere:<ul>
<li><code>QMenuBar</code>, <code>QStatusBar</code>, <code>QToolBar</code>, <code>QDockWidget</code></li>
<li>Widget principale al centro</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="C++"><code>// ... set a layout in the central area
setCentralWidget(new QWidget);
centralWidget()-&gt;setLayout(layout);
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Menù e toolbar</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/notepad-toolbar.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>class NotepadWindow: public QMainWindow // ...
</code></pre>
<pre class="prettyprint" data-lang="C++"><code>NotepadWindow::NotepadWindow() {
    auto notepad = new Notepad; setCentralWidget(notepad);

    auto menu = menuBar()-&gt;addMenu(tr("&amp;File"));  // QMenu*
    auto open_act = menu-&gt;addAction(tr("&amp;Open"));  // QAction*
    auto save_act = menu-&gt;addAction(tr("&amp;Save"));
    menu-&gt;addSeparator();
    auto exit_act = menu-&gt;addAction(tr("E&amp;xit"));
    // auto tools = addToolBar(tr("&amp;File")); tools-&gt;addAction(open_act); ...

    connect(open_act, &amp;QAction::triggered, notepad, &amp;Notepad::open);
    connect(save_act, &amp;QAction::triggered, notepad, &amp;Notepad::save);
    connect(exit_act, &amp;QAction::triggered, notepad, &amp;Notepad::exit);
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Griglia di bottoni</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Griglia di bottoni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/calculator.png">
        
      </figure><ul>
<li><strong><code>QGridLayout</code></strong>: dispone i widget in una griglia</li>
<li>All'inserimento del widget, specificare riga e colonna (<em>0-indexed</em>)</li>
<li>Possibile specificare anche l'occupazione di più celle adiacenti</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fifteen – Gioco astratto</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/fifteen-puzzle.jpg">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>class Game {
public:
    virtual void play_at(int x, int y) = 0;
    virtual int cols() = 0;
    virtual int rows() = 0;
    virtual std::string get_val(int x, int y) = 0;
    virtual bool finished() = 0;
    virtual std::string message() = 0;
};
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fifteen – Gui generica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/puzzle.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>class GameGui : public QWidget {
    Q_OBJECT
public:
    GameGui(Game* game);
private:
    void handle_click(int x, int y);
    void update_button(int x, int y);
    void update_all_buttons();

    Game* game_;
    int cols_, rows_;
};
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fifteen – Costruzione gui</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>GameGui::GameGui(Game* game) {
    cols_ = game-&gt;cols(); rows_ = game-&gt;rows();
    game_ = game;
    auto grid = new QGridLayout; setLayout(grid);
    for (auto y = 0; y &lt; rows_; ++y) {
        for (auto x = 0; x &lt; cols_; ++x) {
            auto b = new QPushButton; 
            grid-&gt;addWidget(b, y, x);
            connect(b, &amp;QPushButton::clicked,
                    [=]{ handle_click(x, y); });
        }
    }
    update_all_buttons();
}
</code></pre>
<ul>
<li><em>Funzioni lambda</em>: anonime, annidate (<em>Church</em>, 1936)</li>
<li><em>Closure</em>: cattura di valori dal contesto; <code>this</code>, <code>x</code>, <code>y</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fifteen – Aggiornamento bottoni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>void GameGui::update_button(int x, int y) {
    auto val = game_-&gt;get_val(x, y);
    auto b = layout()-&gt;itemAt(y * cols_ + x)-&gt;widget();
    dynamic_cast&lt;QPushButton*&gt;(b)-&gt;setText(val.c_str());
}

void GameGui::update_all_buttons() {
    for (auto y = 0; y &lt; rows_; y++) {
        for (auto x = 0; x &lt; cols_; x++) {
            update_button(x, y);
        }
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fifteen – Gestione click</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/puzzle-solved.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>void GameGui::handle_click(int x, int y) {
    game_-&gt;play_at(x, y);
    update_all_buttons();  // ...

    if (game_-&gt;finished()) {
        QMessageBox::information(this,
                                 tr("Game finished"),
                                 tr(game_-&gt;message().c_str()));
        window()-&gt;close();
    }
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Pyside</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Pyside – Costruzione gui</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/puzzle.png">
        
      </figure><pre class="prettyprint" data-lang="python"><code>class GameGui(QWidget):
    def __init__(self, game: Game):
        QWidget.__init__(self)
        self._game = game
        self._cols, self._rows = game.size()
        self.setLayout(QGridLayout())
        for y in range(self._rows):
            for x in range(self._cols):
                b = QPushButton()
                self.layout().addWidget(b, y, x)
                b.clicked.connect(lambda x=x, y=y:
                    self.handle_click(x, y))
        self.update_all_buttons()
    # ...
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pyside – Aggiornamento bottoni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="python"><code>class GameGui(QWidget):
    # ...
    def update_button(self, x: int, y: int):
        val = self._game.get_val(x, y)
        b = self.layout().itemAt(y * self._cols + x).widget()
        b.setText(val)

    def update_all_buttons(self):
        for y in range(self._rows):
            for x in range(self._cols):
                self.update_button(x, y)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pyside – Gestione click</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/puzzle-solved.png">
        
      </figure><pre class="prettyprint" data-lang="python"><code>class GameGui(QWidget):
    # ...
    def handle_click(self, x: int, y: int):
        self._game.play_at(x, y)
        self.update_all_buttons()

        if self._game.finished():
            QMessageBox.information(self, 
                                    self.tr('Game finished'),
                                    self.tr(self._game.message()))
            self.window().close()
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Eventi in Qt</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Dispatching degli eventi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Eventi<ul>
<li>Attività <em>esterne</em> che interessano l'applicazione</li>
<li>O cambiamenti <em>interni</em> all'applicazione</li>
<li>Gestibili da qualsiasi istanza di <code>QObject</code> (spesso widget)</li>
</ul>
</li>
<li>Quando si verifica un evento:<ul>
<li>Creato oggetto per rappresentarlo, istanza (indiretta) di <code>QEvent</code></li>
<li><code>QResizeEvent</code>, <code>QPaintEvent</code>, <code>QMouseEvent</code>, <code>QKeyEvent</code>, <code>QCloseEvent</code></li>
</ul>
</li>
<li>Sulla base del <strong>tipo</strong> di evento:<ul>
<li>Invocato un <strong>metodo specifico</strong> dell'oggetto interessato</li>
<li>Dispatching attraverso il metodo <code>event</code> di <code>QObject</code></li>
<li>L'evento può essere accettato oppure ignorato</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Eventi della tastiera</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/tetrix.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>void TetrixBoard::keyPressEvent(QKeyEvent* e) {
    switch (e-&gt;key()) {
    case Qt::Key_Left:
        tryMove(curPiece, curX - 1, curY);
        break;
        // ...
    case Qt::Key_Down:
        tryMove(curPiece.rotatedRight(), curX, curY);
    break;
        default:
        QFrame::keyPressEvent(e);
    }
}
</code></pre>
<p>Metodi <code>keyPressEvent</code> e <code>keyReleaseEvent</code> per gestire la tastiera</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Segnali periodici</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/analogclock.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>AnalogClock::AnalogClock() {
    QTimer* timer = new QTimer{this};
    connect(timer, &amp;QTimer::timeout,
            this, &amp;AnalogClock::update);
    timer-&gt;start(1000);
}

void AnalogClock::paintEvent(QPaintEvent *event) {
    QPainter painter{this};
    // draw the clock ...
}
</code></pre>
<p><code>QTimer</code>: periodicamente emette segnale <code>timeout</code>, da associare ad uno (o più) slot</p>
<p>Metodo <code>paintEvent</code> per ridisegno di un widget, con oggetto <code>painter</code></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Disegni e animazioni</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Ridisegno</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Metodo <strong><code>update</code></strong> accoda una richiesta di ridisegno <em>asincrono</em> del widget (evento)<ul>
<li>L'operazione non avviene immediatamente</li>
<li>L'<em>event dispatcher</em> esegue il metodo <strong><code>paintEvent</code></strong> appena può</li>
</ul>
</li>
<li>Widget Qt operano di default in <em>double buffering</em><ul>
<li>No <em>flicker</em> dovuto a lettura e scrittura effettuate direttamente su aree di memoria → schermo</li>
<li>Es. si traccia sfondo prima di img in primo piano</li>
<li>Se parte visualizzazione a schermo, img in primo piano scompare per un frame</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sistema di coordinate</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/coord-rect.png"><img src="images/qt/coord-line.png">
        
      </figure><pre class="prettyprint" data-lang="C++"><code>// ...
QPainter painter{this};
painter.setPen(Qt::darkGreen);
painter.drawRect(1, 2, 6, 4);
painter.drawLine(2, 7, 6, 1);
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Disegno di immagini</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>QPainter</code> può disegnare anche immagini <code>QPixmap</code><ul>
<li><code>QPainter::drawPixmap(int x, int y, const QPixmap&amp; pixmap);</code></li>
<li>Immagine caricata facilmente da file, passandone il nome al costruttore</li>
</ul>
</li>
<li>Immagini su bottoni ed etichette<ul>
<li><code>QPushButton::setPixmap(QPixmap&amp; pixmap)</code></li>
<li><code>QLabel::setIcon(QIcon&amp; icon)</code>, oppure <code>setText</code> con HTML</li>
<li>Altrimenti, sfondo: <code>QWidget::setStyleSheet</code></li>
</ul>
</li>
<li><code>QPixmap</code> sono anche superfici di disegno custom<ul>
<li><code>QPainter::QPainter{QPaintDevice* d};</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Superfici ed elementi grafici</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/qt/graphicsview.png">
        
      </figure><ul>
<li><strong><code>QGraphicsScene</code></strong><ul>
<li>Superficie che contiene diversi elementi grafici bidimensionali: fornisce supporto per animazioni e rilevamento collisioni</li>
</ul>
</li>
<li><strong><code>QGraphicsItem</code></strong><ul>
<li>Immagini, linee, poligoni, testo e altri elementi</li>
</ul>
</li>
<li><strong><code>QGraphicsView</code></strong><ul>
<li>Widget per visualizzare l'intera scena o per zoomare su una parte</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Dichiarazione di segnali</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Dichiarazione di segnali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Qt: distribuzione dei segnali gestita automaticamente<ul>
<li>I segnali si dichiarano in maniera simile a metodi</li>
<li>Non devono essere implementati da nessuna parte</li>
<li>Devono restituire <code>void</code></li>
</ul>
</li>
<li>Nota sugli argomenti<ul>
<li>L'esperienza mostra che segnali e slot sono più riusabili se non usano tipi speciali</li>
<li>Raccogliere segnali da diversi widget sarebbe molto più difficile</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Emissione di segnali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un oggetto emette un segnale chiamando <code>emit</code><ul>
<li>Quando si verifica evento o stato interno cambia</li>
<li>Se il cambiamento può interessare altri oggetti</li>
</ul>
</li>
<li>Emesso segnale → slot connessi eseguiti subito<ul>
<li>Come una normale chiamata a metodo</li>
<li>Codice seguente ad <code>emit</code> eseguito dopo aver eseguito tutti gli slot connessi al segnale</li>
<li>Se più slot, eseguiti in sequenza arbitraria</li>
</ul>
</li>
<li>Esistono anche connessioni asincrone (<em>queued</em>)<ul>
<li>Codice dopo <code>emit</code> eseguito subito, poi gli slot</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Meta-Object Compiler</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Il <em>moc</em> è un programma che gestisce le estensioni di Qt al C++</li>
<li>Se una dichiarazione di classe contiene la macro <code>Q_OBJECT</code>, il <em>moc</em> produce altro codice C++ per quella classe</li>
<li>Tra le altre cose, il “<em>meta-object code</em>” è necessario per il meccanismo di segnali e slot</li>
<li><strong>Segnali e slot sono una estensione specifica di Qt alla sintassi C++</strong></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Bottone con click destro</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>class RightPushButton : public QPushButton {
    Q_OBJECT
public:
    using QPushButton::QPushButton;
protected:
    void mouseReleaseEvent(QMouseEvent* e);
signals:
    void rightClicked();  // new signal, in addition to QPushButton::clicked
};
</code></pre>
<pre class="prettyprint" data-lang="C++"><code>void RightPushButton::mouseReleaseEvent(QMouseEvent* e) {
    if (e-&gt;button() == Qt::RightButton) emit rightClicked();
    QPushButton::mouseReleaseEvent(e);  // base class behaviour
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Altre caratteristiche di Qt</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Altre caratteristiche di Qt</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/qt/resources.png" /></p>
<ul>
<li>Possibile inserire dati (img, snd ecc.) direttamente nel file eseguibile<ul>
<li>Aggiungere un “<em>Qt Resource File</em>” al progetto</li>
<li>Aggiungere le singole risorse al descrittore <code>.qrc</code></li>
<li>Percorso delle risorse richiede “<code>:</code>” come prefisso</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Gruppo di bottoni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong><code>QButtonGroup</code></strong>: raggruppamento <em>logico</em> di bottoni</li>
<li>Non fornisce <strong>nessuna rappresentazione</strong> <em>visuale</em></li>
<li>Utile per associare i bottoni ad un indice intero<ul>
<li>Definisce il segnale <strong><code>buttonClicked</code></strong>, che trasmette come parametro l'indice del bottone</li>
<li>Possibile connettere questo segnale anziché il segnale <code>clicked</code> di ciascun bottone</li>
</ul>
</li>
<li>Utile anche per raggruppare bottoni radio<ul>
<li>Gestisce lo stato di tutti i bottoni nel gruppo</li>
<li>Se <code>exclusive</code>, solo un bottone selezionato</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Utilizzare le traduzioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>int main(int argc, char* argv[]) {
    QApplication a{argc, argv};

    // run lupdate(.pro-&gt;.ts), linguist and lrelease(.ts-&gt;.qm), first!
    QTranslator appTranslator;
    appTranslator.load(":/translations/myapp_"
      + QLocale::system().name());
    a.installTranslator(&amp;appTranslator);

    QTranslator qtTranslator;
    qtTranslator.load("qt_" + QLocale::system().name(),
      QLibraryInfo::location(QLibraryInfo::TranslationsPath));
    a.installTranslator(&amp;qtTranslator);

    return a.exec();
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>QString</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Caratteri <code>QChar</code> a 16 bit (UTF-16, rari simboli a due QChar)</li>
<li>Metodi <code>static</code>: <em><code>fromStdString</code></em>, <code>number</code></li>
<li>Metodi: <em><code>toStdString</code></em>, <code>toInt</code>, <code>toFloat</code></li>
<li>Metodo <code>split</code> (genera una <code>QStringList</code>)</li>
<li>Sostituzione automatica di numeri, caratteri e stringhe<ul>
<li><code>QString status = QString{"Processing file %1 of %2: %3"}.arg(i).arg(total).arg(fileName);</code></li>
</ul>
</li>
<li>Operatori <code>[], &gt;, &lt;, ==, +, +=</code> ecc.</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>