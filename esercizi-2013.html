<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Esercizi 2013</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/misc/geek-girl.jpg"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 1</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>1.1 Hello, user!</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/handshake.png">
        
      </figure><ul>
<li>Compilare ed eseguire il programma “Hello world”</li>
<li>In una versione successiva del programma...</li>
<li>Chiedere il nome all'utente e aggiungere tale nome al messaggio di saluto</li>
<li>Se il nome dell'utente è “admin”, salutarlo però con il messaggio speciale “At your command”</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.2 Radici</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/roots2.png">
        
      </figure><ul>
<li>Calcolare le due radici reali di un’equazione di secondo grado: <code>ax<sup>2</sup> + bx + c = 0</code><ul>
<li>Valori dei parametri <code>a</code>, <code>b</code> e <code>c</code> immessi dall’utente</li>
<li>Valori di <code>x<sub>1</sub></code> e <code>x<sub>2</sub></code> calcolati dal programma</li>
</ul>
</li>
<li>Se l'equazione non ammette radici reali, comunicarlo all'utente</li>
</ul>
<blockquote></blockquote>
<p>Per il calcolo della radice quadrata, utilizzare <code>math.sqrt(...)</code> <br>
All'inizio del programma: <code>import math</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.3 Sequenza di valori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere, attraverso un ciclo, una sequenza di numeri interi inseriti dall'utente</li>
<li>La sequenza termina quando la loro somma supera 100</li>
<li>Visualizzare il numero di valori inseriti e la loro somma</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.4 Carattere Unicode</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/characters.png">
        
      </figure><ul>
<li>Leggere un numero</li>
<li>Visualizzare il carattere Unicode corrispondente</li>
<li>Ripetere le operazioni in un ciclo, finchè l'utente non inserisce il valore <code>0</code></li>
</ul>
<blockquote></blockquote>
<p>Usare la funzione <code>chr</code> per convertire un codice nel char corrispondente</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.5 Tabella ASCII</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Visualizzare la tabella dei codici ASCII<ul>
<li>Un carattere per ogni riga</li>
<li>All'inizio della riga: il carattere</li>
<li>Di fianco: il codice ASCII</li>
<li>Limitare l'intervallo tra 32 a 126 (due costanti)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.6 Aritmetica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/calculator.png">
        
      </figure><ul>
<li>Chiedere all'utente due valori <em>float</em>: <code>a</code>, <code>b</code></li>
<li>Mostrare il risultato di tutte le seguenti operazioni<ul>
<li><code>a + b</code></li>
<li><code>a – b</code></li>
<li><code>a * b</code></li>
<li><code>a / b</code></li>
<li><code>a // b</code></li>
<li><code>a % b</code></li>
<li><code>a ** b</code></li>
</ul>
</li>
<li>Eseguire inoltre le stesse operazioni dopo aver convertito i due valori in <em>int</em></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.7 Triangolo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/impossible-triangle.jpg">
        
      </figure><ul>
<li>Chiedere all'utente le lunghezze dei tre lati</li>
<li>Controllare se il triangolo è:<ul>
<li>Equilatero</li>
<li>Isoscele</li>
<li>Scaleno</li>
<li>Oppure se i tre lati non formano affatto un triangolo</li>
</ul>
</li>
<li>Visualizzare il responso</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.8 Media dei voti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/college-student.jpg">
        
      </figure><ul>
<li>Leggere, attraverso un ciclo, una sequenza di risultati di esami<ul>
<li>Voto conseguito all'esame</li>
<li>Numero di crediti formativi acquisiti</li>
</ul>
</li>
<li>La sequenza termina quando l'utente immette il voto 0</li>
<li>Visualizzare la media ponderata dei voti<ul>
<li><code>(∑ v<sub>i</sub>*c<sub>i</sub>) / (∑ c<sub>i</sub>)</code></li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Partire dal calcolo della media semplice, senza considerare i crediti</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.9 Lancio dadi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Due immaginari giocatori lanciano un dado a testa</li>
<li>L'attaccante vince solo se ottiene un numero strettamente maggiore del difensore</li>
<li>Simulare 100 tentativi di attacco e stimare la probabilità di successo dell'attaccante</li>
</ul>
<blockquote></blockquote>
<p>Dado (pseudo-casuale): <code>die = random.randint(1, 6)</code> <br>
All'inizio del programma: <code>import random</code></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 2</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>2.1 Stringhe, cifre</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/numbers.jpg">
        
      </figure><ul>
<li>Leggere una riga di testo</li>
<li>Riscrivere in output la riga, carattere per carattere, ma...<ul>
<li>Escludere tutte le cifre (0-9)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p><code>print(x, end='', sep='')</code> non inserisce spazi e ritorni a capo</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.2 Triangolo di cifre</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere un numero intero positivo <code>n</code> (&lt; 10)</li>
<li>Per ciascun valore <code>y</code> tra 1 ed <code>n</code>...</li>
<li>Stampare una riga con le cifre da 1 ad <code>y</code></li>
</ul>
<pre class="prettyprint" data-lang="Output"><code>1
12
123
1234
</code></pre>
<p>Usare due cicli for annidati <br>
All'inizio non considerare <code>n</code>, ma fissare <code>y</code> e scrivere una sola riga: <code>y = 3</code> → <code>“123”</code> <br>
Poi racchiudere tutto in un ciclo for esterno</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.3 Lista di valori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente una sequenza di valori, terminata da 0<ul>
<li>Memorizzare ciascun valore inserito in una lista <code>values</code></li>
<li><code>values.append(val)</code></li>
</ul>
</li>
<li>In seguito, ripetutamente chiedere all'utente un valore <code>k</code>, da cercare<ul>
<li>Comunicare quante volte <code>k</code> è presente nella lista</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.4 Matrice di valori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente <code>n</code>, il lato di una matrice quadrata<ul>
<li>Chiedere all'utente di inserire gli <code>n<sup>2</sup></code> valori della matrice</li>
</ul>
</li>
<li>In seguito, chiedere ripetutamente all'utente un valore <code>k</code>, da cercare<ul>
<li>Comunicare quante volte <code>k</code> è presente nella matrice</li>
<li>Comunicare inoltre quante volte <code>k</code> è presente sulle diagonali principali</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Usare una semplice lista e aggiungere i valori in maniera simile all'esempio precedente</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.5 Carattere in file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente un carattere</li>
<li>Contare quante volte il carattere è presente in un dato file di testo</li>
</ul>
<blockquote></blockquote>
<p>Leggere per intero il (breve) file in una stringa: <code>txt = f.read()</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.6 Risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Simulare <code>n</code> lanci di una coppia di dadi<ul>
<li><code>n</code> scelto dall'utente</li>
</ul>
</li>
<li>Contare quante volte si presenta ciascun risultato<ul>
<li>Risultati possibili: da 2 a 12</li>
<li>Somma dei due dadi</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Per conteggiare i vari risultati, usare una lista di (almeno) 11 valori</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.7 File, parentesi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/brackets.svg">
        
      </figure><ul>
<li>Data una riga di testo, riscrivere a console solo il testo racchiuso tra parentesi quadre<ul>
<li>Possono essere presenti diverse coppie di parentesi quadre</li>
<li>A capo, dopo ciascuna porzione di testo trovata</li>
</ul>
</li>
<li>Eseguire le stesse operazioni per ogni riga di un file di testo</li>
</ul>
<blockquote></blockquote>
<p>Scorrere la riga, carattere per carattere <br>
Segnare in un bool se si è incontrata una quadra aperta, ma non ancora una quadra chiusa</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.8 Lettura matrice da file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>In un file è riprodotto il contenuto di una matrice di char, riga per riga...</li>
</ul>
<pre class="prettyprint" data-lang="File"><code>AABA
BAAB
AABB
</code></pre>
<ul>
<li>Leggere i char dal file e memorizzarli in una pseudo-matrice (lista semplice)</li>
<li>Inferire le dimensioni della matrice (rows×cols) in base a:<ul>
<li>Numero di righe del file</li>
<li>Lunghezza della prima riga</li>
</ul>
</li>
<li>Visualizzare la matrice</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.9 Lettura matrice da file</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Come esercizio precedente (2.8)</li>
<li>Ma memorizzare i caratteri in una matrice (lista di liste)</li>
</ul>
<blockquote></blockquote>
<p>Da stringa <code>line</code> a lista di char <code>v</code>: <code>v = list(line)</code></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 3</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>3.1 Area di un'ellisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ellipse.svg">
        
      </figure><ul>
<li>Funzione che:<ul>
<li>Riceve come parametri i semiassi di una ellisse: <code>a</code>, <code>b</code></li>
<li>Restituisce l'area dell'ellisse: <code>A = π*a*b</code></li>
</ul>
</li>
<li>All'esterno della funzione:<ul>
<li>Chiedere ripetutamente all'utente una coppia di valori</li>
<li>Invocare ogni volta la funzione con i valori inseriti dall'utente</li>
<li>Visualizzare il risultato</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.2 Sequenza di valori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/data-sequence.png">
        
      </figure><ul>
<li>Funzione che:<ul>
<li>Riceve come parametro il nome di un file</li>
<li>Restituisce una tupla con il valore massimo e quello minimo trovati nel file</li>
<li>(Ciascuna riga del file contiene un valore <code>float</code>)</li>
</ul>
</li>
<li>Invocare la funzione con un nome di file inserito dall'utente</li>
<li>Visualizzare il risultato</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.3 Box</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Classe che modella un riquadro<ul>
<li>Due campi privati, per largezza ed altezza: <code>width</code>, <code>heigth</code></li>
<li>Due metodi, per ottenere area e perimetro: <code>area</code>, <code>perimeter</code></li>
</ul>
</li>
<li>Nel corpo principale del programma, creare e usare un riquadro<ul>
<li>Chiedere all'utente le dimensioni del riquadro</li>
<li>Passare queste dimensioni al costruttore, come parametri</li>
<li>Mostrare area e perimetro del riquadro creato</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.4 Ellisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/ellipse.svg">
        
      </figure><ul>
<li>Classe che modella un'ellisse</li>
<li>Campi privati (parametri del costruttore)<ul>
<li>Semiassi: <code>a, b</code></li>
</ul>
</li>
<li>Metodi pubblici per ottenere...<ul>
<li>Area</li>
<li>Distanza dei fuochi dal centro: <code>√(a<sup>2</sup> - b<sup>2</sup>)</code></li>
<li>Semiassi (due metodi <em>getter</em>)</li>
</ul>
</li>
<li>Nel corpo principale del programma, creare un oggetto con dati forniti dall'utente<ul>
<li>Visualizzare l'area dell'ellisse e la distanza dei fuochi dal centro</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.5 Incolonnamento dati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Visualizzare due tabelle con i caratteri ASCII<ul>
<li>8 righe x 12 colonne, codici da 32 a 126</li>
</ul>
</li>
<li>Tabella 1: mostrare in ordine i caratteri, colonna per colonna</li>
<li>Tabella 2: mostrare in ordine i caratteri, riga per riga</li>
</ul>
<pre class="prettyprint" data-lang="Tabella 1"><code> (08@HPX`hpx
!)19AIQYaiqy
"*2:BJRZbjrz
#+3;CKS[cks{
$,4&lt;DLT\dlt|
%-5=EMU]emu}
&amp;.6&gt;FNV^fnv~
'/7?GOW_gow
</code></pre>
<p>Usare sempre due cicli <code>for</code> annidati: esterno su <code>y</code>, interno su <code>x</code> <br>
In ogni posizione, calcolare il carattere da visualizzare: <code>x * ROWS + y</code>...</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.6 Calcolo delle calorie</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/fast-food.jpg">
        
      </figure><ul>
<li>In un file sono riportati, su ciascuna riga:<ul>
<li>Il nome di un alimento e il suo contenuto calorico (per grammo)</li>
<li>Nome e calorie sono separati da una TABulazione orizzontale (<code>'\t'</code>)</li>
</ul>
</li>
<li>Leggere il contenuto del file e memorizzarlo in un <em>dizionario</em></li>
<li>L'utente inserisce poi da console un menù<ul>
<li>Su ogni riga: alimento e peso, separati da una barra verticale (<code>'|'</code>)</li>
</ul>
</li>
<li>Il programma calcola il contenuto calorico dell'intero menù</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.7 Fattori primi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Funzione che trova tutti i fattori primi di un numero <code>n</code><ul>
<li>Parametro: <code>n</code></li>
<li>Risultato: lista, contenente i fattori primi di <code>n</code></li>
</ul>
</li>
<li>Algoritmo: scorrere tutti i valori d'interesse, e cercare i divisori<ul>
<li><code>x</code> è divisore di <code>n</code> sse <code>n % x == 0</code></li>
<li>Non considerare i fattori non primi</li>
</ul>
</li>
<li>Provare la funzione con valori inseriti dall'utente</li>
</ul>
<blockquote></blockquote>
<p>Quando si trova un divisore <code>x</code>, dividere ripetutamente <code>n</code> per <code>x</code>, finché resta divisibile <br>
Valutare l'uso di un ciclo <code>while</code>, anzichè <code>for</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.8 Crivello di Eratostene</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/hist/eratostenes.jpg">
        
      </figure><ul>
<li>Funzione che calcola la lista di numeri primi fino ad <code>n</code><ul>
<li>Parametro: <code>n</code></li>
<li>Risultato: lista, contenente i numeri primi trovati</li>
</ul>
</li>
<li>Algoritmo<ul>
<li>Inserire tutti i numeri da <code>2</code> fino ad <code>n</code> in una lista</li>
<li>Per ciascun numero <code>x</code> nella lista...</li>
<li>Togliere dalla lista i multipli di <code>x</code> (escluso <code>x</code> stesso)</li>
<li>I numeri rimanenti sono i numeri primi cercati</li>
</ul>
</li>
<li>Provare la funzione con valori inseriti dall'utente</li>
</ul>
<blockquote></blockquote>
<p>Usare il metodo <code>remove</code> della lista, oppure usare una lista di <code>bool</code> <br>
Lista scorsa con un <code>for</code>: sconsigliato rimuovere o inserire elementi</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.9 Parole più lunghe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere le parole presenti in un file (separate da spazi)</li>
<li>Memorizzarle tutte in una lista (senza ripetizioni)</li>
<li>Mostrare a schermo le 10 parole più lunghe in assoluto, in ordine decrescente di lunghezza</li>
</ul>
<blockquote></blockquote>
<p>Si può ordinare una lista tramite il metodo <code>sort</code>. In questo caso: <br>
<code>words.sort(key=lambda x: -len(x))</code></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 4</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>4.1 Ricorsione, palindromo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><em>Palindromo</em>: testo che rimane uguale se letto al contrario</li>
<li>Scrivere una funzione ricorsiva per riconoscere i palindromi<ul>
<li>Parametro: testo da controllare</li>
<li>Risultato: <code>bool</code></li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Stringa palindroma: se ha lunghezza 0 o 1, oppure... <br>
Prima lettera == ultima lettera e... <br>
Stringa rimanente (senza prima e ultima lettera) palindroma</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.2 Fila indiana</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/koala-file.jpg">
        
      </figure><ul>
<li><em>Procedura</em> per far avanzare gli elementi di una lista in “fila indiana”<ul>
<li>Parametri: lista, direzione di avanzamento</li>
<li>Ciascun elemento è rapprensentato come una coppia di valori interi: coordinate <code>(x, y)</code></li>
<li>Il primo elemento avanza nella direzione indicata</li>
<li>Il secondo elemento va nella posizione liberata dal primo, ecc.</li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente la direzione: <code>dx</code>, <code>dy</code>, ciascuno <code>∈ [-1, 0 +1]</code></li>
<li>Invocare la funzione; visualizzare la lista di coordinate aggiornata</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Ad ogni turno: aggiungere nuova coppia <code>(x, y)</code> per elemento di testa, rimuovere elemento di coda <br>
Es. <code>v.insert(0, new_pos), v.pop()</code> <br>
O viceversa <code>v.append(new_pos), v.pop(0)</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.3 Tris</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/tic-tac-toe.svg">
        
      </figure><ul>
<li>Classe che modella una partita a <em>tris</em> (<em>Tic Tac Toe</em>)</li>
<li>Campi privati<ul>
<li>Matrice di gioco</li>
<li>Giocatore di turno: <code>O</code> oppure <code>X</code></li>
</ul>
</li>
<li>Metodi pubblici<ul>
<li>Mossa in una certa posizione <code>x, y</code> (simbolo scelto automaticamente nel metodo)</li>
<li>Rappresentazione stato: <code>__str__(self)</code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>Visualizzare lo stato risultante</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.4 Conclusione partita</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere metodi alla classe del <em>tris</em><ul>
<li>Controllo di conclusione: <code>bool</code></li>
<li>Eventuale vincitore: <code>O</code>, <code>X</code>, <code>None</code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>Visualizzare lo stato risultante</li>
<li>Comunicare l'eventuale conclusione della partita ed il vincitore</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.5 Spirale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/outward-spiral.png">
        
      </figure><ul>
<li>Funzione per riempire una data matrice (parametro) con una sequenza di valori<ul>
<li>Valori disposti a spirale, come suggerito in figura</li>
<li>Valore maggiore in cella in basso a sinistra!</li>
</ul>
</li>
<li>Nel corpo principale dell'applicazione<ul>
<li>Creare la matrice (dimensioni indicate dall'utente)</li>
<li>Invocare la funzione</li>
<li>Visualizzare la matrice</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Tenere traccia della direzione attuale (∆x, ∆y) <br>
Rotazione oraria 90° (coord. raster): <code>(∆x', ∆y') = (-∆y, ∆x)</code> <br>
Rotazione antior. 90° (coord. raster): <code>(∆x', ∆y') = (∆y, -∆x)</code> <br><br>
In generale (coord. cartesiane): <code>(x', y') = (x⋅cos(θ) - y⋅sin(θ), x⋅sin(θ) + y⋅cos(θ))</code> <br>
(Bisogna cambiare il segno di θ)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.6 Fusione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/merge-sign.png">
        
      </figure><ul>
<li>Due file di testo contengono sequenze di numeri<ul>
<li>Un valore per ogni riga</li>
<li>Entrambi i file sono già ordinati, dal valore più piccolo a quello più grande</li>
</ul>
</li>
<li>Scrivere in un terzo file i valori di entrambi i file<ul>
<li>Anche il terzo deve contenere i valori in ordine, dal più piccolo al più grande</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Ciclicamente, confrontare la coppia dei primi valori (ciascuno proveniente da uno dei due stream) <br>
Scrivere il minore dei due sul file di uscita <br>
Non estrarre un nuovo valore da uno stream, se quello precedente non è ancora stato scritto in output </p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.7 Fila di riquadri</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/box-layout.png">
        
      </figure><ul>
<li>Classe che modella una fila verticale di riquadri<ul>
<li>Riquadri (larghezza ed altezza): uno sotto all'altro, ciascuno allineato orizzontalmente al centro</li>
<li>Metodo: aggiunta di un riquadro</li>
<li>Metodo: calcolo area totale (somma delle aree)</li>
<li>Metodo: calcolo riquadro virtuale contenente l'intera fila: <code>w = max(w<sub>i</sub>)</code>, <code>h = Σ h<sub>i</sub></code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere larghezza ed altezza all'utente</li>
<li>Creare un riquadro di quelle dimensioni e aggiungerlo alla fila</li>
<li>Calcolare largezza ed altezza del riquadro virtuale</li>
<li>Calcolare la percentuale di spazio inutilizzato</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.8 Gestione di riquadri</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere alla classe della fila di riquadri<ul>
<li>Metodo per ottenere il numero di riquadri</li>
<li>Metodo per ottenere un riquadro, dato il suo indice nella fila</li>
<li>Metodo per rimuovere un riquadro, dato il suo indice nella fila</li>
</ul>
</li>
<li>Nel <code>main</code>, permettere all'utente di gestire una fila<ul>
<li>Aggiunta, rimozione, elenco dei riquadri</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>4.9 File verticali e orizzontali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/flow-layout.png">
        
      </figure><ul>
<li>Classe base <em>astratta</em> per le file di riquadri</li>
<li>Sottoclasse <em>concreta</em> per fila verticale</li>
<li>Sottoclasse <em>concreta</em> per fila orizzontale<ul>
<li>Riquadri uno di fianco all'altro</li>
<li>Ciascuno allineato verticalmente al centro</li>
<li>Cambia solo il calcolo del riquadro contenente l'intera fila</li>
</ul>
</li>
<li>Rendere il codice generico rispetto al tipo di fila<ul>
<li>L'utente sceglie all'inizio quale fila usare (orizzontale o verticale)</li>
<li>Poi aggiunge i riquadri</li>
<li>Infine calcola il riquadro contenente l'intera fila</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 5</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizi C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/cpp-logo.jpg">
        
      </figure><ul>
<li>1.1 Hello, user!</li>
<li>1.3 Sequenza di valori</li>
<li>1.5 Tabella ASCII</li>
<li>1.8 Media dei voti</li>
<li>1.9 Lancio dadi</li>
<li>2.3 Lista di valori</li>
<li>2.5 Carattere in file</li>
<li>2.6 Risultati casuali</li>
<li>2.8 Lettura matrice da file</li>
</ul>
<blockquote></blockquote>
<p>(1.5) <em>Cast</em> da intero <code>i</code> a carattere: <code>char(i)</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio numeri casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

using namespace std;

int main() {
    srand(time(NULL));  // just once! (initial seed for random numbers)

    for (int i = 0; i &lt; 10; ++i) {
        int r = rand() % 90;  // 0 &lt;= r &lt;= 89
        cout &lt;&lt; r &lt;&lt; endl;
    }
}
</code></pre>
<blockquote></blockquote>
<p>Per esercizi 1.9, 2.6 <br>
Definire costanti, es. <code>const int VALUES = 90</code></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Progetto 1</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Progetto 1</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gioco con diversi personaggi<ul>
<li>Fornita classe <code>Arena</code> per campo di gioco</li>
<li>Fornita classe base astratta <code>Character</code> per personaggi</li>
</ul>
</li>
<li>Creare sottoclassi di <code>Character</code> per personaggi specifici<ul>
<li><em>Polimorfismo</em> per movimento</li>
<li><em>Polimorfismo</em> per interazione reciproca</li>
</ul>
</li>
<li>Inizialmente, I/O tramite console...<ul>
<li>Con attesa dell'input da parte dell'utente</li>
<li>Ma ciclo principale e interazione con l'utente <strong>fuori da queste classi</strong></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Snake</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/snake.png">
        
      </figure><ul>
<li><em>Serpente</em>: guidato dal giocatore<ul>
<li>Avanza continuamente</li>
<li>Non può tornare indietro</li>
<li>Se tocca se stesso, muore</li>
</ul>
</li>
<li><em>Cibo</em>: disposto casualmente<ul>
<li>Il serpente si allunga dopo aver mangiato</li>
<li>Il cibo ricompare in posizione casuale (ma libera)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Per il serpente, usare una lista di tuple, ossia coppie (x, y) <br>
Ad ogni turno aggiungere una nuova coppia (x, y) per la testa e rimuovere la coda</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizi C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/cpp-logo.jpg">
        
      </figure><ul>
<li>3.1 Area di un'ellisse</li>
<li>3.2 Sequenza di valori</li>
<li>3.3 Box</li>
<li>3.6 Calcolo delle calorie</li>
<li>3.8 Crivello di Eratostene</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Pygame</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Snake con Pygame</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/pygame-logo.png">
        
      </figure><ul>
<li>Classi dello Snake in applicazione basata su <em>Pygame</em></li>
<li><em>Due serpenti</em> assieme, comandati con tasti diversi</li>
<li>Muri in posizione fissa; il serpente muore se ci va a sbattere</li>
<li>Cibo diverso, per far crescere il serpente di più</li>
<li>Pezzi speciali; es. per far “rimbalzare” il serpente (testa ↔ coda)</li>
<li>Numero di vite, punti, livelli di gioco ecc.</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>“Bella copia”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/fair-copy.png">
        
      </figure><ul>
<li><strong>Codice leggibile</strong><ul>
<li><em>Costanti</em>, anzichè numeri “<em>magici</em>” sparsi nel codice</li>
<li><em>Nomi esplicativi</em> e semplici</li>
<li><em>Regole di stile</em>: <code>variable_name</code>, <code>function_name</code>, <code>ClassName</code>, <code>CONSTANT_NAME</code></li>
<li><em>Commenti</em>, quando utili: <em>function annotation</em>, <em>docstring</em></li>
</ul>
</li>
<li><strong>Codice ben organizzato</strong><ul>
<li><em>No copia&amp;incolla</em> del codice: funzioni parametrizzate e/o cicli</li>
<li><em>Programmazione strutturata</em>: preferibilmente <code>return</code> a fine funzione, pochi <code>break</code> nei cicli</li>
<li><em>OOP</em>: <em>incapsulamento</em>, <em>ereditarietà</em>, <em>polimorfismo</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizi C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/cpp-logo.jpg">
        
      </figure><ul>
<li>4.3 Tris</li>
<li>4.4 Conclusione partita</li>
<li>4.7 Fila di riquadri</li>
<li>4.8 Gestione di riquadri</li>
<li>4.9 File verticali e orizzontali</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Progetto 2</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Progetto 2</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Classe <em>C++</em> per incapsulare dati e regole di un gioco<ul>
<li>Campi <em>privati</em> + metodi <em>pubblici</em> (e privati)</li>
</ul>
</li>
<li>Inizialmente, I/O tramite console...<ul>
<li>Ma ciclo principale e interazione con l'utente <strong>fuori dalla classe</strong></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Tents puzzle</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/tents.png">
        
      </figure><ul>
<li>Posizionare tende sulla griglia, in modo che ogni albero sia <em>assegnato</em> ad una tenda<ul>
<li>Inizialmente, nessun albero è assegnato ad una tenda</li>
<li>Tenda adiacente (in orizzontale o verticale) ad un solo albero non assegnato ⇒ albero <em>assegnato</em> a quella tenda</li>
<li>Tante tende, quanti sono gli alberi</li>
</ul>
</li>
<li>Le tende non possono toccarsi tra loro, nemmeno in diagonale</li>
<li>Vincoli numerici fuori dalla griglia: numero di tende nella riga o colonna</li>
</ul>
<blockquote></blockquote>
<p><a href="http://www.brainbashers.com/tentshelp.asp">http://www.brainbashers.com/tentshelp.asp</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Bozza della classe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>class TentsPuzzle {
public:
    TentsPuzzle();                  // default board
    void place_tent(int x, int y);  // take a move
    string str();                   // string representation
    bool solved();                  // is puzzle solved?
    // TentsPuzzle(istream&amp; in);    // read from stream
    // bool wrong();                // are tents misplaced?
    // char get(int x, int y)
    // int rows()
    // int cols() ...
private:
    // void set(int x, int y, char value) ...
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio di campi privati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>class TentsPuzzle {
public:
    // ...
private:
    // ...
    int cols_ = 5;
    int rows_ = 5;
    vector&lt;char&gt; board_ = {' ', 'T', ' ', ' ', ' ', 
                           ' ', ' ', ' ', ' ', 'T',
                           ' ', 'T', ' ', 'T', ' ',
                           ' ', ' ', ' ', ' ', 'T',
                           ' ', ' ', ' ', ' ', ' '};
    vector&lt;int&gt; col_constraints_ = {2, 0, 1, 0, 2};
    vector&lt;int&gt; row_constraints_ = {2, 0, 2, 0, 1};
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Gui</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Tents con Qt</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/recycle.png">
        
      </figure><ul>
<li>Aggiungere una <strong>interfaccia grafica</strong> al progetto<ul>
<li>Creare una sottoclasse di <code>QWidget</code> o <code>QMainWindow</code></li>
<li>Interfaccia adattabile a dimensioni diverse del gioco</li>
</ul>
</li>
<li><strong>Riuso</strong> - Classe di modello definita in modo generico<ul>
<li>Usabile sia da interfaccia grafica che da console</li>
</ul>
</li>
<li>Inoltre, permettere di <strong>scrivere</strong> su stream e <strong>leggere</strong> da stream una partita<ul>
<li>Per salvataggio su file e caricamento da file</li>
</ul>
</li>
<li>Infine, permettere all'utente di marcare una cella come <strong>prato</strong>, cioè sicuramente senza una tenda</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Bozza della GUI</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>class TentsGui : public QWidget {
    Q_OBJECT
public:
    TentsGui(TentsPuzzle* puzzle);
private:
    void handle_click(int x, int y);
    void update_button(int x, int y);
    void update_all_buttons();

    vector&lt;QPushButton*&gt; buttons_;
    TentsPuzzle* puzzle_;
};
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Suggerimenti</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Mosse suggerite</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/artificial-intelligence.png">
        
      </figure><ul>
<li>Opzione per marcare automaticamente le celle con <em>prato</em><ul>
<li>Vincolo di riga/colonna pari alle tende già poste: tutte le celle libere sono <em>prato</em></li>
<li>Cella libera vicina ad una tenda (anche diagonalmente): <em>prato</em></li>
<li>Cella non adiacente ad un albero (non assegnato): <em>prato</em></li>
</ul>
</li>
<li>Mossa automatica a richiesta<ul>
<li>Vincolo di riga/colonna pari alla somma delle celle libere e delle tende già poste: le celle libere sono <em>tende</em></li>
<li>Albero senza tende attorno, con una sola cella libera adiacente: <em>tenda</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Soluzione ricorsiva</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="C++"><code>void TentsPuzzle::solve_recursive(int i) {
    // solve_simple();  // mark all obvious grass and tent cells
    // is there an empty cell after i?
    while (i &lt; board_.size() &amp;&amp; board_[i] != EMPTY) ++i;
    if (i &lt; board_.size() &amp;&amp; !wrong()) {
        auto copy = *this;  // save current status
        for (auto m : {TENT, GRASS}) {
            board_[i] = m;
            solve_recursive(i + 1);
            if (solved()) return;
            *this = copy;  // backtracking
        }
    }
}
</code></pre></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>