<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Sistema binario</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/repr/binary-fingers.svg"></figure>
  <hgroup>
    <h2>Introduzione all'informatica</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Analogico e digitale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/analog-clock.png"><img src="images/repr/digital-clock.png">
        
      </figure><ul>
<li>Una grandezza (fisica o astratta) può essere rappresentata in due forme<ul>
<li><strong>Analogica</strong>: insieme di valori <strong>continuo</strong> (<em>denso e “senza buchi”</em>)</li>
<li><strong>Digitale</strong> (o numerica): insieme di valori <strong>discreto</strong> (<em>tutti i punti sono isolati</em>)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Approssimazione discreta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Alcune informazioni sono intrinsecamente discrete<ul>
<li>Informazioni “artificiali”, es. un testo scritto</li>
<li>Scala atomica o subatomica …</li>
</ul>
</li>
<li>Molte grandezze fisiche hanno forma continua<ul>
<li>Per loro elaborazione al calcolatore: rappresentazione digitale</li>
<li><em>Approssimazione</em> del valore analogico</li>
<li>Errore dipende dalla precisione della rappresentazione digitale scelta</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Codice</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sistema basato su simboli, che permette la rappresentazione dell’informazione</li>
<li><em>Simbolo</em>: elemento atomico</li>
<li><em>Alfabeto</em>: insieme dei simboli possibili (<code>A</code>)</li>
<li><em>Cardinalità</em> del codice: numero di simboli dell’alfabeto</li>
<li><em>Stringa</em>: sequenza di simboli (<code>s ∈ A*</code>)</li>
<li><em>Linguaggio</em>: insieme stringhe ben formate (<code>L ⊆ A*</code>)</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Codice posizionale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/child-fingers.png">
        
      </figure><ul>
<li>Un numero naturale può essere rappresentato con una notazione posizionale</li>
<li><code>N = c<sub>0</sub> · base<sup>0</sup> + c<sub>1</sub> · base<sup>1</sup> + … + c<sub>n</sub> · base<sup>n</sup></code><ul>
<li>Es. <code>587<sub>10</sub> = 7·10<sup>0</sup> + 8·10<sup>1</sup> + 5·10<sup>2</sup></code></li>
</ul>
</li>
<li>Sistemi di numerazione posizionali di uso comune<ul>
<li>Decimale (base 10; c: <code>0-9</code>)</li>
<li>Binario (base 2; c: <code>0-1</code>)</li>
<li>Esadecimale (base 16; c: <code>0-9, A-F</code>)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Codifica dell’informazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Codifica: regole di corrispondenza per passare da un certo codice ad un altro</li>
<li>Corrispondenza biunivoca<ul>
<li>Tra una stringa di un codice</li>
<li>E una stringa di un altro codice</li>
</ul>
</li>
<li>Ad una certa stringa in un alfabeto ricco di simboli, corrisponde una stringa più lunga in un alfabeto più ridotto</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Numeri binari</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Codice binario</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/sum-binary.jpg">
        
      </figure><ul>
<li>Base 2; c: <code>0-1</code></li>
<li>Informazione digitale nei calcolatori rappresentata con una sequenza di 0 e 1<ul>
<li>Leibniz, ~1700</li>
<li>Konrad Zuse, ~1940</li>
</ul>
</li>
<li>Ogni elemento di una sequenza binaria viene detto <em>bit</em></li>
<li>Una sequenza di 8 bit viene detta <em>byte</em></li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Codifica decimale → binaria</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>(1) Dividere il numero decimale per 2</li>
<li>(2) Assegnare il resto come valore del bit <em>(loop)</em></li>
<li>Ossia continuare a dividere per 2 il quoziente, finché non si annulla</li>
<li>Es.: <code>35<sub>10</sub> = 00100011<sub>2</sub></code></li>
</ul>
<table>
<thead>
<tr>
<th>n</th>
<th>n // B</th>
<th>n % B</th>
<th>peso</th>
</tr>
</thead>
<tbody>
<tr>
<td>35</td>
<td>17</td>
<td>1</td>
<td>1 = 2<sup>0</sup></td>
</tr>
<tr>
<td>17</td>
<td>8</td>
<td>1</td>
<td>2 = 2<sup>1</sup></td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>0</td>
<td>4 = 2<sup>2</sup></td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>0</td>
<td>8 = 2<sup>3</sup></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>16 = 2<sup>4</sup></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>32 = 2<sup>5</sup></td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Numeri naturali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/binary-fingers.svg">
        <figcaption>... 819</figcaption>
      </figure><ul>
<li>Rappresentare un numero naturale <code>N</code> in forma binaria</li>
<li>Occorrono <code>K</code> bit, t.c. <code>2<sup>K</sup> &gt; N</code></li>
<li>Es. 4 bit per numeri naturali da 0 a 15</li>
<li>Un calcolatore assegna un numero fisso di bit per diversi tipi di informazione<ul>
<li>Casi di valori non rappresentabili</li>
<li><strong>Overflow</strong>, <strong>underflow</strong></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Esadecimale (Hex)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th>Dec</th>
<th>Bin</th>
<th>Hex</th>
<th>Dec</th>
<th>Bin</th>
<th>Hex</th>
<th>Dec</th>
<th>Bin</th>
<th>Hex</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>00</strong></td>
<td>0000 0000</td>
<td>00</td>
<td><strong>16</strong></td>
<td>0001 0000</td>
<td>10</td>
<td><strong>32</strong></td>
<td>0010 0000</td>
<td>20</td>
</tr>
<tr>
<td><strong>01</strong></td>
<td>0000 0001</td>
<td>01</td>
<td><strong>17</strong></td>
<td>0001 0001</td>
<td>11</td>
<td><strong>33</strong></td>
<td>0010 0001</td>
<td>21</td>
</tr>
<tr>
<td><strong>02</strong></td>
<td>0000 0010</td>
<td>02</td>
<td><strong>18</strong></td>
<td>0001 0010</td>
<td>12</td>
<td><strong>34</strong></td>
<td>0010 0010</td>
<td>22</td>
</tr>
<tr>
<td><strong>03</strong></td>
<td>0000 0011</td>
<td>03</td>
<td><strong>19</strong></td>
<td>0001 0011</td>
<td>13</td>
<td><strong>35</strong></td>
<td>0010 0011</td>
<td>23</td>
</tr>
<tr>
<td><strong>04</strong></td>
<td>0000 0100</td>
<td>04</td>
<td><strong>20</strong></td>
<td>0001 0100</td>
<td>14</td>
<td><strong>36</strong></td>
<td>0010 0100</td>
<td>24</td>
</tr>
<tr>
<td><strong>05</strong></td>
<td>0000 0101</td>
<td>05</td>
<td><strong>21</strong></td>
<td>0001 0101</td>
<td>15</td>
<td><strong>37</strong></td>
<td>0010 0101</td>
<td>25</td>
</tr>
<tr>
<td><strong>06</strong></td>
<td>0000 0110</td>
<td>06</td>
<td><strong>22</strong></td>
<td>0001 0110</td>
<td>16</td>
<td><strong>38</strong></td>
<td>0010 0110</td>
<td>26</td>
</tr>
<tr>
<td><strong>07</strong></td>
<td>0000 0111</td>
<td>07</td>
<td><strong>23</strong></td>
<td>0001 0111</td>
<td>17</td>
<td><strong>39</strong></td>
<td>0010 0111</td>
<td>27</td>
</tr>
<tr>
<td><strong>08</strong></td>
<td>0000 1000</td>
<td>08</td>
<td><strong>24</strong></td>
<td>0001 1000</td>
<td>18</td>
<td><strong>40</strong></td>
<td>0010 1000</td>
<td>28</td>
</tr>
<tr>
<td><strong>09</strong></td>
<td>0000 1001</td>
<td>09</td>
<td><strong>25</strong></td>
<td>0001 1001</td>
<td>19</td>
<td><strong>41</strong></td>
<td>0010 1001</td>
<td>29</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>0000 1010</td>
<td>0A</td>
<td><strong>26</strong></td>
<td>0001 1010</td>
<td>1A</td>
<td><strong>42</strong></td>
<td>0010 1010</td>
<td>2A</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>0000 1011</td>
<td>0B</td>
<td><strong>27</strong></td>
<td>0001 1011</td>
<td>1B</td>
<td><strong>43</strong></td>
<td>0010 1011</td>
<td>2B</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>0000 1100</td>
<td>0C</td>
<td><strong>28</strong></td>
<td>0001 1100</td>
<td>1C</td>
<td><strong>44</strong></td>
<td>0010 1100</td>
<td>2C</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>0000 1101</td>
<td>0D</td>
<td><strong>29</strong></td>
<td>0001 1101</td>
<td>1D</td>
<td><strong>45</strong></td>
<td>0010 1101</td>
<td>2D</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td>0000 1110</td>
<td>0E</td>
<td><strong>30</strong></td>
<td>0001 1110</td>
<td>1E</td>
<td><strong>46</strong></td>
<td>0010 1110</td>
<td>2E</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td>0000 1111</td>
<td>0F</td>
<td><strong>31</strong></td>
<td>0001 1111</td>
<td>1F</td>
<td><strong>47</strong></td>
<td>0010 1111</td>
<td>2F</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Bin ↔ Hex</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/4bits.png">
        
      </figure><p><img alt="" src="images/repr/bin-hex.png" /></p>
<ul>
<li>Ogni gruppo di 4 bit: 16 configurazioni diverse (2<sup>4</sup> = 16)</li>
<li>Ciascuna combinazione corrisponde ad uno dei 16 simboli esadecimali</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Somma e sottrazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Binary"><code>    1   1
0 0 0 1 0 1 1 0 +
0 0 0 1 0 1 0 1 =
-----------------
0 0 1 0 1 0 1 1
</code></pre>
<pre class="prettyprint" data-lang="Binary"><code>            0 10
0 0 0 0 1 1 1 0 -
0 0 0 0 0 1 0 1 =
-----------------
0 0 0 0 1 0 0 1
</code></pre>
<p>Attenzione a riporto e prestito (in alto)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Moltiplicazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Binary"><code>        1 0 1 1 x
        1 1 0 1 =
        ---------
        1 0 1 1 +
      0 0 0 0
    -------------
      0 1 0 1 1 +
    1 0 1 1
  ---------------
    1 1 0 1 1 1 +
  1 0 1 1
-----------------
1 0 0 0 1 1 1 1
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Divisione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Binary"><code>1 0 1 1 0 1 : 1 1
0 0          ---------
-----         0 1 1 1 1
1 0 1 -
  1 1
-------
  1 0 1 -
    1 1
  -------
    1 0 0 -
      1 1
    -------
        1 1 -
        1 1
        -----
        0 0
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Numeri interi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Occorre rappresentare anche i numeri negativi<ul>
<li>Necessario riservare un bit per il segno</li>
<li>Ovvero, si dimezza il massimo modulo ammesso</li>
</ul>
</li>
<li><strong>Modulo e segno</strong><ul>
<li>Il primo bit indica il segno</li>
<li>0 positivo, 1 negativo</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Complemento a due</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/4bits-sign.png">
        
      </figure><ul>
<li>Rappresentazione alternativa, <em>diversa da modulo e segno!</em></li>
<li>Numero negativo, ottenuto dal suo opposto positivo<ul>
<li>Complemento il numero <br> (cambio gli 1 con 0 e viceversa)</li>
<li>Sommo 1</li>
</ul>
</li>
<li>Anche così, il primo bit indica il segno<ul>
<li>0 positivo, 1 negativo </li>
</ul>
</li>
<li><em>Attenzione</em>: bisogna conoscere codifica e num bit<ul>
<li>Esempi seguenti: ogni intero con segno memorizzato in un singolo byte</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Es. numero intero</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Avendo un byte, +35 è in binario: <strong><code>0</code></strong><code>0100011</code></li>
<li>Numero –35, in modulo e segno: <strong><code>1</code></strong><code>0100011</code></li>
<li>Numero –35, in complemento a due: <strong><code>1</code></strong><code>1011101</code></li>
</ul>
<pre class="prettyprint" data-lang="Binary"><code>0 0 1 0 0 0 1 1 ¬
-----------------
1 1 0 1 1 1 0 0 +
              1 =
-----------------
1 1 0 1 1 1 0 1
</code></pre>
<p><code>¬</code>: complemento semplice, bit a bit</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Somma con segno</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sommare 12 e -35 su 8 bit, modulo e segno<ul>
<li>Sottrazione tra 35 e 12</li>
<li>Cambio di segno</li>
</ul>
</li>
<li>Stessa operazione, complemento due<ul>
<li>Semplice somma: <code>12 + -35 = -23</code></li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="Binary"><code>0 0 0 0 1 1 0 0 +
1 1 0 1 1 1 0 1 =
-----------------
1 1 1 0 1 0 0 1
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Numeri reali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Insieme continuo, per grandezze analogiche<ul>
<li>Rappresentabili solo in modo approssimato</li>
</ul>
</li>
<li>Parte frazionaria:<ul>
<li><code>F = c<sub>-1</sub> · base<sup>-1</sup> + … + c<sub>-n</sub> · base<sup>-n</sup></code></li>
</ul>
</li>
<li>Due rappresentazioni <em>alternative</em><ul>
<li><strong>Virgola fissa</strong>: segno, parte intera, parte decimale</li>
<li><strong>Virgola mobile</strong>: segno, mantissa, esponente</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Parte frazionaria in binario</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Moltiplicare la parte frazionaria per 2</li>
<li>Assegnare la parte intera del risultato come valore del bit <em>(loop)</em></li>
<li>Ossia: continuare a moltiplicare per 2 la parte frazionaria del risultato... <br> finché non si annulla</li>
</ul>
<table>
<thead>
<tr>
<th>fract</th>
<th>fract*B</th>
<th>int</th>
<th>peso</th>
</tr>
</thead>
<tbody>
<tr>
<td>0,375</td>
<td>0,750</td>
<td>0</td>
<td>2<sup>-1</sup></td>
</tr>
<tr>
<td>0,750</td>
<td>1,500</td>
<td>1</td>
<td>2<sup>-2</sup></td>
</tr>
<tr>
<td>0,500</td>
<td>1,000</td>
<td>1</td>
<td>2<sup>-3</sup></td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Virgola fissa</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Numero espresso come: <code>r = (i, f)</code><ul>
<li><strong><code>i</code></strong> è la parte intera, <code>n<sub>1</sub></code> bit</li>
<li><strong><code>f</code></strong> è la parte frazionaria, <code>n<sub>2</sub></code> bit</li>
</ul>
</li>
<li>Precisione costante lungo l’asse reale<ul>
<li>P.es. <code>f</code> di 3 bit, valori consecutivi sempre distanziati di 1/8</li>
</ul>
</li>
</ul>
<p><img alt="" src="images/repr/fixed-point.png" /></p></article>
 
</slide>

<slide class="large-image" >
  
    <hgroup>
      <h2>Virgola mobile</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Numero espresso come: <code>r = ±(1+f)·2<sup>e</sup></code><ul>
<li><strong><code>e</code></strong> è l'esponente intero (o caratteristica), <code>n<sub>1</sub></code> bit</li>
<li><strong><code>f</code></strong> è la parte frazionaria <em>(0 ≤ f &lt; 1)</em>, <code>n<sub>2</sub></code> bit</li>
<li><code>2</code> è la base, <code>1+f</code> è anche detto <em>mantissa</em></li>
</ul>
</li>
<li>Precisione variabile lungo l’asse reale; p.es.:<ul>
<li><code>f ∈ {0, 1/4, 2/4, 3/4}</code>, 2 bit <br> <code>e ∈ {-2, -1, 0, 1}</code>, 2 bit</li>
</ul>
</li>
</ul>
<p><img alt="" src="images/repr/float4.png" /></p>
<blockquote></blockquote>
<p><a href="http://www.mathworks.com/company/newsletters/news_notes/pdf/Fall96Cleve.pdf">http://www.mathworks.com/company/newsletters/news_notes/pdf/Fall96Cleve.pdf</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>IEEE 754</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>-118.625 = -1110110.101<sub>2</sub> = -1.110110101<sub>2</sub> × 2<sup>6</sup></code></li>
<li>All’esponente, su 8 bit, bisogna sommare <code>127</code> (<code>=2<sup>8 − 1</sup> − 1</code>)</li>
</ul>
<p><img alt="" src="images/repr/ieee754-32-ex.svg" />
<img alt="" src="images/repr/ieee754-32.svg" />
<img alt="" src="images/repr/ieee754-64.svg" /></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Algebra di Boole</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Algebra di Boole</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>L’algebra di Boole è un formalismo che opera su variabili (dette <em>variabili booleane</em>)</li>
<li>Le variabili booleane possono assumere due soli valori: <code>vero</code>, <code>falso</code></li>
<li>Sulle variabili booleane è possibile definire delle funzioni (dette <em>funzioni booleane</em>)</li>
<li>Anche le funzioni booleane possono assumere solo i due valori <code>vero</code> e <code>falso</code></li>
</ul></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Funzione e tabella di verità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Una <em>tabella di verità</em> permette di definire una <em>funzione booleana</em></li>
<li>Valore risultante per ciascuna combinazione dei valori in ingresso</li>
<li>A volte, <em>specifica incompleta</em> (certe combinazioni di ingressi non possono verificarsi) → Non è specificato alcun valore</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F<sub>1</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Espressione booleana</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/repr/hair-logic.svg">
        
      </figure><ul>
<li>Algebra di Boole: basata su un insieme di operatori</li>
<li>Possono essere combinati in espressioni</li>
<li>Altra forma di definizione di funzioni booleane</li>
<li>Es. <code>F<sub>2</sub>(A, B, C) = A·B + C</code></li>
</ul>
<table>
<thead>
<tr>
<th>Operatore</th>
<th>Simbolo</th>
</tr>
</thead>
<tbody>
<tr>
<td>And</td>
<td>· (∧)</td>
</tr>
<tr>
<td>Or</td>
<td>+ (∨)</td>
</tr>
<tr>
<td>Not</td>
<td>¬</td>
</tr>
<tr>
<td>Xor</td>
<td>⊕</td>
</tr>
<tr>
<td>Nand</td>
<td>↑</td>
</tr>
<tr>
<td>Nor</td>
<td>↓</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Operatori principali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A·B</th>
<th>A+B</th>
<th>A⊕B</th>
<th>A↑B</th>
<th>A↓B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>A</th>
<th>¬A</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Proprietà degli operatori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <table>
<thead>
<tr>
<th>Proprietà</th>
<th>Not</th>
</tr>
</thead>
<tbody>
<tr>
<td>Complemento</td>
<td>¬¬A = A</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Proprietà</th>
<th>And</th>
<th>Or</th>
</tr>
</thead>
<tbody>
<tr>
<td>Commutativa</td>
<td>A · B = B · A</td>
<td>A + B = B + A</td>
</tr>
<tr>
<td>Associativa</td>
<td>(A·B) · C = A · (B·C)</td>
<td>(A+B) + C = A + (B+C)</td>
</tr>
<tr>
<td>Distributiva</td>
<td>A + (B·C) = (A+B) · (A+C)</td>
<td>A · (B+C) = (A·B) + (A·C)</td>
</tr>
<tr>
<td>Idempotenza</td>
<td>A · A = A</td>
<td>A + A = A</td>
</tr>
<tr>
<td>Identità</td>
<td>A · 1 = A</td>
<td>A + 0 = A</td>
</tr>
<tr>
<td>Del limite</td>
<td>A · 0 = 0</td>
<td>A + 1 = 1</td>
</tr>
<tr>
<td>Assorbimento</td>
<td>A · (A + B) = A</td>
<td>A + (A · B) = A</td>
</tr>
<tr>
<td>Inverso</td>
<td>A · ¬ A = 0</td>
<td>A + ¬A = 1</td>
</tr>
<tr>
<td>De Morgan</td>
<td>¬(A·B·C…) = ¬A + ¬B + ¬C…</td>
<td>¬(A+B+C…) = ¬A · ¬B · ¬C…</td>
</tr>
</tbody>
</table>
<blockquote></blockquote>
<p>Attenzione a De Morgan: errore comune!</p></article>
 
</slide>

<slide class="large-table" >
  
    <hgroup>
      <h2>Forme canoniche</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Somma di Prodotti (SP)</strong>: si considerano le righe a 1<ul>
<li><code>F<sub>1</sub>(A, B, C) = (¬A·¬B·¬C) + (¬A·B·C) + (A·¬B·C) + (A·B·¬C) + (A·B·C)</code></li>
</ul>
</li>
<li><strong>Prodotto di Somme (PS)</strong>: si considerano le righe a 0<ul>
<li><code>F<sub>1</sub>(A, B, C) = (A + B + ¬C) · (A + ¬B + C) · (¬A + B + C)</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>F<sub>1</sub></th>
<th>→ Forma canonica...</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>→ PS</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>→ SP</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>→ SP</td>
</tr>
</tbody>
</table></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Operazioni bit a bit in Python</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Python"><code>x, y, z, shift = 0, 0, 0, 0  # some int values
x &lt;&lt; shift  # x = x * (2^shift)
x &gt;&gt; shift  # x = x / (2^shift), con segno
x &amp; y       # AND applicato bit a bit
x | y       # OR applicato bit a bit
x ^ y       # XOR bit a bit
~x          # complemento di ogni bit

z = 0x0B    # hex value (11 dec)
z = 0b1011  # bin value (11 dec)

hex(11)     # '0x0b' (text)
bin(0x0B)   # '0b1011' (text)
</code></pre>
<p>Da non confondere con operatori logici (and, or, not)</p></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>