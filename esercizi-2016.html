<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Esercizi 2016</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/misc/geek-girl.jpg"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 1</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>1.1 Hello, user!</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/handshake.png">
        
      </figure><ul>
<li>Compilare ed eseguire il programma “<code>Hello world</code>”</li>
<li>In una versione successiva del programma...</li>
<li>Chiedere il nome all'utente e aggiungere tale nome al messaggio di saluto</li>
<li>Se il nome dell'utente è “<code>admin</code>”, mostrare inoltre il messaggio speciale “<code>At your command</code>”</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.2 Equazione di secondo grado</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/quadratic-eq.svg"><img src="images/misc/quadratic-formula.svg">
        
      </figure><ul>
<li>Chiedere all'utente i tre coefficienti <code>a, b, c</code> di una equazione di secondo grado<ul>
<li><code>ax<sup>2</sup> + bx + c = 0</code></li>
</ul>
</li>
<li>Comunicare all'utente che tipo di soluzioni presenta l'equazione<ul>
<li>Due soluzioni reali</li>
<li>Un'unica soluzione reale</li>
<li>Nessuna soluzione reale</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Non è richiesto il valore delle soluzioni</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.3 Equazione di 2° grado, con ciclo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/quadratic-eq.svg"><img src="images/misc/quadratic-formula.svg">
        
      </figure><ul>
<li>Riprendere l'esercizio 1.2</li>
<li>In caso di soluzioni reali, mostrare all'utente il loro valore</li>
<li>Chiedere infine all'utente se vuole valutare altre equazioni</li>
</ul>
<blockquote></blockquote>
<p>Racchiudere il programma in un ciclo <code>while</code> <br>
Per il calcolo della radice quadrata, utilizzare <code>sqrt(...)</code> <br>
All'inizio del programma: <code>from math import sqrt</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.4 Fattoriale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere un numero intero positivo <code>n</code></li>
<li>Calcolare il fattoriale del numero</li>
</ul>
<blockquote></blockquote>
<p>Moltiplicare tra loro i primi <code>n</code> numeri</p>
<p>Memorizzare in una variabile il risultato parziale; ad ogni ciclo, moltiplicarla per il nuovo numero</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.5 Divisori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente un numero <code>n</code></li>
<li>Mostrare tutti i divisori di <code>n</code></li>
</ul>
<blockquote></blockquote>
<p><code>n</code> è divisibile per <code>x</code> se <code>n % x == 0</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.6 Triangolo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/impossible-triangle.jpg">
        
      </figure><ul>
<li>Chiedere all'utente le lunghezze dei tre lati</li>
<li>Controllare se il triangolo è:<ul>
<li>Equilatero</li>
<li>Isoscele</li>
<li>Scaleno</li>
<li>Oppure se i tre lati non formano affatto un triangolo</li>
</ul>
</li>
<li>Visualizzare il responso</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.7 Massimo e minimo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/data-sequence.png">
        
      </figure><ul>
<li>Leggere, attraverso un ciclo, una sequenza di numeri interi</li>
<li>La sequenza termina quando l'utente inserisce il valore 0</li>
<li>Visualizzare il valore massimo e quello minimo tra i numeri inseriti</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.8 Passeggiata casuale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chidere all'utente un numero <code>n</code></li>
<li>A partire dalla posizione <code>x = 0, y = 0</code></li>
<li>Compiere <code>n</code> passi, ciascuno in una direzione casuale<ul>
<li>Estrarre un numero casuale <code>r</code> tra 0 e 3</li>
<li>Se <code>r == 0</code>, sottrarre 1 alla <code>y</code> attuale (alto)</li>
<li>Se <code>r == 1</code>, sommare 1 alla <code>x</code> attuale (destra)</li>
<li>Se <code>r == 2</code>, sommare 1 alla <code>y</code> attuale (basso)</li>
<li>Se <code>r == 3</code>, sottrarre 1 alla <code>x</code> attuale (sinistra)</li>
</ul>
</li>
<li>Al termine comunicare le coordinate finali e la distanza raggiunta dall'origine, calcolata come <code>abs(x) + abs(y)</code></li>
</ul>
<pre class="prettyprint" data-lang="python"><code>from random import randrange
# ...
r = randrange(4)  # something between 0 and 3
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.9 Tre carte</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/three-cards.png">
        
      </figure><ul>
<li>All'inizio l'utente ha 10 monete</li>
<li>Ad ogni turno:<ul>
<li>Viene estratto a sorte un numero segreto tra 1 e 3</li>
<li>L'utente sceglie quante monete puntare e su quale numero</li>
<li>Se indovina, gli viene sommato l'importo puntato</li>
<li>Altrimenti gli viene sottratto lo stesso importo</li>
</ul>
</li>
<li>Il gioco termina quando l'utente perde tutto o si ritira</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 2</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>2.1 Percentuale di maiuscole</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/troll-key.png">
        
      </figure><ul>
<li>Chiedere una riga di testo all'utente</li>
<li>Mostrare la percentuale di lettere maiuscole presenti</li>
</ul>
<blockquote></blockquote>
<p>Usare un ciclo <code>for</code> sulla stringa</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.2 Valori sopra e sotto la media</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente una sequenza in interi, terminata da 0</li>
<li>Calcolare e mostrare il valore medio</li>
<li>Elencare i valori sotto alla media</li>
<li>Elencare i valori sopra (o uguali) alla media</li>
</ul>
<blockquote></blockquote>
<p>Aggiungere ciascun valore ad una lista inizialmente vuota, con <code>append</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.3 Funzione, Erone</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/triangle-notations.svg">
        
      </figure><ul>
<li>Definire una funzione <code>heron</code> per il calcolo dell'area di un triangolo<ul>
<li>Parametri: tre lati come <code>float</code></li>
<li>Risultato: area come <code>float</code></li>
</ul>
</li>
<li>Invocare la funzione dalla shell interattiva</li>
<li>Aggiungere poi al programma una funzione <code>main</code><ul>
<li><em>Procedura, senza parametri e senza risultato</em></li>
<li>Chiedere all'utente tre valori (chiamando <code>input</code>)</li>
<li>Poi chiamare <code>heron</code> con questi parametri</li>
<li>Infine mostrare all'utente il risultato (chiamando <code>print</code>)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Formula di Erone: <code>area = sqrt(s * (s - a) * (s - b) * (s - c))</code> <br>
Con <code>s = (a + b + c) / 2</code>, semiperimetro</p>
<p><a href="http://en.wikipedia.org/wiki/Heron%27s_formula">http://en.wikipedia.org/wiki/Heron%27s_formula</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.4 Sequenza di quadrati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/green-squares.png">
        
      </figure><ul>
<li>Chiedere all'utente il numero di quadrati da disegnare</li>
<li>Disegnare i quadrati con lato decrescente, tutti allineati in alto e a sinistra</li>
<li>Far variare il colore dei quadrati<ul>
<li>Dal nero del quadrato più grande</li>
<li>Fino al verde del quadrato più piccolo</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a disegnare un grosso quadrato nero</p>
<p>Poi, inserire l'operazione di disegno un ciclo, aggiungendo ad ogni passo <code>10</code> (p.es.) al livello di verde, e togliendo lo stesso valore al lato</p>
<p>Infine, determinare automaticamente le variazioni migliori per lato e colore, prima di iniziare il ciclo</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.5 Griglia di colori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/color-grid.png"><img src="images/oop/raster-tile.png">
        
      </figure><ul>
<li>Chidere all'utente dei valori per <code>rows</code> e <code>cols</code></li>
<li>Mostrare una griglia di rettangoli di dimensione <code>rows×cols</code></li>
<li>Partire da un rettangolo nero in alto a sinistra</li>
<li>In orizzontale, aumentare gradatamente la componente di blu</li>
<li>In verticale, aumentare gradatamente la componente di verde</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a creare una griglia di riquadri tutti neri, con due cicli <code>for</code> annidati</p>
<p>Lasciare tra i riquadri un piccolo margine</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.6 Triangolo di cifre</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere un numero intero positivo <code>n</code> (&lt; 10)</li>
<li>Per ciascun valore <code>y</code> tra 1 ed <code>n</code>...</li>
<li>Stampare una riga con le cifre da 1 ad <code>y</code></li>
</ul>
<pre class="prettyprint" data-lang="Output"><code>1
12
123
1234
</code></pre>
<p>Usare due cicli for annidati <br>
All'inizio non considerare <code>n</code>, ma fissare <code>y</code> e scrivere una sola riga: <code>y = 3</code> → <code>“123”</code> <br>
Poi racchiudere tutto in un ciclo for esterno</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.7 Nomi sopra e sotto la media</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/high-scores.jpg">
        
      </figure><ul>
<li>Chiedere all'utente una sequenza di dati, come coppie <em>(nome, valore)</em><ul>
<li>Ciascun nome (<code>str</code>) è associato ad un valore (<code>int</code>)</li>
<li>La sequenza termina quando il nome è vuoto</li>
</ul>
</li>
<li>Calcolare e mostrare il valore medio</li>
<li>Elencare i nomi con valori sotto alla media</li>
<li>Elencare i nomi con valori sopra (o uguali) alla media</li>
</ul>
<blockquote></blockquote>
<p>Inserire nella lista delle tuple, cioè coppie <em>(nome, valore)</em></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.8 Istogramma con barre orizzontali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram-rot.png">
        
      </figure><ul>
<li>Chiedere all'utente una lista di valori positivi<ul>
<li>La lista termina quando l'utente inserisce il valore <code>0</code></li>
</ul>
</li>
<li>Mostrare un istogramma<ul>
<li>Larghezza di ciascuna barra proporzionale al valore corrispondente</li>
<li>La barra più lunga occupa tutto lo spazio disponibile</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.9 Istogramma con barre verticali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram.png">
        
      </figure><ul>
<li>Chiedere all'utente una lista di valori positivi<ul>
<li>La lista termina quando l'utente inserisce il valore <code>0</code></li>
</ul>
</li>
<li>Mostrare un istogramma<ul>
<li>Altezza di ciascuna barra proporzionale al valore corrispondente</li>
<li>La barra più alta occupa tutto lo spazio disponibile</li>
<li>Barre in blu, per valori sotto alla media</li>
<li>Barre in rosso, per valori sopra (o uguali) alla media</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 3</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>3.1 Classe dei pianeti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/trigonometry.svg">
        
      </figure><ul>
<li>Scrivere una classe <code>Planet</code>, con dati (campi privati):<ul>
<li>Raggio <code>r</code> dell'orbita: distanza dall'origine degli assi</li>
<li>Angolo <code>theta</code> attuale rispetto all'asse <em>x</em> (coordinate polari)</li>
</ul>
</li>
<li>Operazioni (metodi pubblici):<ul>
<li><code>pos</code>: fornisce la posizione attuale come tupla <code>(x, y)</code></li>
</ul>
</li>
<li>Nella parte principale del programma:<ul>
<li>Creare un oggetto pianeta, con dati forniti all'utente</li>
<li>Invocare il metodo <code>pos</code> per ottenere le coord. cartesiane</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Distinguere bene campi dell'oggetto, parametri dei metodi, variabili esterne</p>
<p>Opzionalmente, nel costruttore ricevere come parametri <code>x</code> e <code>y</code> iniziali, da cui inizializzare i campi <code>r</code> e <code>theta</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.2 Pianeta in rivoluzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere ai dati di <code>Planet</code> (es. 3.1) una velocità angolare <code>omega</code><ul>
<li>Gradi di rotazione del pianeta attorno all'origine, ad ogni turno</li>
</ul>
</li>
<li>Aggiungere un metodo <code>move</code><ul>
<li>Pianeta percorre un piccolo arco attorno all'origine</li>
<li>Ad ogni chiamata, sommare <code>omega</code> all'attuale <code>theta</code></li>
</ul>
</li>
<li>In <code>main</code> (<em>senza grafica</em>), creare un pianeta<ul>
<li>Ciclicamente, chiamare il metodo <code>move</code> del pianeta...</li>
<li>E stampare la posizione restituita dal metodo <code>pos</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.3 Rimbalzi con gravità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/bouncing-ball.jpg">
        
      </figure><ul>
<li>Partire dall'esempio di animazione visto a lezione (<em>senza oggetti</em>)</li>
<li>Un rettangolo si muove orizzontalmente, p.es. di <code>10</code> pixel alla volta</li>
<li>Percorso ciclico del rettangolo<ul>
<li>Quando esce dallo schermo, rientra dalla parte opposta</li>
</ul>
</li>
<li>Aggiungere al rettangolo un effetto di gravità<ul>
<li>Definire una variabile <code>dy</code>: componente di velocità verticale (inizialmente <code>0</code>)</li>
<li>Ad ogni ciclo, aggiungere a <code>dy</code> una piccola quantità costante (es. <code>g = 0.4</code>)</li>
<li>Quando si tocca il fondo, cambiare il segno di <code>dy</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.4 Animazione di un pianeta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire dall'esempio di animazione visto a lezione</li>
<li>Aggiungere ai dati del pianeta (es. 3.2) anche la sua dimensione come <code>diameter</code>, con un corrispondente metodo <em>getter</em></li>
<li>Rappresentare il movimento del pianeta dell'esercizio 3.2<ul>
<li>Per ogni frame, chiamare il metodo <code>move</code> del pianeta</li>
<li>Rappresentare un cerchio nella posizione aggiornata del pianeta</li>
</ul>
</li>
<li>Traslare il disegno, <em>senza modificare la classe</em>, in modo che l'origine degli assi sia al centro della finestra</li>
</ul>
<blockquote></blockquote>
<p>L'asse <em>y</em> può rimanere orientato verso il basso</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.5 Lista di pianeti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/solar-system.jpg">
        
      </figure><ul>
<li>Aggiungere ai dati del pianeta (es. 3.4) anche un colore come tupla <code>RGB</code>, con un corrispondente metodo <em>getter</em></li>
<li>Anzichè un solo pianeta, crearne diversi ed inserirli in una lista</li>
<li>Rappresentare graficamente il movimento di tutti i pianeti<ul>
<li>Per ogni frame, in un ciclo <code>for</code>, chiamare il metodo <code>move</code> di ogni pianeta</li>
<li>Rappresentare un cerchio colorato nella posizione aggiornata di ogni pianeta</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.6 Classe degli esami</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/college-student.jpg">
        
      </figure><ul>
<li>Scrivere una classe <code>Exam</code> per rappresentare gli esami sostenuti in un corso di studio<ul>
<li>Parametri del costruttore: <em>nome esame</em>; <em>numero crediti</em>; <em>data</em> (es. “<code>2016-10-14</code>”); <em>voto</em> (da 18 a 30)</li>
</ul>
</li>
<li>Fornire metodo <code>estimate_work</code> per stimare le ore di studio, supponendo che...<ul>
<li>Ad ogni credito corrispondano ~ 25h di studio</li>
<li>Il voto sia direttamente proporzionale allo studio</li>
</ul>
</li>
<li>Nel <code>main</code>, istanziare un esame con valori forniti all'utente, invocare il metodo e mostrare il valore stimato</li>
</ul>
<blockquote></blockquote>
<p>Es.: Un esame da 9 crediti corrisponde a 225h di studio; per prendere 24, in proporzione dovrei studiare 180h</p>
<p>Tenere l'uso della console per I/O fuori dalla classe!</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.7 Scrittura di risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Simulare <code>n</code> lanci di una coppia di dadi<ul>
<li><code>n</code> scelto dall'utente</li>
</ul>
</li>
<li>Scrivere il risultato dei lanci in un file<ul>
<li>In ogni riga, inserire i due valori separati da spazio</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.8 Analisi di risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Leggere i dati dal file generato nell'esercizio 3.7</li>
<li>Per ogni coppia di valori letta, mostrare all'utente la loro somma</li>
<li>Contare quante volte, in tutto, si presenta ciascun risultato<ul>
<li>Risultati possibili: da 2 a 12</li>
<li>Somma dei due dadi</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Per conteggiare i vari risultati, usare una lista di (almeno) 11 valori</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.9 Battaglia navale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/battleship-2.png">
        
      </figure><ul>
<li>Allocare una matrice <code>rows×cols</code> (dimensioni scelte dall'utente)</li>
<li>Ripetutamente...<ul>
<li>Chiedere all'utente un numero <code>size</code></li>
<li>Riempire con '<code>+</code>' un numero <code>size</code> di celle adiacenti (direzione e posizione di partenza casuali)</li>
<li>Opzionalmente, evitare inserimenti sovrapposti oppure oltre i bordi</li>
<li>Mostrare la matrice risultante</li>
</ul>
</li>
<li>All'uscita del programma, salvare la matrice in un file di testo</li>
</ul>
<blockquote></blockquote>
<p>Si può usare una lista come pseudo-matrice, oppure una lista di liste</p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 4</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>4.1 Massimo valore, con ricorsione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/matryoshka.png">
        
      </figure><ul>
<li>Definire una funzione ricorsiva <code>max_char</code><ul>
<li>Cerca, in una stringa di testo, il carattere con codice Unicode massimo</li>
</ul>
</li>
<li>Se il testo ha lunghezza 1, l'unico carattere è quello massimo</li>
<li>Altrimenti il carattere con codice massimo è pari al maggiore tra:<ul>
<li>Il primo carattere</li>
<li>Il carattere con codice massimo tra tutti gli altri (ricorsione)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Saranno accettate esclusivamente le soluzioni ricorsive</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.2 Pallina in caduta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/bouncing-ball.jpg">
        
      </figure><ul>
<li>Creare una classe <code>FallingBall</code><ul>
<li>Partire dal codice di <code>Ball</code> in <code>p4_ball</code> (esempio a lezione)</li>
<li>Mantenere stessi campi e metodi</li>
</ul>
</li>
<li>Aggiungere un campo <code>g</code> (<code>float</code>)<ul>
<li>Accelerazione di gravità, costante, verso il basso</li>
<li>Ad ogni esecuzione, il metodo <code>move</code> aggiunge <code>g</code> a <code>dy</code></li>
</ul>
</li>
<li>Nel <code>main</code>: istanziare un oggetto <code>FallingBall</code><ul>
<li>Chiamare ciclicamente <code>move</code></li>
<li>Visualizzare un rettangolo (o una immagine) nella posizione attuale</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.3 Attori astratti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire dalla classe <code>Actor</code> (astratta) definita qui sotto</li>
<li>Ridefinire <code>FallingBall</code> (es. 4.2) come sottoclasse di <code>Actor</code></li>
<li>Definire una classe <code>Plane</code>, come sottoclasse di <code>Actor</code><ul>
<li>Implementare un semplice movimento orizzontale ciclico</li>
</ul>
</li>
<li>Nel programma principale, creare una lista di personaggi misti (palline e aerei)<ul>
<li>Chiamare il metodo <code>move</code> di ciascuno ad ogni ciclo</li>
<li>Visualizzare un rettangolo (o una immagine) nella posizione corrispondente</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>class Actor:
    def move(self): pass
    def rect(self) -&gt; (int, int, int, int): pass
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.4 Collisione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire dalle classi <code>Arena</code> e <code>Actor</code> del modulo <code>actor</code> fornito</li>
<li>Ridefinire <code>FallingBall</code> e <code>Plane</code> (es. 4.3) come sottoclassi di <code>Actor</code><ul>
<li>Implementare i metodi mancanti</li>
</ul>
</li>
<li>Gestire le collisioni nel metodo <code>collide</code><ul>
<li>Un oggetto <code>Plane</code> inverte la direzione, quando urta un oggetto <code>FallingBall</code></li>
</ul>
</li>
<li>Nel programma principale, creare una <code>arena</code> con personaggi misti (palline e aerei)<ul>
<li>Chiamare il metodo <code>move_all</code> ad ogni ciclo</li>
<li>Visualizzare un rettangolo nella posizione corrispondente</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.5 Scroll</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/viewport.png">
        
      </figure><ul>
<li>Associare a ciascun tipo di personaggio dell'es. 4.4 una immagine</li>
<li>Creare un'arena di gioco (<em>game world</em>) più ampia della finestra</li>
<li>Usare per lo sfondo una immagine grande quanto l'intera arena di gioco</li>
<li>Permettere infine all'utente di spostare l'inquadratura assegnata alla finestra (<em>viewport</em>), usando i tasti cursore</li>
</ul>
<blockquote></blockquote>
<p>Non modificare le classi dei personaggi, nè <code>Arena</code></p>
<p>Aggiugere invece un <em>offset</em>, in fase di visualizzazione, alle coordinate dei personaggi per decidere il punto in cui disegnarli nella finestra</p>
<p>Usare lo stesso <em>offset</em> anche per ritagliare la parte giusta dall'immagine di sfondo </p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.6 Circular infinity</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/crop-circle.jpg">
        
      </figure><ul>
<li>Disegnare ricorsivamente dei cerchi, con i centri allineati in verticale</li>
<li>Il riquadro iniziale è l'intera finestra</li>
<li>Tracciare un cerchio contenuto nel riquadro <code>(x, y, w, h)</code><ul>
<li><code>r = h / 2, xc = x + w / 2, yc = y + h / 2</code></li>
</ul>
</li>
<li>Dividere il riquadro in due metà</li>
<li>Applicare a ciascuno dei due riquadri il processo, ricorsivamente</li>
<li>Ad ogni livello, invertire il colore del cerchio disegnato</li>
</ul>
<blockquote></blockquote>
<p>Saranno accettate esclusivamente le soluzioni ricorsive</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.7 Tris</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/tic-tac-toe.svg">
        
      </figure><ul>
<li>Classe che modella una partita a <em>tris</em> (<em>Tic Tac Toe</em>)</li>
<li>Campi privati<ul>
<li>Matrice di gioco</li>
<li>Giocatore di turno: <code>O</code> oppure <code>X</code></li>
</ul>
</li>
<li>Metodi pubblici<ul>
<li>Mossa in una certa posizione <code>x, y</code> (simbolo scelto automaticamente nel metodo)</li>
<li>Rappresentazione stato: <code>__str__(self)</code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>Visualizzare lo stato risultante</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.8 Conclusione partita</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere metodi alla classe del <em>tris</em><ul>
<li>Controllo di conclusione: <code>bool</code></li>
<li>Eventuale vincitore: <code>O</code>, <code>X</code>, <code>None</code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>Visualizzare lo stato risultante</li>
<li>Comunicare l'eventuale conclusione della partita ed il vincitore</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.9 Valori in file CSV</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere una matrice di interi da un file testuale CSV<ul>
<li><em>Comma Separated Values</em>: valori riportati riga per riga e separati da una virgola</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="File"><code>5,7,2,11
1,3,12,9
4,6,10,8
</code></pre>
<ul>
<li>Memorizzare i dati in una lista semplice (pseudo-matrice)<ul>
<li>Inferire dimensioni della matrice (<code>rows×cols</code>) in base a:</li>
<li>Num. righe del file; num. valori nella prima riga</li>
</ul>
</li>
<li>Riscrivere in un altro file tutti i valori della matrice<ul>
<li>Raddoppiare però i valori sulla diagonale che parte dall'angolo in basso a destra (<code>cols - x == rows - y</code>)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Nell'esempio, i valori da raddoppiare in scrittura sono i seguenti: <code>8, 12, 7</code></p></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>