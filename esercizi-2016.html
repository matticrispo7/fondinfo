<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Esercizi 2016</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/misc/geek-girl.jpg"></figure>
  <hgroup>
    <h2>Introduzione alla programmazione</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 1</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>1.1 Hello, user!</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/handshake.png">
        
      </figure><ul>
<li>Compilare ed eseguire il programma “<code>Hello world</code>”</li>
<li>In una versione successiva del programma...</li>
<li>Chiedere il nome all'utente e aggiungere tale nome al messaggio di saluto</li>
<li>Se il nome dell'utente è “<code>admin</code>”, mostrare inoltre il messaggio speciale “<code>At your command</code>”</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.2 Equazione di secondo grado</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/quadratic-eq.svg"><img src="images/misc/quadratic-formula.svg">
        
      </figure><ul>
<li>Chiedere all'utente i tre coefficienti <code>a, b, c</code> di una equazione di secondo grado<ul>
<li><code>ax<sup>2</sup> + bx + c = 0</code></li>
</ul>
</li>
<li>Comunicare all'utente che tipo di soluzioni presenta l'equazione<ul>
<li>Due soluzioni reali</li>
<li>Un'unica soluzione reale</li>
<li>Nessuna soluzione reale</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Non è richiesto il valore delle soluzioni</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.3 Equazione di 2° grado, con ciclo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/quadratic-eq.svg"><img src="images/misc/quadratic-formula.svg">
        
      </figure><ul>
<li>Riprendere l'esercizio 1.2</li>
<li>In caso di soluzioni reali, mostrare all'utente il loro valore</li>
<li>Chiedere infine all'utente se vuole valutare altre equazioni</li>
</ul>
<blockquote></blockquote>
<p>Racchiudere il programma in un ciclo <code>while</code> <br>
Per il calcolo della radice quadrata, utilizzare <code>sqrt(...)</code> <br>
All'inizio del programma: <code>from math import sqrt</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.4 Fattoriale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere un numero intero positivo <code>n</code></li>
<li>Calcolare il fattoriale del numero</li>
</ul>
<blockquote></blockquote>
<p>Moltiplicare tra loro i primi <code>n</code> numeri</p>
<p>Memorizzare in una variabile il risultato parziale; ad ogni ciclo, moltiplicarla per il nuovo numero</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.5 Divisori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente un numero <code>n</code></li>
<li>Mostrare tutti i divisori di <code>n</code></li>
</ul>
<blockquote></blockquote>
<p><code>n</code> è divisibile per <code>x</code> se <code>n % x == 0</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.6 Triangolo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/impossible-triangle.jpg">
        
      </figure><ul>
<li>Chiedere all'utente le lunghezze dei tre lati</li>
<li>Controllare se il triangolo è:<ul>
<li>Equilatero</li>
<li>Isoscele</li>
<li>Scaleno</li>
<li>Oppure se i tre lati non formano affatto un triangolo</li>
</ul>
</li>
<li>Visualizzare il responso</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.7 Massimo e minimo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/data-sequence.png">
        
      </figure><ul>
<li>Leggere, attraverso un ciclo, una sequenza di numeri interi</li>
<li>La sequenza termina quando l'utente inserisce il valore 0</li>
<li>Visualizzare il valore massimo e quello minimo tra i numeri inseriti</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.8 Passeggiata casuale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chidere all'utente un numero <code>n</code></li>
<li>A partire dalla posizione <code>x = 0, y = 0</code></li>
<li>Compiere <code>n</code> passi, ciascuno in una direzione casuale<ul>
<li>Estrarre un numero casuale <code>r</code> tra 0 e 3</li>
<li>Se <code>r == 0</code>, sottrarre 1 alla <code>y</code> attuale (alto)</li>
<li>Se <code>r == 1</code>, sommare 1 alla <code>x</code> attuale (destra)</li>
<li>Se <code>r == 2</code>, sommare 1 alla <code>y</code> attuale (basso)</li>
<li>Se <code>r == 3</code>, sottrarre 1 alla <code>x</code> attuale (sinistra)</li>
</ul>
</li>
<li>Al termine comunicare le coordinate finali e la distanza raggiunta dall'origine, calcolata come <code>abs(x) + abs(y)</code></li>
</ul>
<pre class="prettyprint" data-lang="python"><code>from random import randrange
# ...
r = randrange(4)  # something between 0 and 3
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>1.9 Tre carte</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/three-cards.png">
        
      </figure><ul>
<li>All'inizio l'utente ha 10 monete</li>
<li>Ad ogni turno:<ul>
<li>Viene estratto a sorte un numero segreto tra 1 e 3</li>
<li>L'utente sceglie quante monete puntare e su quale numero</li>
<li>Se indovina, gli viene sommato l'importo puntato</li>
<li>Altrimenti gli viene sottratto lo stesso importo</li>
</ul>
</li>
<li>Il gioco termina quando l'utente perde tutto o si ritira</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 2</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>2.1 Percentuale di maiuscole</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/troll-key.png">
        
      </figure><ul>
<li>Chiedere una riga di testo all'utente</li>
<li>Mostrare la percentuale di lettere maiuscole presenti</li>
</ul>
<blockquote></blockquote>
<p>Usare un ciclo <code>for</code> sulla stringa</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.2 Valori sopra e sotto la media</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Chiedere all'utente una sequenza in interi, terminata da 0</li>
<li>Calcolare e mostrare il valore medio</li>
<li>Elencare i valori sotto alla media</li>
<li>Elencare i valori sopra (o uguali) alla media</li>
</ul>
<blockquote></blockquote>
<p>Aggiungere ciascun valore ad una lista inizialmente vuota, con <code>append</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.3 Funzione, Erone</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/triangle-notations.svg">
        
      </figure><ul>
<li>Definire una funzione <code>heron</code> per il calcolo dell'area di un triangolo<ul>
<li>Parametri: tre lati come <code>float</code></li>
<li>Risultato: area come <code>float</code></li>
</ul>
</li>
<li>Invocare la funzione dalla shell interattiva</li>
<li>Aggiungere poi al programma una funzione <code>main</code><ul>
<li><em>Procedura, senza parametri e senza risultato</em></li>
<li>Chiedere all'utente tre valori (chiamando <code>input</code>)</li>
<li>Poi chiamare <code>heron</code> con questi parametri</li>
<li>Infine mostrare all'utente il risultato (chiamando <code>print</code>)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Formula di Erone: <code>area = sqrt(s * (s - a) * (s - b) * (s - c))</code> <br>
Con <code>s = (a + b + c) / 2</code>, semiperimetro</p>
<p><a href="http://en.wikipedia.org/wiki/Heron%27s_formula">http://en.wikipedia.org/wiki/Heron%27s_formula</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.4 Sequenza di quadrati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/green-squares.png">
        
      </figure><ul>
<li>Chiedere all'utente il numero di quadrati da disegnare</li>
<li>Disegnare i quadrati con lato decrescente, tutti allineati in alto e a sinistra</li>
<li>Far variare il colore dei quadrati<ul>
<li>Dal nero del quadrato più grande</li>
<li>Fino al verde del quadrato più piccolo</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a disegnare un grosso quadrato nero</p>
<p>Poi, inserire l'operazione di disegno un ciclo, aggiungendo ad ogni passo <code>10</code> (p.es.) al livello di verde, e togliendo lo stesso valore al lato</p>
<p>Infine, determinare automaticamente le variazioni migliori per lato e colore, prima di iniziare il ciclo</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.5 Griglia di colori</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/color-grid.png"><img src="images/oop/raster-tile.png">
        
      </figure><ul>
<li>Chidere all'utente dei valori per <code>rows</code> e <code>cols</code></li>
<li>Mostrare una griglia di rettangoli di dimensione <code>rows×cols</code></li>
<li>Partire da un rettangolo nero in alto a sinistra</li>
<li>In orizzontale, aumentare gradatamente la componente di blu</li>
<li>In verticale, aumentare gradatamente la componente di verde</li>
</ul>
<blockquote></blockquote>
<p>Cominciare a creare una griglia di riquadri tutti neri, con due cicli <code>for</code> annidati</p>
<p>Lasciare tra i riquadri un piccolo margine</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.6 Triangolo di cifre</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere un numero intero positivo <code>n</code> (&lt; 10)</li>
<li>Per ciascun valore <code>y</code> tra 1 ed <code>n</code>...</li>
<li>Stampare una riga con le cifre da 1 ad <code>y</code></li>
</ul>
<pre class="prettyprint" data-lang="Output"><code>1
12
123
1234
</code></pre>
<p>Usare due cicli for annidati <br>
All'inizio non considerare <code>n</code>, ma fissare <code>y</code> e scrivere una sola riga: <code>y = 3</code> → <code>“123”</code> <br>
Poi racchiudere tutto in un ciclo for esterno</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.7 Nomi sopra e sotto la media</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/high-scores.jpg">
        
      </figure><ul>
<li>Chiedere all'utente una sequenza di dati, come coppie <em>(nome, valore)</em><ul>
<li>Ciascun nome (<code>str</code>) è associato ad un valore (<code>int</code>)</li>
<li>La sequenza termina quando il nome è vuoto</li>
</ul>
</li>
<li>Calcolare e mostrare il valore medio</li>
<li>Elencare i nomi con valori sotto alla media</li>
<li>Elencare i nomi con valori sopra (o uguali) alla media</li>
</ul>
<blockquote></blockquote>
<p>Inserire nella lista delle tuple, cioè coppie <em>(nome, valore)</em></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.8 Istogramma con barre orizzontali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram-rot.png">
        
      </figure><ul>
<li>Chiedere all'utente una lista di valori positivi<ul>
<li>La lista termina quando l'utente inserisce il valore <code>0</code></li>
</ul>
</li>
<li>Mostrare un istogramma<ul>
<li>Larghezza di ciascuna barra proporzionale al valore corrispondente</li>
<li>La barra più lunga occupa tutto lo spazio disponibile</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>2.9 Istogramma con barre verticali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/histogram.png">
        
      </figure><ul>
<li>Chiedere all'utente una lista di valori positivi<ul>
<li>La lista termina quando l'utente inserisce il valore <code>0</code></li>
</ul>
</li>
<li>Mostrare un istogramma<ul>
<li>Altezza di ciascuna barra proporzionale al valore corrispondente</li>
<li>La barra più alta occupa tutto lo spazio disponibile</li>
<li>Barre in blu, per valori sotto alla media</li>
<li>Barre in rosso, per valori sopra (o uguali) alla media</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 3</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>3.1 Classe dei pianeti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/trigonometry.svg">
        
      </figure><ul>
<li>Scrivere una classe <code>Planet</code>, con dati (campi privati):<ul>
<li>Raggio <code>r</code> dell'orbita: distanza dall'origine degli assi</li>
<li>Angolo <code>theta</code> attuale rispetto all'asse <em>x</em> (coordinate polari)</li>
</ul>
</li>
<li>Operazioni (metodi pubblici):<ul>
<li><code>pos</code>: fornisce la posizione attuale come tupla <code>(x, y)</code></li>
</ul>
</li>
<li>Nella parte principale del programma:<ul>
<li>Creare un oggetto pianeta, con dati forniti all'utente</li>
<li>Invocare il metodo <code>pos</code> per ottenere le coord. cartesiane</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Distinguere bene campi dell'oggetto, parametri dei metodi, variabili esterne</p>
<p>Opzionalmente, nel costruttore ricevere come parametri <code>x</code> e <code>y</code> iniziali, da cui inizializzare i campi <code>r</code> e <code>theta</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.2 Pianeta in rivoluzione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere ai dati di <code>Planet</code> (es. 3.1) una velocità angolare <code>omega</code><ul>
<li>Gradi di rotazione del pianeta attorno all'origine, ad ogni turno</li>
</ul>
</li>
<li>Aggiungere un metodo <code>move</code><ul>
<li>Pianeta percorre un piccolo arco attorno all'origine</li>
<li>Ad ogni chiamata, sommare <code>omega</code> all'attuale <code>theta</code></li>
</ul>
</li>
<li>In <code>main</code> (<em>senza grafica</em>), creare un pianeta<ul>
<li>Ciclicamente, chiamare il metodo <code>move</code> del pianeta...</li>
<li>E stampare la posizione restituita dal metodo <code>pos</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.3 Rimbalzi con gravità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/bouncing-ball.jpg">
        
      </figure><ul>
<li>Partire dall'esempio di animazione visto a lezione (<em>senza oggetti</em>)</li>
<li>Un rettangolo si muove orizzontalmente, p.es. di <code>10</code> pixel alla volta</li>
<li>Percorso ciclico del rettangolo<ul>
<li>Quando esce dallo schermo, rientra dalla parte opposta</li>
</ul>
</li>
<li>Aggiungere al rettangolo un effetto di gravità<ul>
<li>Definire una variabile <code>dy</code>: componente di velocità verticale (inizialmente <code>0</code>)</li>
<li>Ad ogni ciclo, aggiungere a <code>dy</code> una piccola quantità costante (es. <code>g = 0.4</code>)</li>
<li>Quando si tocca il fondo, cambiare il segno di <code>dy</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.4 Animazione di un pianeta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire dall'esempio di animazione visto a lezione</li>
<li>Aggiungere ai dati del pianeta (es. 3.2) anche la sua dimensione come <code>diameter</code>, con un corrispondente metodo <em>getter</em></li>
<li>Rappresentare il movimento del pianeta dell'esercizio 3.2<ul>
<li>Per ogni frame, chiamare il metodo <code>move</code> del pianeta</li>
<li>Rappresentare un cerchio nella posizione aggiornata del pianeta</li>
</ul>
</li>
<li>Traslare il disegno, <em>senza modificare la classe</em>, in modo che l'origine degli assi sia al centro della finestra</li>
</ul>
<blockquote></blockquote>
<p>L'asse <em>y</em> può rimanere orientato verso il basso</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.5 Lista di pianeti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/solar-system.jpg">
        
      </figure><ul>
<li>Aggiungere ai dati del pianeta (es. 3.4) anche un colore come tupla <code>RGB</code>, con un corrispondente metodo <em>getter</em></li>
<li>Anzichè un solo pianeta, crearne diversi ed inserirli in una lista</li>
<li>Rappresentare graficamente il movimento di tutti i pianeti<ul>
<li>Per ogni frame, in un ciclo <code>for</code>, chiamare il metodo <code>move</code> di ogni pianeta</li>
<li>Rappresentare un cerchio colorato nella posizione aggiornata di ogni pianeta</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.6 Classe degli esami</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/college-student.jpg">
        
      </figure><ul>
<li>Scrivere una classe <code>Exam</code> per rappresentare gli esami sostenuti in un corso di studio<ul>
<li>Parametri del costruttore: <em>nome esame</em>; <em>numero crediti</em>; <em>data</em> (es. “<code>2016-10-14</code>”); <em>voto</em> (da 18 a 30)</li>
</ul>
</li>
<li>Fornire metodo <code>estimate_work</code> per stimare le ore di studio, supponendo che...<ul>
<li>Ad ogni credito corrispondano ~ 25h di studio</li>
<li>Il voto sia direttamente proporzionale allo studio</li>
</ul>
</li>
<li>Nel <code>main</code>, istanziare un esame con valori forniti all'utente, invocare il metodo e mostrare il valore stimato</li>
</ul>
<blockquote></blockquote>
<p>Es.: Un esame da 9 crediti corrisponde a 225h di studio; per prendere 24, in proporzione dovrei studiare 180h</p>
<p>Tenere l'uso della console per I/O fuori dalla classe!</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.7 Scrittura di risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Simulare <code>n</code> lanci di una coppia di dadi<ul>
<li><code>n</code> scelto dall'utente</li>
</ul>
</li>
<li>Scrivere il risultato dei lanci in un file<ul>
<li>In ogni riga, inserire i due valori separati da spazio</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.8 Analisi di risultati casuali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dice.png">
        
      </figure><ul>
<li>Leggere i dati dal file generato nell'esercizio 3.7</li>
<li>Per ogni coppia di valori letta, mostrare all'utente la loro somma</li>
<li>Contare quante volte, in tutto, si presenta ciascun risultato<ul>
<li>Risultati possibili: da 2 a 12</li>
<li>Somma dei due dadi</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Per conteggiare i vari risultati, usare una lista di (almeno) 11 valori</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>3.9 Battaglia navale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/battleship-2.png">
        
      </figure><ul>
<li>Allocare una matrice <code>rows×cols</code> (dimensioni scelte dall'utente)</li>
<li>Ripetutamente...<ul>
<li>Chiedere all'utente un numero <code>size</code></li>
<li>Riempire con '<code>+</code>' un numero <code>size</code> di celle adiacenti (direzione e posizione di partenza casuali)</li>
<li>Opzionalmente, evitare inserimenti sovrapposti oppure oltre i bordi</li>
<li>Mostrare la matrice risultante</li>
</ul>
</li>
<li>All'uscita del programma, salvare la matrice in un file di testo</li>
</ul>
<blockquote></blockquote>
<p>Si può usare una lista come pseudo-matrice, oppure una lista di liste</p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 4</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>4.1 Massimo valore, con ricorsione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/fun/matryoshka.png">
        
      </figure><ul>
<li>Definire una funzione ricorsiva <code>max_char</code><ul>
<li>Cerca, in una stringa di testo, il carattere con codice Unicode massimo</li>
</ul>
</li>
<li>Se il testo ha lunghezza 1, l'unico carattere è quello massimo</li>
<li>Altrimenti il carattere con codice massimo è pari al maggiore tra:<ul>
<li>Il primo carattere</li>
<li>Il carattere con codice massimo tra tutti gli altri (ricorsione)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Saranno accettate esclusivamente le soluzioni ricorsive</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.2 Pallina in caduta</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/bouncing-ball.jpg">
        
      </figure><ul>
<li>Creare una classe <code>FallingBall</code><ul>
<li>Partire dal codice di <code>Ball</code> in <code>p4_ball</code> (esempio a lezione)</li>
<li>Mantenere stessi campi e metodi</li>
</ul>
</li>
<li>Aggiungere un campo <code>g</code> (<code>float</code>)<ul>
<li>Accelerazione di gravità, costante, verso il basso</li>
<li>Ad ogni esecuzione, il metodo <code>move</code> aggiunge <code>g</code> a <code>dy</code></li>
</ul>
</li>
<li>Nel <code>main</code>: istanziare un oggetto <code>FallingBall</code><ul>
<li>Chiamare ciclicamente <code>move</code></li>
<li>Visualizzare un rettangolo (o una immagine) nella posizione attuale</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.3 Lista di personaggi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire da classe <code>SimpleActor</code> (astratta) definita qui sotto</li>
<li>Ridefinire <code>FallingBall</code> (es. 4.2) come sottoclasse di <code>SimpleActor</code></li>
<li>Definire una classe <code>Plane</code>, come sottoclasse di <code>SimpleActor</code><ul>
<li>Implementare un semplice movimento orizzontale ciclico</li>
</ul>
</li>
<li>Nel programma principale, creare una <em>lista di personaggi misti</em> (palline e aerei)<ul>
<li>Chiamare il metodo <code>move</code> di ciascuno ad ogni ciclo</li>
<li>Visualizzare un rettangolo per ogni personaggio</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>class SimpleActor:
    def move(self): pass
    def rect(self) -&gt; (int, int, int, int): pass
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.4 Arena e collisioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partire da classi <code>Arena</code> e <code>Actor</code> del modulo <code>actor</code> fornito</li>
<li>Ridefinire <code>FallingBall</code> e <code>Plane</code> come sottoclassi di <code>Actor</code><ul>
<li>Implementare i metodi mancanti (partire da es. 4.3)</li>
</ul>
</li>
<li>Gestire le collisioni nel metodo <code>collide</code><ul>
<li>Un oggetto <code>Plane</code> inverte la direzione, quando urta un oggetto <code>FallingBall</code></li>
</ul>
</li>
<li>Nel programma principale, creare una <em>arena con personaggi misti</em> (palline e aerei)<ul>
<li>Chiamare il metodo <code>move_all</code> ad ogni ciclo</li>
<li>Visualizzare un rettangolo per ogni personaggio</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>from actor import Actor, Arena
class FallingBall(Actor):
    # ...
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.5 Scroll</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/viewport.png">
        
      </figure><ul>
<li>Associare a ciascun tipo di personaggio dell'es. 4.4 una immagine</li>
<li>Creare un'arena di gioco (<em>game world</em>) più ampia della finestra</li>
<li>Usare per lo sfondo una immagine grande quanto l'intera arena di gioco</li>
<li>Permettere infine all'utente di spostare l'inquadratura assegnata alla finestra (<em>viewport</em>), usando i tasti cursore</li>
</ul>
<blockquote></blockquote>
<p>Non modificare le classi dei personaggi, nè <code>Arena</code></p>
<p>Aggiugere invece un <em>offset</em>, in fase di visualizzazione, alle coordinate dei personaggi per decidere il punto in cui disegnarli nella finestra</p>
<p>Usare lo stesso <em>offset</em> anche per ritagliare la parte giusta dall'immagine di sfondo </p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.6 Circular infinity</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/crop-circle.jpg">
        
      </figure><ul>
<li>Disegnare ricorsivamente dei cerchi, con i centri allineati in verticale</li>
<li>Il riquadro iniziale è l'intera finestra</li>
<li>Tracciare un cerchio contenuto nel riquadro <code>(x, y, w, h)</code><ul>
<li><code>r = h / 2, xc = x + w / 2, yc = y + h / 2</code></li>
</ul>
</li>
<li>Dividere il riquadro in due metà</li>
<li>Applicare a ciascuno dei due riquadri il processo, ricorsivamente</li>
<li>Ad ogni livello, invertire il colore del cerchio disegnato</li>
</ul>
<blockquote></blockquote>
<p>Saranno accettate esclusivamente le soluzioni ricorsive</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.7 Tris</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/tic-tac-toe.svg">
        
      </figure><ul>
<li>Classe che modella una partita a <em>tris</em> (<em>Tic Tac Toe</em>)</li>
<li>Campi privati<ul>
<li>Matrice di gioco</li>
<li>Giocatore di turno: <code>O</code> oppure <code>X</code></li>
</ul>
</li>
<li>Metodi pubblici<ul>
<li>Mossa in una certa posizione <code>x, y</code> (simbolo scelto automaticamente nel metodo)</li>
<li>Rappresentazione stato: <code>__str__(self)</code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>Visualizzare lo stato risultante</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.8 Conclusione partita</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere metodi alla classe del <em>tris</em><ul>
<li>Controllo di conclusione: <code>bool</code></li>
<li>Eventuale vincitore: <code>O</code>, <code>X</code>, <code>None</code></li>
</ul>
</li>
<li>Nel <code>main</code>, in un ciclo<ul>
<li>Chiedere all'utente le coordinate per la prossima mossa</li>
<li>Visualizzare lo stato risultante</li>
<li>Comunicare l'eventuale conclusione della partita ed il vincitore</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>4.9 Valori in file CSV</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Leggere una matrice di interi da un file testuale CSV<ul>
<li><em>Comma Separated Values</em>: valori riportati riga per riga e separati da una virgola</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="File"><code>5,7,2,11
1,3,12,9
4,6,10,8
</code></pre>
<ul>
<li>Memorizzare i dati in una lista semplice (pseudo-matrice)<ul>
<li>Inferire dimensioni della matrice (<code>rows×cols</code>) in base a:</li>
<li>Num. righe del file; num. valori nella prima riga</li>
</ul>
</li>
<li>Riscrivere in un altro file tutti i valori della matrice<ul>
<li>Raddoppiare però i valori sulla diagonale che parte dall'angolo in basso a destra (<code>cols - x == rows - y</code>)</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Nell'esempio, i valori da raddoppiare in scrittura sono i seguenti: <code>8, 12, 7</code></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 5</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>5.1 Tartaruga saltellante</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/jumper.png">
        
      </figure><ul>
<li>Modificare <code>Turtle</code> nel modulo <code>bounce</code></li>
<li>L'utente non controlla <code>dy</code>, ma solo <code>dx</code><ul>
<li>Eliminare metodi <code>go_up</code> e <code>go_down</code></li>
</ul>
</li>
<li><code>Turtle</code> subisce gravità<ul>
<li>Ma si ferma sul fondo dell'arena</li>
</ul>
</li>
<li>Tasto <code>Space</code>: la tartaruga salta<ul>
<li><em>Ma solo se si trova già sul fondo dell'arena</em></li>
<li>Parte con un valore prefissato di <code>dy</code> (negativo), poi subisce la gravità</li>
<li>Per saltare, aggiungere un metodo <code>jump</code></li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>from actor import Actor, Arena
class Turtle(Actor):
    # ...
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.2 Muri impenetrabili</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/oop/wall.png">
        
      </figure><ul>
<li>Creare classe <code>Wall</code>, sottoclasse di <code>Actor</code><ul>
<li>Rettangolo immobile ed impenetrabile</li>
<li>Campi: <code>x</code>, <code>y</code>, <code>w</code>, <code>h</code></li>
</ul>
</li>
<li>Modificare <code>Ball</code> del modulo <code>bounce</code><ul>
<li>Scivola sul muro, senza rimbalzare</li>
<li>In caso di collisione pallina / muro...</li>
<li>Resta appena fuori da muro (bordo più vicino)</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="python"><code>class Ball(Actor):  # ...
    def collide(self, other):
        if isinstance(other, Wall):
            x, y, w, h = other.rect()
            border_left, border_right = x - self.W, x + w
            border_top, border_bottom = y - self.H, y + h
            # now set either self._x or self._y, to the nearest border
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.3 Stampa per righe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Visualizzare in forma tabellare i caratteri ASCII<ul>
<li>8 righe x 12 colonne, codici da 32 a 126</li>
</ul>
</li>
<li>Mostrare in ordine i caratteri, riga per riga</li>
</ul>
<pre class="prettyprint" data-lang="Tabella 1"><code> !"#$%&amp;'()*+
,-./01234567
89:;&lt;=&gt;?@ABC
DEFGHIJKLMNO
PQRSTUVWXYZ[
\]^_`abcdefg
hijklmnopqrs
tuvwxyz{|}~
</code></pre>
<p>Usare solo due cicli <code>for</code> annidati: esterno su <code>y</code>, interno su <code>x</code> <br>
In ogni posizione, calcolare il codice da visualizzare: <code>y * COLS + x + ...</code></p>
<p>Solo stampa caratteri: non servono liste, nè matrici</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.4 Stampa per colonne</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Visualizzare in forma tabellare i caratteri ASCII<ul>
<li>8 righe x 12 colonne, codici da 32 a 126</li>
</ul>
</li>
<li>Mostrare in ordine i caratteri, colonna per colonna</li>
</ul>
<pre class="prettyprint" data-lang="Tabella 2"><code> (08@HPX`hpx
!)19AIQYaiqy
"*2:BJRZbjrz
#+3;CKS[cks{
$,4&lt;DLT\dlt|
%-5=EMU]emu}
&amp;.6&gt;FNV^fnv~
'/7?GOW_gow
</code></pre>
<p>Usare solo due cicli <code>for</code> annidati: esterno su <code>y</code>, interno su <code>x</code> <br>
In ogni posizione, calcolare il codice da visualizzare: <code>x * ROWS + y + ...</code></p>
<p>Solo stampa caratteri: non servono liste, nè matrici</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.5 Spirale</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/spiral.png">
        
      </figure><ul>
<li>Scrivere una funzione per riempire di numeri crescenti una matrice quadrata (o rettangolare)</li>
<li>Seguire il percorso a spirale suggerito nella figura a fianco</li>
<li>Dimensioni della matrice indicate dall'utente a runtime</li>
</ul>
<blockquote></blockquote>
<p>Tenere traccia della direzione attuale (<em>∆y</em>, <em>∆x</em>) <br>
Avanzare fino al bordo o ad una cella già visitata, <br>
poi cambiare la direzione in senso orario</p>
<p>Rotazione oraria 90° (coord. raster): <code>(∆x', ∆y') = (-∆y, ∆x)</code> <br>
Rotazione antior. 90° (coord. raster): <code>(∆x', ∆y') = (∆y, -∆x)</code> <br><br>
In generale (coord. cartesiane): <code>(x', y') = (x⋅cos(θ) - y⋅sin(θ), x⋅sin(θ) + y⋅cos(θ))</code> <br>
(Bisogna cambiare il segno di θ)</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.6 Fusione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/merge-sign.png">
        
      </figure><ul>
<li>Due file di testo contengono sequenze di numeri<ul>
<li>Un valore per ogni riga</li>
<li>Entrambi i file sono già ordinati, dal valore più piccolo a quello più grande</li>
</ul>
</li>
<li>Scrivere in un terzo file i valori di entrambi i file, <em>senza usare nessuna lista</em><ul>
<li>Anche il terzo deve contenere i valori in ordine, dal più piccolo al più grande</li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p>Ciclicamente, confrontare la coppia dei primi valori (ciascuno proveniente da uno dei due stream) <br>
Scrivere il minore dei due sul file di uscita <br>
Non estrarre un nuovo valore da uno stream, se quello precedente non è ancora stato scritto in output </p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.7 Espressioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Definire una gerarchia di classi per rappresentare espressioni matematiche</li>
<li>La <em>classe base</em> <strong><code>Expression</code></strong> ha un metodo astratto <code>eval</code><ul>
<li>Senza parametri, restituisce il valore <code>float</code> dell'espressione</li>
</ul>
</li>
<li>Le <em>sottoclassi</em> concrete di una espressione sono:<ul>
<li><strong><code>Literal</code></strong>, contenente un valore costante <code>float</code></li>
<li><strong><code>Sum</code></strong>, contenente due operandi, entrambi espressioni</li>
<li><strong><code>Product</code></strong>, contenente due operandi, entrambi espr.</li>
</ul>
</li>
<li>Istanziare (senza fare <em>parsing</em>!) oggetti per rappresentare questa espressione:<ul>
<li><code>5 * (4 + 3 * 2)</code></li>
</ul>
</li>
<li>Calcolare il valore finale, chiamando <code>eval</code> sul nodo radice</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.8 Espressioni prefisse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Aggiungere un  metodo <code>prefix</code> a <code>Expression</code> (es. 5.7)<ul>
<li>Genera una stringa in notazione prefissa (operatore seguito da operandi)</li>
</ul>
</li>
<li>Risultato da espressione es. 5.7: <code>"* 5 + 4 * 3 2"</code></li>
</ul>
<pre class="prettyprint" data-lang="python"><code>                                          #   *  (prod2)
prod1 = Product(Literal(3), Literal(2))   #  / \
sum1 = Sum(Literal(4), prod1)             # 5   +  (sum1)
prod2 = Product(Literal(5), sum1)         #    / \
print(prod2.eval())                       #   4   *  (prod1)
print(prod2.prefix())                     #      / \
                                          #     3   2
</code></pre>
<blockquote></blockquote>
<p><a href="https://it.wikipedia.org/wiki/Notazione_polacca">https://it.wikipedia.org/wiki/Notazione_polacca</a></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>5.9 Dominating knights (++)</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/dom-knights.png">
        
      </figure><ul>
<li>Problemi di dominio (o copertura)<ul>
<li>Trovare la posizione di un certo numero di pezzi</li>
<li>Tutti dello stesso tipo... ⇒</li>
<li>Tutte le celle sono occupate o sotto attacco</li>
</ul>
</li>
<li>In particolare, il programma deve posizionare automaticamente <code>K</code> cavalli su una scacchiera <code>NxN</code><ul>
<li>L'utente sceglie <code>K</code> ed <code>N</code></li>
<li>Ogni cella deve essere occupata, oppure sotto attacco</li>
<li>Usare il <em>backtracking</em></li>
</ul>
</li>
</ul>
<blockquote></blockquote>
<p><a href="https://en.wikipedia.org/wiki/Mathematical_chess_problem">https://en.wikipedia.org/wiki/Mathematical_chess_problem</a></p></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 6</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Progetto 1</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Gioco con diversi personaggi<ul>
<li>Fornita classe <code>Arena</code> per campo di gioco</li>
<li>Fornita classe base astratta <code>Actor</code> per personaggi</li>
</ul>
</li>
<li>Creare sottoclassi di <code>Actor</code> per personaggi specifici<ul>
<li><em>Polimorfismo</em> per movimento</li>
<li><em>Polimorfismo</em> per interazione reciproca</li>
</ul>
</li>
<li>Ma ciclo principale, interazione con l'utente e grafica <em>fuori da queste classi</em><ul>
<li>Funzionamento con grafica oppure con console testuale</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Super Mario - Personaggi</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/super-mario.jpg">
        
      </figure><ul>
<li><em>Mario</em>: guidato dal giocatore<ul>
<li>Si muove e salta sulle piattaforme</li>
<li>Cade secondo gravità, fuori dalle piattaforme</li>
<li>Ma non accelera oltre una velocità limite</li>
<li>Muore se cade in fondo allo schermo</li>
</ul>
</li>
<li><em>Muri e piattaforme</em><ul>
<li>Mario ci atterra dall'alto</li>
<li>Non si possono attraversare in nessuna direzione</li>
</ul>
</li>
<li><em>Avversari</em><ul>
<li>Si muovono sulle piattaforme come Mario, ma scelgono casualmente la direzione</li>
<li>Uccidono Mario se lo urtano, ma muoiono se Mario ci salta sopra</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Super Mario - Implementazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se un personaggio collide con un <em>muro</em><ul>
<li>Deve indietreggiare di pochi pixel</li>
<li>In modo da rimanere appena all'esterno del muro</li>
</ul>
</li>
<li>Implementazione degli <em>avversari</em><ul>
<li>Il comportamento di base è comune tra Mario e le altre “creature”</li>
<li>Si può creare una classe base comune per gestire cadute e atterraggi sulle piattaforme</li>
<li>Mario prende i comandi dall'utente, tramite tastiera</li>
<li>Le creature possono scegliere casualmente (ogni tanto) di cambiare direzione</li>
</ul>
</li>
<li>Nella prima versione, si può mantenere fissa la vista del gioco</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 7</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizi C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/cpp-logo.jpg">
        
      </figure><ul>
<li>1.1 Hello, user!</li>
<li>1.7 Massimo e minimo</li>
<li>2.1 Percentuale di maiuscole</li>
<li>2.2 Valori sopra e sotto la media</li>
<li>2.3 Funzione, Erone</li>
<li>3.7 Scrittura di risultati casuali</li>
<li>3.8 Analisi di risultati casuali</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Super Mario - Scroll</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/super-mario.jpg">
        
      </figure><ul>
<li>Aggiungere <em>scrolling</em> automatico<ul>
<li>La mappa di un livello è più ampia di una sola schermata</li>
<li>La vista del gioco si sposta lateralmente con Mario, quando si avvicina a bordo schermo</li>
<li>Lavorare sulla visualizzazione, senza modificare i personaggi</li>
</ul>
</li>
<li>Alcune piattaforme, se colpite dal basso, possono attivare dei bonus</li>
<li>Aggiungere bandiera o altro controllo per fine gioco (un solo livello)</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Super Mario - Arena</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/super-mario.jpg">
        
      </figure><ul>
<li>Definire una sottoclasse di <code>Arena</code><ul>
<li>Nel metodo di inizializzazione, genera e posiziona i personaggi del gioco</li>
<li>Fornisce i seguenti due metodi booleani, per controllare l'eventuale termine della partita:</li>
<li><code>lost</code> per la sconfitta (Mario non è più tra i personaggi dell'arena)</li>
<li><code>won</code> per la vittoria (Mario ha raggiunto l'uscita)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Esercitazione 8</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Esercizi C++</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/cpp-logo.jpg">
        
      </figure><ul>
<li>3.2 Pianeta in rivoluzione</li>
<li>3.5 Lista di pianeti<ul>
<li><a href="https://github.com/tomamic/fondinfo/tree/master/cpp/p5_4_anim_balls">https://github.com/tomamic/fondinfo/tree/master/cpp/p5_4_anim_balls</a></li>
<li>Campo: <code>vector&lt;Planet*&gt; planets</code></li>
</ul>
</li>
<li>4.3 Attori astratti</li>
<li>5.5 Spirale</li>
<li>5.1 Memory, 2011 (a console)<ul>
<li><a href="https://github.com/tomamic/fondinfo/blob/master/exercises/e5_2011_1_memory.py">https://github.com/tomamic/fondinfo/blob/master/exercises/e5_2011_1_memory.py</a></li>
</ul>
</li>
<li>5.1 Memory, 2011 (con GUI)<ul>
<li>Creare una sottoclasse di <code>Game</code></li>
</ul>
</li>
<li>4.7 Espressioni</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Super Mario</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/super-mario.jpg">
        
      </figure><ul>
<li>Aggiungere secondo giocatore, <em>Luigi</em><ul>
<li>La vista del gioco si sposta assieme ai due personaggi</li>
<li>Mario e Luigi non possono allontanarsi troppo tra loro</li>
</ul>
</li>
<li><em>Opzionalmente...</em><ul>
<li>Aggiungere bonus, piante, vite, punteggio, tempo, livelli ed estensioni a <em>fantasia</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>“Bella copia”</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/misc/fair-copy.png">
        
      </figure><ul>
<li><strong>Codice leggibile</strong><ul>
<li><em>Costanti</em>, anzichè numeri “<em>magici</em>” sparsi nel codice</li>
<li><em>Nomi esplicativi</em> e semplici</li>
<li><em>Regole di stile</em>: <code>variable_name</code>, <code>function_name</code>, <code>ClassName</code>, <code>CONSTANT_NAME</code></li>
<li><em>Commenti</em>, quando utili: <em>function annotation</em>, <em>docstring</em></li>
</ul>
</li>
<li><strong>Codice ben organizzato</strong><ul>
<li><em>No copia&amp;incolla</em> del codice: funzioni parametrizzate e/o cicli</li>
<li><em>Programmazione strutturata</em>: preferibilmente <code>return</code> a fine funzione, cicli senza <code>break</code></li>
<li><em>OOP</em>: <em>incapsulamento</em>, <em>ereditarietà</em>, <em>polimorfismo</em></li>
</ul>
</li>
</ul></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>