<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Haskell</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/tomamic.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/fun/function.png"></figure>
  <hgroup>
    <h2>Functional programming</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide  >
  
    <hgroup>
      <h2>Recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <blockquote>
<p>If you still don't know what recursion is, read this sentence</p>
</blockquote>
<ul>
<li>Recursion is actually a way of defining functions in which the function is applied inside its own definition</li>
<li>Definitions in mathematics are often given recursively. Ex.: Fibonacci sequence<ul>
<li><code>F(0) = 0 and F(1) = 1</code>  (<em>edge condition</em>)</li>
<li><code>F(n) = F(n-1) + F(n-2)</code></li>
<li>=&gt; <code>F(3) = F(2) + F(1) = (F(1) + F(0)) + F(1) = 2</code></li>
</ul>
</li>
<li>Having at least an element defined non-recursively is important for termination</li>
<li>There are no loops in Haskell, we use recursion to <em>declare</em> what something is</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Maximum function</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>The maximum function takes a list of things that can be ordered (e.g. instances of the Ord typeclass) and returns the biggest of them</li>
<li>Imperative paradigm<ul>
<li>A variable to hold the maximum value so far</li>
<li>Loop through the elements</li>
</ul>
</li>
<li>Recursive definition<ul>
<li>Edge condition, for a singleton list: the maximum is the only element in it</li>
<li>Longer list: the maximum is the head, if it is bigger than the maximum of the tail; else, the maximum of the tail</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Maximum with recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="haskell"><code>maximum' :: (Ord a) =&gt; [a] -&gt; a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs)   
    | x &gt; maxTail = x  
    | otherwise = maxTail  
    where maxTail = maximum' xs
</code></pre>
<ul>
<li>Pattern matching goes great with recursion</li>
<li>Otherwise, a lot of <code>if else</code> statements to test for edge conditions</li>
<li>Common idiom when doing recursion with lists: pattern to split a list into a head and a tail</li>
</ul>
<blockquote></blockquote>
<p>Example list of numbers, check out how this would work on them: [2,5,1]</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Maximum with max</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>max</code> is a function that takes two numbers and returns the bigger of them</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>maximum' :: (Ord a) =&gt; [a] -&gt; a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs) = max x (maximum' xs)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Replicate with recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>replicate</code> takes an <code>Int</code> and some element and returns a list that has several repetitions of the same element</li>
<li>For instance, replicate 3 5 returns [5,5,5]</li>
<li>Edge condition: if we try to replicate something zero times (or less) it should return an empty list</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>replicate' :: (Num i, Ord i) =&gt; i -&gt; a -&gt; [a]  
replicate' n x  
    | n &lt;= 0    = []  
    | otherwise = x:replicate' (n-1) x
</code></pre>
<ul>
<li>Guards instead of patterns: testing for a boolean condition</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Take with recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>take</code> takes a certain number of elements from a list</li>
<li>For instance, <code>take 3 [5,4,3,2,1]</code> returns <code>[5,4,3]</code></li>
<li>Edge conditions<ul>
<li>Take 0 or less elements from a list =&gt; empty list</li>
<li>Take anything from an empty list =&gt; empty list</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>take' :: (Num i, Ord i) =&gt; i -&gt; [a] -&gt; [a]  
take' n _  
    | n &lt;= 0   = []  
take' _ []     = []  
take' n (x:xs) = x : take' (n-1) xs
</code></pre>
<blockquote></blockquote>
<p>Guard, without an otherwise part: if <code>n</code> turns out to be more than 0, the matching will fall through to the next pattern</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Reverse with recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Edge condition: the empty list!</li>
<li>Split a list to a head and a tail, the result is the reversed tail and then the head at the end</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>reverse' :: [a] -&gt; [a]  
reverse' [] = []  
reverse' (x:xs) = reverse' xs ++ [x]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Infinite recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Haskell is <em>lazy</em> and supports infinite lists: recursion doesn't really have to have an edge condition</li>
<li><code>repeat</code> takes an element and returns an infinite list...</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>repeat' :: a -&gt; [a]  
repeat' x = x:repeat' x
</code></pre>
<ul>
<li><code>repeat 3</code> evaluates like <code>3:repeat 3</code>, which is <code>3:(3:repeat 3)</code>...</li>
<li><code>repeat 3</code> gives us a list that starts with 3, and then has an infinite amount of 3's as a tail</li>
<li><code>take 5 (repeat 3)</code> will give us a list of five 3's</li>
<li>Essentially it's like doing replicate 5 3.</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Zip with recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>zip [1,2,3] [2,3]</code> returns <code>[(1,2),(2,3)]</code></li>
<li>It truncates the longer list to match the length of the shorter one</li>
<li>zip something with an empty list =&gt; empty list (<em>edge conditions</em>)</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>zip' :: [a] -&gt; [b] -&gt; [(a,b)]  
zip' _ [] = []  
zip' [] _ = []  
zip' (x:xs) (y:ys) = (x,y):zip' xs ys
</code></pre>
<blockquote></blockquote>
<p>Ex.: <code>zip [1,2,3] ['a','b']</code></p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Elem with recursion</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><code>elem</code> takes an element and a list and sees if that element is in the list</li>
<li>Edge condition: empty list</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool  
elem' a [] = False  
elem' a (x:xs)  
    | a == x    = True  
    | otherwise = a `elem'` xs
</code></pre>
<blockquote></blockquote>
<p>If the head isn't the element, then we check the tail. If we reach an empty list, the result is <code>False</code>.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Quick, sort!</p>
<p>We have a list of items that can be sorted. Their type is an instance of the Ord typeclass. And now, we want to sort them! There's a very cool algoritm for sorting called quicksort. It's a very clever way of sorting items. While it takes upwards of 10 lines to implement quicksort in imperative languages, the implementation is much shorter and elegant in Haskell. Quicksort has become a sort of poster child for Haskell. Therefore, let's implement it here, even though implementing quicksort in Haskell is considered really cheesy because everyone does it to showcase how elegant Haskell is.
quickman</p>
<p>So, the type signature is going to be quicksort :: (Ord a) =&gt; [a] -&gt; [a]. No surprises there. The edge condition? Empty list, as is expected. A sorted empty list is an empty list. Now here comes the main algorithm: a sorted list is a list that has all the values smaller than (or equal to) the head of the list in front (and those values are sorted), then comes the head of the list in the middle and then come all the values that are bigger than the head (they're also sorted). Notice that we said sorted two times in this definition, so we'll probably have to make the recursive call twice! Also notice that we defined it using the verb is to define the algorithm instead of saying do this, do that, then do that .... That's the beauty of functional programming! How are we going to filter the list so that we get only the elements smaller than the head of our list and only elements that are bigger? List comprehensions.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>So, let's dive in and define this function.</p>
<pre><code>quicksort :: (Ord a) =&gt; [a] -&gt; [a]  
quicksort [] = []  
quicksort (x:xs) =   
    let smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]  
        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]  
    in  smallerSorted ++ [x] ++ biggerSorted
</code></pre>
<p>Let's give it a small test run to see if it appears to behave correctly.</p>
<pre><code>Prelude&gt; quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]  
[1,2,2,3,3,4,4,5,6,7,8,9,10]  
Prelude&gt; quicksort "the quick brown fox jumps over the lazy dog"  
"        abcdeeefghhijklmnoooopqrrsttuuvwxyz"
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>An element that is in place and won't move anymore is represented in orange. If you read them from left to right, you'll see the sorted list. Although we chose to compare all the elements to the heads, we could have used any element to compare against. In quicksort, an element that you compare against is called a pivot. They're in green here. We chose the head because it's easy to get by pattern matching. The elements that are smaller than the pivot are light green and elements larger than the pivot are dark green. The yellowish gradient thing represents an application of quicksort.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Thinking recursively</p>
<p>We did quite a bit of recursion so far and as you've probably noticed, there's a pattern here. Usually you define an edge case and then you define a function that does something between some element and the function applied to the rest. It doesn't matter if it's a list, a tree or any other data structure. A sum is the first element of a list plus the sum of the rest of the list. A product of a list is the first element of the list times the product of the rest of the list. The length of a list is one plus the length of the tail of the list. Ekcetera, ekcetera ...</p>
<p>Of course, these also have edge cases. Usually the edge case is some scenario where a recursive application doesn't make sense. When dealing with lists, the edge case is most often the empty list. If you're dealing with trees, the edge case is usually a node that doesn't have any children.</p>
<p>It's similar when you're dealing with numbers recursively. Usually it has to do with some number and the function applied to that number modified. We did the factorial function earlier and it's the product of a number and the factorial of that number minus one. Such a recursive application doesn't make sense with zero, because factorials are defined only for positive integers. Often the edge case value turns out to be an identity. The identity for multiplication is 1 because if you multiply something by 1, you get that something back. Also when doing sums of lists, we define the sum of an empty list as 0 and 0 is the identity for addition. In quicksort, the edge case is the empty list and the identity is also the empty list, because if you add an empty list to a list, you just get the original list back.</p>
<p>So when trying to think of a recursive way to solve a problem, try to think of when a recursive solution doesn't apply and see if you can use that as an edge case, think about identities and think about whether you'll break apart the parameters of the function (for instance, lists are usually broken into a head and a tail via pattern matching) and on which part you'll use the recursive call.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Higher order functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Higher order functions<ul>
<li>Haskell functions can take functions as parameters and return functions as return values</li>
<li>A function that does either of those is called a <em>higher order function</em></li>
<li>Essential feature of the language, indispensable for the functional paradigm</li>
</ul>
</li>
<li>Curried functions<ul>
<li>Every function in Haskell officially only takes one parameter (!)</li>
<li>What's the "trick" for functions that take more than one parameter?</li>
<li>All the functions that accepted several parameters so far have been <em>curried</em> functions</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Curried functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Apparently... the <code>max</code> function takes two <code>Ord</code> parameters and returns the one that's bigger</li>
<li>In reality, <code>max 4 5</code> first creates a function that takes a parameter and returns either 4 or that parameter, depending on which is bigger</li>
<li>Then, 5 is applied to that function and that function produces our desired result</li>
<li>The following two calls are equivalent:</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>Prelude&gt; max 4 5  
5  
Prelude&gt; (max 4) 5  
5
</code></pre>
<blockquote>
<p>The space is like an operator, for function application, which has the highest precedence</p>
</blockquote></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Currying and function types</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Let's examine the type of <code>max</code>:<ul>
<li><code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code></li>
<li><code>max :: (Ord a) =&gt; a -&gt; (a -&gt; a)  -- same as above</code></li>
<li>Read as: <code>max</code> takes an <code>a</code> and returns (that's the <code>-&gt;</code>) a function...</li>
<li>That takes an <code>a</code> and returns an <code>a</code></li>
</ul>
</li>
<li>Currying is the reason why the return type and the parameters of functions are all simply separated with arrows</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Partially applied functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>If we call a function with too few parameters, we get back a partially applied function</li>
<li>The returned function takes as many parameters as we left out</li>
<li>Using partial application is a neat way to create functions on the fly</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>multThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a  
multThree x y z = x * y * z
</code></pre>
<ul>
<li><code>multThree 3 5 9</code> or <code>((multThree 3) 5) 9</code><ul>
<li>First, 3 is applied to multThree; that creates a function that takes one parameter and returns a function</li>
<li>So then 5 is applied to that, which creates a function that takes ome parameter and multiply it by 15</li>
<li>9 is applied to that function, so the result is 135</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Function types</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="haskell"><code>multThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a
</code></pre>
<ul>
<li>The thing before the <code>-&gt;</code> is the parameter that a function takes</li>
<li>The thing after it is what it returns</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>multThree :: (Num a) =&gt; a -&gt; (a -&gt; (a -&gt; a))  -- same as above
</code></pre>
<ul>
<li>Our function takes an <code>a</code> and returns <code>a</code> function of type <code>(Num a) =&gt; a -&gt; (a -&gt; a)</code></li>
<li>Similarly, this function takes an <code>a</code> and returns a function of type <code>(Num a) =&gt; a -&gt; a</code></li>
<li>And this function, finally, just takes an <code>a</code> and returns an <code>a</code> </li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Partial application</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="haskell"><code>Prelude&gt; let multTwoWithNine = multThree 9  
Prelude&gt; multTwoWithNine 2 3  
54  
Prelude&gt; let multWithEighteen = multTwoWithNine 2  
Prelude&gt; multWithEighteen 10  
180
</code></pre>
<ul>
<li>By calling functions with too few parameters, we're creating new functions on the fly</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Currying for creating functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="haskell"><code>compareWithHundred :: (Num a, Ord a) =&gt; a -&gt; Ordering  
compareWithHundred x = compare 100 x
</code></pre>
<ul>
<li>Function that takes a number and compares it to 100</li>
<li>Notice that the <code>x</code> is on the right hand side on both sides of the equation</li>
<li>However, <code>compare 100</code> returns a function, that takes a number and compares it with 100</li>
<li>The type declaration stays the same</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>compareWithHundred :: (Num a, Ord a) =&gt; a -&gt; Ordering  
compareWithHundred = compare 100
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Infix partial application</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Infix functions can also be partially applied, by using <em>sections</em></li>
<li>To section an infix function, simply surround it with parentheses and only supply a parameter on one side</li>
<li>That creates a function that takes one parameter and then applies it to the side that's missing an operand</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>divideByTen :: (Floating a) =&gt; a -&gt; a  
divideByTen = (/10)
</code></pre>
<ul>
<li><code>divideByTen 200</code> is equivalent to <code>200 / 10</code>, as is <code>(/10) 200</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sectioning functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>
<p>A function that checks if a character supplied to it is an uppercase letter</p>
<p>isUpperAlphanum :: Char -&gt; Bool<br />
isUpperAlphanum = (<code>elem</code> ['A'..'Z'])  </p>
</li>
<li>
<p>Exception: for convenience, <code>(-4)</code> means minus four</p>
</li>
<li>Partially apply the <code>subtract</code> function: <code>(subtract 4)</code></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Defining higher-order functions</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Functions can take functions as parameters and also return functions</li>
<li>Ex.: a function that takes a function, and then applies it twice to something</li>
</ul>
<pre class="prettyprint" data-lang="haskell"><code>applyTwice :: (a -&gt; a) -&gt; a -&gt; a  
applyTwice f x = f (f x)
</code></pre>
<ul>
<li>Type declaration: parentheses because <code>-&gt;</code> is naturally right-associative<ul>
<li>The first parameter is a function that takes something and returns that same thing</li>
<li>The second parameter is something of that type also</li>
<li>The return value is also of the same type</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Example of high-order function</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="haskell"><code>Prelude&gt; applyTwice (+3) 10  
16  
Prelude&gt; applyTwice (++ " HAHA") "HEY"  
"HEY HAHA HAHA"  
Prelude&gt; applyTwice ("HAHA " ++) "HEY"  
"HAHA HAHA HEY"  
Prelude&gt; applyTwice (multThree 2 2) 9  
144  
Prelude&gt; applyTwice (3:) [1]  
[3,3,1]
</code></pre>
<ul>
<li>The awesomeness and usefulness of partial application is evident<ul>
<li>Our function requires us to pass it a function that takes only one parameter</li>
<li>We can just partially apply a function to the point where it takes only one parameter and then pass it</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]  
zipWith' _ [] _ = []  
zipWith' _ _ [] = []  
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
</code></pre>
<p>Look at the type declaration. The first parameter is a function that takes two things and produces a third thing. They don't have to be of the same type, but they can. The second and third parameter are lists. The result is also a list. The first has to be a list of a's, because the joining function takes a's as its first argument. The second has to be a list of b's, because the second parameter of the joining function is of type b. The result is a list of c's. If the type declaration of a function says it accepts an a -&gt; b -&gt; c function as a parameter, it will also accept an a -&gt; a -&gt; a function, but not the other way around! Remember that when you're making functions, especially higher order ones, and you're unsure of the type, you can just try omitting the type declaration and then checking what Haskell infers it to be by using :t.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>Prelude&gt; zipWith' (+) [4,2,5,6] [2,6,2,3]  
[6,8,7,9]  
Prelude&gt; zipWith' max [6,3,2,1] [7,3,1,5]  
[7,3,2,5]  
Prelude&gt; zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]  
["foo fighters","bar hoppers","baz aldrin"]  
Prelude&gt; zipWith' (*) (replicate 5 2) [1..]  
[2,4,6,8,10]  
Prelude&gt; zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
[[3,4,6],[9,20,30],[10,12,12]]
</code></pre>
<p>As you can see, a single higher order function can be used in very versatile ways. Imperative programming usually uses stuff like for loops, while loops, setting something to a variable, checking its state, etc. to achieve some behavior and then wrap it around an interface, like a function. Functional programming uses higher order functions to abstract away common patterns, like examining two lists in pairs and doing something with those pairs or getting a set of solutions and eliminating the ones you don't need.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>flip' :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)  
flip' f = g  
    where g x y = f y x
</code></pre>
<p>Reading the type declaration, we say that it takes a function that takes an a and a b and returns a function that takes a b and an a. But because functions are curried by default, the second pair of parentheses is really unnecessary, because -&gt; is right associative by default. (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c) is the same as (a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c)), which is the same as (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c. We wrote that g x y = f y x. If that's true, then f y x = g x y must also hold, right? Keeping that in mind, we can define this function in an even simpler manner.</p>
<pre><code>flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  
flip' f y x = f x y
</code></pre>
<p>Here, we take advantage of the fact that functions are curried. When we call flip' f without the parameters y and x, it will return an f that takes those two parameters but calls them flipped. Even though flipped functions are usually passed to other functions, we can take advantage of currying when making higher-order functions by thinking ahead and writing what their end result would be if they were called fully applied.</p>
<pre><code>Prelude&gt; flip' zip [1,2,3,4,5] "hello"  
[('h',1),('e',2),('l',3),('l',4),('o',5)]  
Prelude&gt; zipWith (flip' div) [2,2..] [10,8,6,4,2]  
[5,4,3,2,1]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Maps and filters</p>
<p>map takes a function and a list and applies that function to every element in the list, producing a new list. Let's see what its type signature is and how it's defined.</p>
<pre><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]  
map _ [] = []  
map f (x:xs) = f x : map f xs
</code></pre>
<p>The type signature says that it takes a function that takes an a and returns a b, a list of a's and returns a list of b's. It's interesting that just by looking at a function's type signature, you can sometimes tell what it does. map is one of those really versatile higher-order functions that can be used in millions of different ways.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>Prelude&gt; map (+3) [1,5,3,1,6]  
[4,8,6,4,9]  
Prelude&gt; map (++ "!") ["BIFF", "BANG", "POW"]  
["BIFF!","BANG!","POW!"]  
Prelude&gt; map (replicate 3) [3..6]  
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  
Prelude&gt; map (map (^2)) [[1,2],[3,4,5,6],[7,8]]  
[[1,4],[9,16,25,36],[49,64]]  
Prelude&gt; map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[1,3,6,2,2]
</code></pre>
<p>You've probably noticed that each of these could be achieved with a list comprehension. map (+3) [1,5,3,1,6] is the same as writing [x+3 | x &lt;- [1,5,3,1,6]]. However, using map is much more readable for cases where you only apply some function to the elements of a list, especially once you're dealing with maps of maps and then the whole thing with a lot of brackets can get a bit messy.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]  
filter _ [] = []  
filter p (x:xs)   
    | p x       = x : filter p xs  
    | otherwise = filter p xs
</code></pre>
<p>Pretty simple stuff. If p x evaluates to True, the element gets included in the new list. If it doesn't, it stays out. Some usage examples:</p>
<pre><code>Prelude&gt; filter (&gt;3) [1,5,3,2,1,6,4,3,2,1]  
[5,6,4]  
Prelude&gt; filter (==3) [1,2,3,4,5]  
[3]  
Prelude&gt; filter even [1..10]  
[2,4,6,8,10]  
Prelude&gt; let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]  
[[1,2,3],[3,4,5],[2,2]]  
Prelude&gt; filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"  
"uagameasadifeent"  
Prelude&gt; filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"  
"GAYBALLS"
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>All of this could also be achived with list comprehensions by the use of predicates. There's no set rule for when to use map and filter versus using list comprehension, you just have to decide what's more readable depending on the code and the context. The filter equivalent of applying several predicates in a list comprehension is either filtering something several times or joining the predicates with the logical &amp;&amp; function.</p>
<p>Remember our quicksort function from the previous chapter? We used list comprehensions to filter out the list elements that are smaller than (or equal to) and larger than the pivot. We can achieve the same functionality in a more readable way by using filter:</p>
<pre><code>quicksort :: (Ord a) =&gt; [a] -&gt; [a]    
quicksort [] = []    
quicksort (x:xs) =     
    let smallerSorted = quicksort (filter (&lt;=x) xs)  
        biggerSorted = quicksort (filter (&gt;x) xs)   
    in  smallerSorted ++ [x] ++ biggerSorted
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>map</p>
<p>Mapping and filtering is the bread and butter of every functional programmer's toolbox. Uh. It doesn't matter if you do it with the map and filter functions or list comprehensions. Recall how we solved the problem of finding right triangles with a certain circumference. With imperative programming, we would have solved it by nesting three loops and then testing if the current combination satisfies a right triangle and if it has the right perimeter. If that's the case, we would have printed it out to the screen or something. In functional programming, that pattern is achieved with mapping and filtering. You make a function that takes a value and produces some result. We map that function over a list of values and then we filter the resulting list out for the results that satisfy our search. Thanks to Haskell's laziness, even if you map something over a list several times and filter it several times, it will only pass over the list once.</p>
<p>Let's find the largest number under 100,000 that's divisible by 3829. To do that, we'll just filter a set of possibilities in which we know the solution lies.</p>
<pre><code>largestDivisible :: (Integral a) =&gt; a  
largestDivisible = head (filter p [100000,99999..])  
    where p x = x `mod` 3829 == 0
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>We first make a list of all numbers lower than 100,000, descending. Then we filter it by our predicate and because the numbers are sorted in a descending manner, the largest number that satisfies our predicate is the first element of the filtered list. We didn't even need to use a finite list for our starting set. That's laziness in action again. Because we only end up using the head of the filtered list, it doesn't matter if the filtered list is finite or infinite. The evaluation stops when the first adequate solution is found.</p>
<p>Next up, we're going to find the sum of all odd squares that are smaller than 10,000. But first, because we'll be using it in our solution, we're going to introduce the takeWhile function. It takes a predicate and a list and then goes from the beginning of the list and returns its elements while the predicate holds true. Once an element is found for which the predicate doesn't hold, it stops. If we wanted to get the first word of the string "elephants know how to party", we could do takeWhile (/=' ') "elephants know how to party" and it would return "elephants". Okay. The sum of all odd squares that are smaller than 10,000. First, we'll begin by mapping the (^2) function to the infinite list [1..]. Then we filter them so we only get the odd ones. And then, we'll take elements from that list while they are smaller than 10,000. Finally, we'll get the sum of that list. We don't even have to define a function for that, we can do it in one line in GHCI:</p>
<pre><code>Prelude&gt; sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))  
166650
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>Prelude&gt; sum (takeWhile (&lt;10000) [n^2 | n &lt;- [1..], odd (n^2)])  
166650
</code></pre>
<p>It's a matter of taste as to which one you find prettier. Again, Haskell's property of laziness is what makes this possible. We can map over and filter an infinite list, because it won't actually map and filter it right away, it'll delay those actions. Only when we force Haskell to show us the sum does the sum function say to the takeWhile that it needs those numbers. takeWhile forces the filtering and mapping to occur, but only until a number greater than or equal to 10,000 is encountered.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Now what we want to know is this: for all starting numbers between 1 and 100, how many chains have a length greater than 15? First off, we'll write a function that produces a chain:</p>
<pre><code>chain :: (Integral a) =&gt; a -&gt; [a]  
chain 1 = [1]  
chain n  
    | even n =  n:chain (n `div` 2)  
    | odd n  =  n:chain (n*3 + 1)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Because the chains end at 1, that's the edge case. This is a pretty standard recursive function.</p>
<pre><code>Prelude&gt; chain 10  
[10,5,16,8,4,2,1]  
Prelude&gt; chain 1  
[1]  
Prelude&gt; chain 30  
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
</code></pre>
<p>Yay! It seems to be working correctly. And now, the function that tells us the answer to our question:</p>
<pre><code>numLongChains :: Int  
numLongChains = length (filter isLong (map chain [1..100]))  
    where isLong xs = length xs &gt; 15
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Using map, we can also do stuff like map (<em>) [0..], if not for any other reason than to illustrate how currying works and how (partially applied) functions are real values that you can pass around to other functions or put into lists (you just can't turn them to strings). So far, we've only mapped functions that take one parameter over lists, like map (</em>2) [0..] to get a list of type (Num a) =&gt; [a], but we can also do map (<em>) [0..] without a problem. What happens here is that the number in the list is applied to the function </em>, which has a type of (Num a) =&gt; a -&gt; a -&gt; a. Applying only one parameter to a function that takes two parameters returns a function that takes one parameter. If we map * over the list [0..], we get back a list of functions that only take one parameter, so (Num a) =&gt; [a -&gt; a]. map (<em>) [0..] produces a list like the one we'd get by writing [(0</em>),(1<em>),(2</em>),(3<em>),(4</em>),(5*)...</p>
<pre><code>Prelude&gt; let listOfFuns = map (*) [0..]  
Prelude&gt; (listOfFuns !! 4) 5  
20
</code></pre>
<p>Getting the element with the index 4 from our list returns a function that's equivalent to (4<em>). And then, we just apply 5 to that function. So that's like writing (4</em>) 5 or just 4 * 5.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Lambdas</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Lambdas are basically anonymous functions that are used because we need some functions only once. Normally, we make a lambda with the sole purpose of passing it to a higher-order function. To make a lambda, we write a \ (because it kind of looks like the greek letter lambda if you squint hard enough) and then we write the parameters, separated by spaces. After that comes a -&gt; and then the function body. We usually surround them by parentheses, because otherwise they extend all the way to the right.</p>
<p>If you look about 5 inches up, you'll see that we used a where binding in our numLongChains function to make the isLong function for the sole purpose of passing it to filter. Well, instead of doing that, we can use a lambda:</p>
<pre><code>numLongChains :: Int  
numLongChains = length (filter (\xs -&gt; length xs &gt; 15) (map chain [1..100]))
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Lambdas are expressions, that's why we can just pass them like that. The expression (\xs -&gt; length xs &gt; 15) returns a function that tells us whether the length of the list passed to it is greater than 15.
lamb</p>
<p>People who are not well acquainted with how currying and partial application works often use lambdas where they don't need to. For instance, the expressions map (+3) [1,6,3,2] and map (\x -&gt; x + 3) [1,6,3,2] are equivalent since both (+3) and (\x -&gt; x + 3) are functions that take a number and add 3 to it. Needless to say, making a lambda in this case is stupid since using partial application is much more readable.</p>
<p>Like normal functions, lambdas can take any number of parameters:</p>
<pre><code>Prelude&gt; zipWith (\a b -&gt; (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]  
[153.0,61.5,31.0,15.75,6.6]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>Prelude&gt; map (\(a,b) -&gt; a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[3,8,9,8,7]
</code></pre>
<p>Lambdas are normally surrounded by parentheses unless we mean for them to extend all the way to the right. Here's something interesting: due to the way functions are curried by default, these two are equivalent:</p>
<pre><code>addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a  
addThree x y z = x + y + z

addThree :: (Num a) =&gt; a -&gt; a -&gt; a -&gt; a  
addThree = \x -&gt; \y -&gt; \z -&gt; x + y + z
</code></pre>
<p>If we define a function like this, it's obvious why the type declaration is what it is. There are three -&gt;'s in both the type declaration and the equation. But of course, the first way to write functions is far more readable, the second one is pretty much a gimmick to illustrate currying.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c  
flip' f = \x y -&gt; f y x
</code></pre>
<p>Even though that's the same as writing flip' f x y = f y x, we make it obvious that this will be used for producing a new function most of the time. The most common use case with flip is calling it with just the function parameter and then passing the resulting function on to a map or a filter. So use lambdas in this way when you want to make it explicit that your function is mainly meant to be partially applied and passed on to a function as a parameter.
Only folds and horses
folded bird</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>A fold takes a binary function, a starting value (I like to call it the accumulator) and a list to fold up. The binary function itself takes two parameters. The binary function is called with the accumulator and the first (or last) element and produces a new accumulator. Then, the binary function is called again with the new accumulator and the now new first (or last) element, and so on. Once we've walked over the whole list, only the accumulator remains, which is what we've reduced the list to.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>First let's take a look at the foldl function, also called the left fold. It folds the list up from the left side. The binary function is applied between the starting value and the head of the list. That produces a new accumulator value and the binary function is called with that value and the next element, etc.</p>
<p>Let's implement sum again, only this time, we'll use a fold instead of explicit recursion.</p>
<pre><code>sum' :: (Num a) =&gt; [a] -&gt; a  
sum' xs = foldl (\acc x -&gt; acc + x) 0 xs
</code></pre>
<p>Testing, one two three:</p>
<pre><code>Prelude&gt; sum' [3,5,2,1]  
11
</code></pre>
<p>foldl</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Let's take an in-depth look into how this fold happens. \acc x -&gt; acc + x is the binary function. 0 is the starting value and xs is the list to be folded up. Now first, 0 is used as the acc parameter to the binary function and 3 is used as the x (or the current element) parameter. 0 + 3 produces a 3 and it becomes the new accumulator value, so to speak. Next up, 3 is used as the accumulator value and 5 as the current element and 8 becomes the new accumulator value. Moving forward, 8 is the accumulator value, 2 is the current element, the new accumulator value is 10. Finally, that 10 is used as the accumulator value and 1 as the current element, producing an 11. Congratulations, you've done a fold!</p>
<p>This professional diagram on the left illustrates how a fold happens, step by step (day by day!). The greenish brown number is the accumulator value. You can see how the list is sort of consumed up from the left side by the accumulator. Om nom nom nom! If we take into account that functions are curried, we can write this implementation ever more succinctly, like so:</p>
<pre><code>sum' :: (Num a) =&gt; [a] -&gt; a  
sum' = foldl (+) 0
</code></pre>
<p>The lambda function (\acc x -&gt; acc + x) is the same as (+). We can omit the xs as the parameter because calling foldl (+) 0 will return a function that takes a list. Generally, if you have a function like foo a = bar b a, you can rewrite it as foo = bar b, because of currying.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Anyhoo, let's implement another function with a left fold before moving on to right folds. I'm sure you all know that elem checks whether a value is part of a list so I won't go into that again (whoops, just did!). Let's implement it with a left fold.</p>
<pre><code>elem' :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool  
elem' y ys = foldl (\acc x -&gt; if x == y then True else acc) False ys
</code></pre>
<p>Well, well, well, what do we have here? The starting value and accumulator here is a boolean value. The type of the accumulator value and the end result is always the same when dealing with folds. Remember that if you ever don't know what to use as a starting value, it'll give you some idea. We start off with False. It makes sense to use False as a starting value. We assume it isn't there. Also, if we call a fold on an empty list, the result will just be the starting value. Then we check the current element is the element we're looking for. If it is, we set the accumulator to True. If it's not, we just leave the accumulator unchanged. If it was False before, it stays that way because this current element is not it. If it was True, we leave it at that.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>The right fold, foldr works in a similar way to the left fold, only the accumulator eats up the values from the right. Also, the left fold's binary function has the accumulator as the first parameter and the current value as the second one (so \acc x -&gt; ...), the right fold's binary function has the current value as the first parameter and the accumulator as the second one (so \x acc -&gt; ...). It kind of makes sense that the right fold has the accumulator on the right, because it folds from the right side.</p>
<p>The accumulator value (and hence, the result) of a fold can be of any type. It can be a number, a boolean or even a new list. We'll be implementing the map function with a right fold. The accumulator will be a list, we'll be accumulating the mapped list element by element. From that, it's obvious that the starting element will be an empty list.</p>
<pre><code>map' :: (a -&gt; b) -&gt; [a] -&gt; [b]  
map' f xs = foldr (\x acc -&gt; f x : acc) [] xs
</code></pre>
<p>If we're mapping (+3) to [1,2,3], we approach the list from the right side. We take the last element, which is 3 and apply the function to it, which ends up being 6. Then, we prepend it to the accumulator, which is was []. 6:[] is [6] and that's now the accumulator. We apply (+3) to 2, that's 5 and we prepend (:) it to the accumulator, so the accumulator is now [5,6]. We apply (+3) to 1 and prepend that to the accumulator and so the end value is [4,5,6].</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>If you reverse a list, you can do a right fold on it just like you would have done a left fold and vice versa. Sometimes you don't even have to do that. The sum function can be implemented pretty much the same with a left and right fold. One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end!</p>
<p>Folds can be used to implement any function where you traverse a list once, element by element, and then return something based on that. Whenever you want to traverse a list to return something, chances are you want a fold. That's why folds are, along with maps and filters, one of the most useful types of functions in functional programming.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      </article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>maximum' :: (Ord a) =&gt; [a] -&gt; a  
maximum' = foldr1 (\x acc -&gt; if x &gt; acc then x else acc)

reverse' :: [a] -&gt; [a]  
reverse' = foldl (\acc x -&gt; x : acc) []

product' :: (Num a) =&gt; [a] -&gt; a  
product' = foldr1 (*)

filter' :: (a -&gt; Bool) -&gt; [a] -&gt; [a]  
filter' p = foldr (\x acc -&gt; if p x then x : acc else acc) []

head' :: [a] -&gt; a  
head' = foldr1 (\x _ -&gt; x)

last' :: [a] -&gt; a  
last' = foldl1 (\_ x -&gt; x)
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Another way to picture right and left folds is like this: say we have a right fold and the binary function is f and the starting value is z. If we're right folding over the list [3,4,5,6], we're essentially doing this: f 3 (f 4 (f 5 (f 6 z))). f is called with the last element in the list and the accumulator, that value is given as the accumulator to the next to last value and so on. If we take f to be + and the starting accumulator value to be 0, that's 3 + (4 + (5 + (6 + 0))). Or if we write + as a prefix function, that's (+) 3 ((+) 4 ((+) 5 ((+) 6 0))). Similarly, doing a left fold over that list with g as the binary function and z as the accumulator is the equivalent of g (g (g (g z 3) 4) 5) 6. If we use flip (:) as the binary function and [] as the accumulator (so we're reversing the list), then that's the equivalent of flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6. And sure enough, if you evaluate that expression, you get [6,5,4,3].</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>scanl and scanr are like foldl and foldr, only they report all the intermediate accumulator states in the form of a list. There are also scanl1 and scanr1, which are analogous to foldl1 and foldr1.</p>
<pre><code>Prelude&gt; scanl (+) 0 [3,5,2,1]  
[0,3,8,10,11]  
Prelude&gt; scanr (+) 0 [3,5,2,1]  
[11,8,3,1,0]  
Prelude&gt; scanl1 (\acc x -&gt; if x &gt; acc then x else acc) [3,4,5,3,7,9,2,1]  
[3,4,5,5,7,9,9,9]  
Prelude&gt; scanl (flip (:)) [] [3,2,1]  
[[],[3],[2,3],[1,2,3]]
</code></pre>
<p>When using a scanl, the final result will be in the last element of the resulting list while a scanr will place the result in the head.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>sqrtSums :: Int  
sqrtSums = length (takeWhile (&lt;1000) (scanl1 (+) (map sqrt [1..]))) + 1

Prelude&gt; sqrtSums  
131  
Prelude&gt; sum (map sqrt [1..131])  
1005.0942035344083  
Prelude&gt; sum (map sqrt [1..130])  
993.6486803921487
</code></pre>
<p>We use takeWhile here instead of filter because filter doesn't work on infinite lists. Even though we know the list is ascending, filter doesn't, so we use takeWhile to cut the scanlist off at the first occurence of a sum greater than 1000.
Function application with $</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>($) :: (a -&gt; b) -&gt; a -&gt; b  
f $ x = f x
</code></pre>
<p>dollar</p>
<p>What the heck? What is this useless operator? It's just function application! Well, almost, but not quite! Whereas normal function application (putting a space between two things) has a really high precedence, the $ function has the lowest precedence. Function application with a space is left-associative (so f a b c is the same as ((f a) b) c)), function application with $ is right-associative.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>That's all very well, but how does this help us? Most of the time, it's a convenience function so that we don't have to write so many parentheses. Consider the expression sum (map sqrt [1..130]). Because $ has such a low precedence, we can rewrite that expression as sum $ map sqrt [1..130], saving ourselves precious keystrokes! When a $ is encountered, the expression on its right is applied as the parameter to the function on its left. How about sqrt 3 + 4 + 9? This adds together 9, 4 and the square root of 3. If we want get the square root of 3 + 4 + 9, we'd have to write sqrt (3 + 4 + 9) or if we use $ we can write it as sqrt $ 3 + 4 + 9 because $ has the lowest precedence of any operator. That's why you can imagine a $ being sort of the equivalent of writing an opening parentheses and then writing a closing one on the far right side of the expression.</p>
<p>How about sum (filter (&gt; 10) (map (<em>2) [2..10]))? Well, because $ is right-associative, f (g (z x)) is equal to f $ g $ z x. And so, we can rewrite sum (filter (&gt; 10) (map (</em>2) [2..10])) as sum $ filter (&gt; 10) $ map (*2) [2..10].</p>
<p>But apart from getting rid of parentheses, $ means that function application can be treated just like another function. That way, we can, for instance, map function application over a list of functions.</p>
<pre><code>Prelude&gt; map ($ 3) [(4+), (10*), (^2), sqrt]  
[7.0,30.0,9.0,1.7320508075688772]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Function composition</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>In mathematics, function composition is defined like this: (f . g)(x) = f(g(x)), meaning that composing two functions produces a new function that, when called with a parameter, say, x is the equivalent of calling g with the parameter x and then calling the f with that result.</p>
<p>In Haskell, function composition is pretty much the same thing. We do function composition with the . function, which is defined like so:</p>
<pre><code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c  
f . g = \x -&gt; f (g x)
</code></pre>
<p>notes</p>
<p>Mind the type declaration. f must take as its parameter a value that has the same type as g's return value. So the resulting function takes a parameter of the same type that g takes and returns a value of the same type that f returns. The expression negate . (* 3) returns a function that takes a number, multiplies it by 3 and then negates it.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>Prelude&gt; map (\x -&gt; negate (abs x)) [5,-3,-6,7,-3,2,-19,24]  
[-5,-3,-6,-7,-3,-2,-19,-24]
</code></pre>
<p>Notice the lambda and how it looks like the result function composition. Using function composition, we can rewrite that as:</p>
<pre><code>Prelude&gt; map (negate . abs) [5,-3,-6,7,-3,2,-19,24]  
[-5,-3,-6,-7,-3,-2,-19,-24]
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Fabulous! Function composition is right-associative, so we can compose many functions at a time. The expression f (g (z x)) is equivalent to (f . g . z) x. With that in mind, we can turn</p>
<pre><code>Prelude&gt; map (\xs -&gt; negate (sum (tail xs))) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]
</code></pre>
<p>into</p>
<pre><code>Prelude&gt; map (negate . sum . tail) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]
</code></pre>
<p>But what about functions that take several parameters? Well, if we want to use them in function composition, we usually have to partially apply them just so much that each function takes just one parameter. sum (replicate 5 (max 6.7 8.9)) can be rewritten as (sum . replicate 5 . max 6.7) 8.9 or as sum . replicate 5 . max 6.7 $ 8.9. What goes on in here is this: a function that takes what max 6.7 takes and applies replicate 5 to it is created. Then, a function that takes the result of that and does a sum of it is created. Finally, that function is called with 8.9. But normally, you just read that as: apply 8.9 to max 6.7, then apply replicate 5 to that and then apply sum to that. If you want to rewrite an expression with a lot of parentheses by using function composition, you can start by putting the last parameter of the innermost function after a $ and then just composing all the other function calls, writing them without their last parameter and putting dots between them. If you have replicate 100 (product (map (<em>3) (zipWith max [1,2,3,4,5] [4,5,6,7,8]))), you can write it as replicate 100 . product . map (</em>3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]. If the expression ends with three parentheses, chances are that if you translate it into function composition, it'll have three composition operators.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>sum' :: (Num a) =&gt; [a] -&gt; a     
sum' xs = foldl (+) 0 xs
</code></pre>
<p>The xs is exposed on both right sides. Because of currying, we can omit the xs on both sides, because calling foldl (+) 0 creates a function that takes a list. Writing the function as sum' = foldl (+) 0 is called writing it in point free style.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>How would we write this in point free style?</p>
<pre><code>fn x = ceiling (negate (tan (cos (max 50 x))))
</code></pre>
<p>We can't just get rid of the x on both right right sides. The x in the function body has parentheses after it. cos (max 50) wouldn't make sense. You can't get the cosine of a function. What we can do is express fn as a composition of functions.</p>
<pre><code>fn = ceiling . negate . tan . cos . max 50
</code></pre>
<p>Excellent! Many times, a point free style is more readable and concise, because it makes you think about functions and what kind of functions composing them results in instead of thinking about data and how it's shuffled around. You can take simple functions and use composition as glue to form more complex functions. However, many times, writing a function in point free style can be less readable if a function is too complex. That's why making long chains of function composition is discouraged, although I plead guilty of sometimes being too composition-happy. The prefered style is to use let bindings to give labels to intermediary results or split the problem into sub-problems and then put it together so that the function makes sense to someone reading it instead of just making a huge composition chain.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>In the section about maps and filters, we solved a problem of finding the sum of all odd squares that are smaller than 10,000. Here's what the solution looks like when put into a function.</p>
<pre><code>oddSquareSum :: Integer  
oddSquareSum = sum (takeWhile (&lt;10000) (filter odd (map (^2) [1..])))
</code></pre>
<p>Being such a fan of function composition, I would have probably written that like this:</p>
<pre><code>oddSquareSum :: Integer  
oddSquareSum = sum . takeWhile (&lt;10000) . filter odd . map (^2) $ [1..]
</code></pre>
<p>However, if there was a chance of someone else reading that code, I would have written it like this:</p>
<pre><code>oddSquareSum :: Integer  
oddSquareSum =   
    let oddSquares = filter odd $ map (^2) [1..]  
        belowLimit = takeWhile (&lt;10000) oddSquares  
    in  sum belowLimit
</code></pre>
<p>It wouldn't win any code golf competition, but someone reading the function will probably find it easier to read than a composition chain.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Modules</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>A Haskell module is a collection of related functions, types and typeclasses. A Haskell program is a collection of modules where the main module loads up the other modules and then uses the functions defined in them to do something. Having code split up into several modules has quite a lot of advantages. If a module is generic enough, the functions it exports can be used in a multitude of different programs. If your own code is separated into self-contained modules which don't rely on each other too much (we also say they are loosely coupled), you can reuse them later on. It makes the whole deal of writing code more manageable by having it split into several parts, each of which has some sort of purpose.</p>
<p>The Haskell standard library is split into modules, each of them contains functions and types that are somehow related and serve some common purpose. There's a module for manipulating lists, a module for concurrent programming, a module for dealing with complex numbers, etc. All the functions, types and typeclasses that we've dealt with so far were part of the Prelude module, which is imported by default. In this chapter, we're going to examine a few useful modules and the functions that they have. But first, we're going to see how to import modules.</p>
<p>The syntax for importing modules in a Haskell script is import <module name>. This must be done before defining any functions, so imports are usually done at the top of the file. One script can, of course, import several modules. Just put each import statement into a separate line. Let's import the Data.List module, which has a bunch of useful functions for working with lists and use a function that it exports to create a function that tells us how many unique elements a list has.</p>
<pre><code>import Data.List

numUniques :: (Eq a) =&gt; [a] -&gt; Int  
numUniques = length . nub
</code></pre>
<p>When you do import Data.List, all the functions that Data.List exports become available in the global namespace, meaning that you can call them from wherever in the script. nub is a function defined in Data.List that takes a list and weeds out duplicate elements. Composing length and nub by doing length . nub produces a function that's the equivalent of \xs -&gt; length (nub xs).</p>
<p>You can also put the functions of modules into the global namespace when using GHCI. If you're in GHCI and you want to be able to call the functions exported by Data.List, do this:</p>
<pre><code>Prelude&gt; :m + Data.List
</code></pre>
<p>If we want to load up the names from several modules inside GHCI, we don't have to do :m + several times, we can just load up several modules at once.</p>
<pre><code>Prelude&gt; :m + Data.List Data.Map Data.Set
</code></pre>
<p>However, if you've loaded a script that already imports a module, you don't need to use :m + to get access to it.</p>
<p>If you just need a couple of functions from a module, you can selectively import just those functions. If we wanted to import only the nub and sort functions from Data.List, we'd do this:</p>
<pre><code>import Data.List (nub, sort)
</code></pre>
<p>You can also choose to import all of the functions of a module except a few select ones. That's often useful when several modules export functions with the same name and you want to get rid of the offending ones. Say we already have our own function that's called nub and we want to import all the functions from Data.List except the nub function:</p>
<pre><code>import Data.List hiding (nub)
</code></pre>
<p>Another way of dealing with name clashes is to do qualified imports. The Data.Map module, which offers a data structure for looking up values by key, exports a bunch of functions with the same name as Prelude functions, like filter or null. So when we import Data.Map and then call filter, Haskell won't know which function to use. Here's how we solve this:</p>
<pre><code>import qualified Data.Map
</code></pre>
<p>This makes it so that if we want to reference Data.Map's filter function, we have to do Data.Map.filter, whereas just filter still refers to the normal filter we all know and love. But typing out Data.Map in front of every function from that module is kind of tedious. That's why we can rename the qualified import to something shorter:</p>
<pre><code>import qualified Data.Map as M
</code></pre>
<p>Now, to reference Data.Map's filter function, we just use M.filter.</p>
<p>Use this handy reference to see which modules are in the standard library. A great way to pick up new Haskell knowledge is to just click through the standard library reference and explore the modules and their functions. You can also view the Haskell source code for each module. Reading the source code of some modules is a really good way to learn Haskell and get a solid feel for it.</p>
<p>To search for functions or to find out where they're located, use Hoogle. It's a really awesome Haskell search engine, you can search by name, module name or even type signature.
Data.List</p>
<p>The Data.List module is all about lists, obviously. It provides some very useful functions for dealing with them. We've already met some of its functions (like map and filter) because the Prelude module exports some functions from Data.List for convenience. You don't have to import Data.List via a qualified import because it doesn't clash with any Prelude names except for those that Prelude already steals from Data.List. Let's take a look at some of the functions that we haven't met before.</p>
<p>intersperse takes an element and a list and then puts that element in between each pair of elements in the list. Here's a demonstration:</p>
<pre><code>Prelude&gt; intersperse '.' "MONKEY"  
"M.O.N.K.E.Y"  
Prelude&gt; intersperse 0 [1,2,3,4,5,6]  
[1,0,2,0,3,0,4,0,5,0,6]
</code></pre>
<p>intercalate takes a list of lists and a list. It then inserts that list in between all those lists and then flattens the result.</p>
<pre><code>Prelude&gt; intercalate " " ["hey","there","guys"]  
"hey there guys"  
Prelude&gt; intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]  
[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]
</code></pre>
<p>transpose transposes a list of lists. If you look at a list of lists as a 2D matrix, the columns become the rows and vice versa.</p>
<pre><code>Prelude&gt; transpose [[1,2,3],[4,5,6],[7,8,9]]  
[[1,4,7],[2,5,8],[3,6,9]]  
Prelude&gt; transpose ["hey","there","guys"]  
["htg","ehu","yey","rs","e"]
</code></pre>
<p>Say we have the polynomials 3x2 + 5x + 9, 10x3 + 9 and 8x3 + 5x2 + x - 1 and we want to add them together. We can use the lists [0,3,5,9], [10,0,0,9] and [8,5,1,-1] to represent them in Haskell. Now, to add them, all we have to do is this:</p>
<pre><code>Prelude&gt; map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]  
[18,8,6,17]
</code></pre>
<p>When we transpose these three lists, the third powers are then in the first row, the second powers in the second one and so on. Mapping sum to that produces our desired result.
shopping lists</p>
<p>foldl' and foldl1' are stricter versions of their respective lazy incarnations. When using lazy folds on really big lists, you might often get a stack overflow error. The culprit for that is that due to the lazy nature of the folds, the accumulator value isn't actually updated as the folding happens. What actually happens is that the accumulator kind of makes a promise that it will compute its value when asked to actually produce the result (also called a thunk). That happens for every intermediate accumulator and all those thunks overflow your stack. The strict folds aren't lazy buggers and actually compute the intermediate values as they go along instead of filling up your stack with thunks. So if you ever get stack overflow errors when doing lazy folds, try switching to their strict versions.</p>
<p>concat flattens a list of lists into just a list of elements.</p>
<pre><code>Prelude&gt; concat ["foo","bar","car"]  
"foobarcar"  
Prelude&gt; concat [[3,4,5],[2,3,4],[2,1,1]]  
[3,4,5,2,3,4,2,1,1]
</code></pre>
<p>It will just remove one level of nesting. So if you want to completely flatten [[[2,3],[3,4,5],[2]],[[2,3],[3,4]]], which is a list of lists of lists, you have to concatenate it twice.</p>
<p>Doing concatMap is the same as first mapping a function to a list and then concatenating the list with concat.</p>
<pre><code>Prelude&gt; concatMap (replicate 4) [1..3]  
[1,1,1,1,2,2,2,2,3,3,3,3]
</code></pre>
<p>and takes a list of boolean values and returns True only if all the values in the list are True.</p>
<pre><code>Prelude&gt; and $ map (&gt;4) [5,6,7,8]  
True  
Prelude&gt; and $ map (==4) [4,4,4,3,4]  
False
</code></pre>
<p>or is like and, only it returns True if any of the boolean values in a list is True.</p>
<pre><code>Prelude&gt; or $ map (==4) [2,3,4,5,6,1]  
True  
Prelude&gt; or $ map (&gt;4) [1,2,3]  
False
</code></pre>
<p>any and all take a predicate and then check if any or all the elements in a list satisfy the predicate, respectively. Usually we use these two functions instead of mapping over a list and then doing and or or.</p>
<pre><code>Prelude&gt; any (==4) [2,3,5,6,1,4]  
True  
Prelude&gt; all (&gt;4) [6,9,10]  
True  
Prelude&gt; all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
False  
Prelude&gt; any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
True
</code></pre>
<p>iterate takes a function and a starting value. It applies the function to the starting value, then it applies that function to the result, then it applies the function to that result again, etc. It returns all the results in the form of an infinite list.</p>
<pre><code>Prelude&gt; take 10 $ iterate (*2) 1  
[1,2,4,8,16,32,64,128,256,512]  
Prelude&gt; take 3 $ iterate (++ "haha") "haha"  
["haha","hahahaha","hahahahahaha"]
</code></pre>
<p>splitAt takes a number and a list. It then splits the list at that many elements, returning the resulting two lists in a tuple.</p>
<pre><code>Prelude&gt; splitAt 3 "heyman"  
("hey","man")  
Prelude&gt; splitAt 100 "heyman"  
("heyman","")  
Prelude&gt; splitAt (-3) "heyman"  
("","heyman")  
Prelude&gt; let (a,b) = splitAt 3 "foobar" in b ++ a  
"barfoo"
</code></pre>
<p>takeWhile is a really useful little function. It takes elements from a list while the predicate holds and then when an element is encountered that doesn't satisfy the predicate, it's cut off. It turns out this is very useful.</p>
<pre><code>Prelude&gt; takeWhile (&gt;3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]  
[6,5,4]  
Prelude&gt; takeWhile (/=' ') "This is a sentence"  
"This"
</code></pre>
<p>Say we wanted to know the sum of all third powers that are under 10,000. We can't map (^3) to [1..], apply a filter and then try to sum that up because filtering an infinite list never finishes. You may know that all the elements here are ascending but Haskell doesn't. That's why we can do this:</p>
<pre><code>Prelude&gt; sum $ takeWhile (&lt;10000) $ map (^3) [1..]  
53361
</code></pre>
<p>We apply (^3) to an infinite list and then once an element that's over 10,000 is encountered, the list is cut off. Now we can sum it up easily.</p>
<p>dropWhile is similar, only it drops all the elements while the predicate is true. Once predicate equates to False, it returns the rest of the list. An extremely useful and lovely function!</p>
<pre><code>Prelude&gt; dropWhile (/=' ') "This is a sentence"  
" is a sentence"  
Prelude&gt; dropWhile (&lt;3) [1,2,2,2,3,4,5,4,3,2,1]  
[3,4,5,4,3,2,1]
</code></pre>
<p>We're given a list that represents the value of a stock by date. The list is made of tuples whose first component is the stock value, the second is the year, the third is the month and the fourth is the date. We want to know when the stock value first exceeded one thousand dollars!</p>
<pre><code>Prelude&gt; let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]  
Prelude&gt; head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)  
(1001.4,2008,9,4)
</code></pre>
<p>span is kind of like takeWhile, only it returns a pair of lists. The first list contains everything the resulting list from takeWhile would contain if it were called with the same predicate and the same list. The second list contains the part of the list that would have been dropped.</p>
<pre><code>Prelude&gt; let (fw, rest) = span (/=' ') "This is a sentence" in "First word:" ++ fw ++ ", the rest:" ++ rest  
"First word: This, the rest: is a sentence"
</code></pre>
<p>Whereas span spans the list while the predicate is true, break breaks it when the predicate is first true. Doing break p is the equivalent of doing span (not . p).</p>
<pre><code>Prelude&gt; break (==4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])  
Prelude&gt; span (/=4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])
</code></pre>
<p>When using break, the second list in the result will start with the first element that satisfies the predicate.</p>
<p>sort simply sorts a list. The type of the elements in the list has to be part of the Ord typeclass, because if the elements of a list can't be put in some kind of order, then the list can't be sorted.</p>
<pre><code>Prelude&gt; sort [8,5,3,2,1,6,4,2]  
[1,2,2,3,4,5,6,8]  
Prelude&gt; sort "This will be sorted soon"  
"    Tbdeehiillnooorssstw"
</code></pre>
<p>group takes a list and groups adjacent elements into sublists if they are equal.</p>
<pre><code>Prelude&gt; group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]
</code></pre>
<p>If we sort a list before grouping it, we can find out how many times each element appears in the list.</p>
<pre><code>Prelude&gt; map (\l@(x:xs) -&gt; (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
</code></pre>
<p>inits and tails are like init and tail, only they recursively apply that to a list until there's nothing left. Observe.</p>
<pre><code>Prelude&gt; inits "w00t"  
["","w","w0","w00","w00t"]  
Prelude&gt; tails "w00t"  
["w00t","00t","0t","t",""]  
Prelude&gt; let w = "w00t" in zip (inits w) (tails w)  
[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]
</code></pre>
<p>Let's use a fold to implement searching a list for a sublist.</p>
<pre><code>search :: (Eq a) =&gt; [a] -&gt; [a] -&gt; Bool  
search needle haystack =   
    let nlen = length needle  
    in  foldl (\acc x -&gt; if take nlen x == needle then True else acc) False (tails haystack)
</code></pre>
<p>First we call tails with the list in which we're searching. Then we go over each tail and see if it starts with what we're looking for.</p>
<p>With that, we actually just made a function that behaves like isInfixOf. isInfixOf searches for a sublist within a list and returns True if the sublist we're looking for is somewhere inside the target list.</p>
<pre><code>Prelude&gt; "cat" `isInfixOf` "im a cat burglar"  
True  
Prelude&gt; "Cat" `isInfixOf` "im a cat burglar"  
False  
Prelude&gt; "cats" `isInfixOf` "im a cat burglar"  
False
</code></pre>
<p>isPrefixOf and isSuffixOf search for a sublist at the beginning and at the end of a list, respectively.</p>
<pre><code>Prelude&gt; "hey" `isPrefixOf` "hey there!"  
True  
Prelude&gt; "hey" `isPrefixOf` "oh hey there!"  
False  
Prelude&gt; "there!" `isSuffixOf` "oh hey there!"  
True  
Prelude&gt; "there!" `isSuffixOf` "oh hey there"  
False
</code></pre>
<p>elem and notElem check if an element is or isn't inside a list.</p>
<p>partition takes a list and a predicate and returns a pair of lists. The first list in the result contains all the elements that satisfy the predicate, the second contains all the ones that don't.</p>
<pre><code>Prelude&gt; partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"  
("BOBMORGAN","sidneyeddy")  
Prelude&gt; partition (&gt;3) [1,3,5,6,3,2,1,0,3,7]  
([5,6,7],[1,3,3,2,1,0,3])
</code></pre>
<p>It's important to understand how this is different from span and break:</p>
<pre><code>Prelude&gt; span (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"  
("BOB","sidneyMORGANeddy")
</code></pre>
<p>While span and break are done once they encounter the first element that doesn't and does satisfy the predicate, partition goes through the whole list and splits it up according to the predicate.</p>
<p>find takes a list and a predicate and returns the first element that satisfies the predicate. But it returns that element wrapped in a Maybe value. We'll be covering algebraic data types more in depth in the next chapter but for now, this is what you need to know: a Maybe value can either be Just something or Nothing. Much like a list can be either an empty list or a list with some elements, a Maybe value can be either no elements or a single element. And like the type of a list of, say, integers is [Int], the type of maybe having an integer is Maybe Int. Anyway, let's take our find function for a spin.</p>
<pre><code>Prelude&gt; find (&gt;4) [1,2,3,4,5,6]  
Just 5  
Prelude&gt; find (&gt;9) [1,2,3,4,5,6]  
Nothing  
Prelude&gt; :t find  
find :: (a -&gt; Bool) -&gt; [a] -&gt; Maybe a
</code></pre>
<p>Notice the type of find. Its result is Maybe a. That's kind of like having the type of [a], only a value of the type Maybe can contain either no elements or one element, whereas a list can contain no elements, one element or several elements.</p>
<p>Remember when we were searching for the first time our stock went over $1000. We did head (dropWhile ((val,y,m,d) -&gt; val &lt; 1000) stock). Remember that head is not really safe. What would happen if our stock never went over $1000? Our application of dropWhile would return an empty list and getting the head of an empty list would result in an error. However, if we rewrote that as find ((val,y,m,d) -&gt; val &gt; 1000) stock, we'd be much safer. If our stock never went over $1000 (so if no element satisfied the predicate), we'd get back a Nothing. But there was a valid answer in that list, we'd get, say, Just (1001.4,2008,9,4).</p>
<p>elemIndex is kind of like elem, only it doesn't return a boolean value. It maybe returns the index of the element we're looking for. If that element isn't in our list, it returns a Nothing.</p>
<pre><code>Prelude&gt; :t elemIndex  
elemIndex :: (Eq a) =&gt; a -&gt; [a] -&gt; Maybe Int  
Prelude&gt; 4 `elemIndex` [1,2,3,4,5,6]  
Just 3  
Prelude&gt; 10 `elemIndex` [1,2,3,4,5,6]  
Nothing
</code></pre>
<p>elemIndices is like elemIndex, only it returns a list of indices, in case the element we're looking for crops up in our list several times. Because we're using a list to represent the indices, we don't need a Maybe type, because failure can be represented as the empty list, which is very much synonymous to Nothing.</p>
<pre><code>Prelude&gt; ' ' `elemIndices` "Where are the spaces?"  
[5,9,13]
</code></pre>
<p>findIndex is like find, but it maybe returns the index of the first element that satisfies the predicate. findIndices returns the indices of all elements that satisfy the predicate in the form of a list.</p>
<pre><code>Prelude&gt; findIndex (==4) [5,3,2,1,6,4]  
Just 5  
Prelude&gt; findIndex (==7) [5,3,2,1,6,4]  
Nothing  
Prelude&gt; findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"  
[0,6,10,14]
</code></pre>
<p>We already covered zip and zipWith. We noted that they zip together two lists, either in a tuple or with a binary function (meaning such a function that takes two parameters). But what if we want to zip together three lists? Or zip three lists with a function that takes three parameters? Well, for that, we have zip3, zip4, etc. and zipWith3, zipWith4, etc. These variants go up to 7. While this may look like a hack, it works out pretty fine, because there aren't many times when you want to zip 8 lists together. There's also a very clever way for zipping infinite numbers of lists, but we're not advanced enough to cover that just yet.</p>
<pre><code>Prelude&gt; zipWith3 (\x y z -&gt; x + y + z) [1,2,3] [4,5,2,2] [2,2,3]  
[7,9,8]  
Prelude&gt; zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]  
[(2,2,5,2),(3,2,5,2),(3,2,3,2)]
</code></pre>
<p>Just like with normal zipping, lists that are longer than the shortest list that's being zipped are cut down to size.</p>
<p>lines is a useful function when dealing with files or input from somewhere. It takes a string and returns every line of that string in a separate list.</p>
<pre><code>Prelude&gt; lines "first line\nsecond line\nthird line"  
["first line","second line","third line"]
</code></pre>
<p>'\n' is the character for a unix newline. Backslashes have special meaning in Haskell strings and characters.</p>
<p>unlines is the inverse function of lines. It takes a list of strings and joins them together using a '\n'.</p>
<pre><code>Prelude&gt; unlines ["first line", "second line", "third line"]  
"first line\nsecond line\nthird line\n"
</code></pre>
<p>words and unwords are for splitting a line of text into words or joining a list of words into a text. Very useful.</p>
<pre><code>Prelude&gt; words "hey these are the words in this sentence"  
["hey","these","are","the","words","in","this","sentence"]  
Prelude&gt; words "hey these           are    the words in this\nsentence"  
["hey","these","are","the","words","in","this","sentence"]  
Prelude&gt; unwords ["hey","there","mate"]  
"hey there mate"
</code></pre>
<p>We've already mentioned nub. It takes a list and weeds out the duplicate elements, returning a list whose every element is a unique snowflake! The function does have a kind of strange name. It turns out that "nub" means a small lump or essential part of something. In my opinion, they should use real words for function names instead of old-people words.</p>
<pre><code>Prelude&gt; nub [1,2,3,4,3,2,1,2,3,4,3,2,1]  
[1,2,3,4]  
Prelude&gt; nub "Lots of words and stuff"  
"Lots fwrdanu"
</code></pre>
<p>delete takes an element and a list and deletes the first occurence of that element in the list.</p>
<pre><code>Prelude&gt; delete 'h' "hey there ghang!"  
"ey there ghang!"  
Prelude&gt; delete 'h' . delete 'h' $ "hey there ghang!"  
"ey tere ghang!"  
Prelude&gt; delete 'h' . delete 'h' . delete 'h' $ "hey there ghang!"  
"ey tere gang!"
</code></pre>
<p>\ is the list difference function. It acts like a set difference, basically. For every element in the right-hand list, it removes a matching element in the left one.</p>
<pre><code>Prelude&gt; [1..10] \\ [2,5,9]  
[1,3,4,6,7,8,10]  
Prelude&gt; "Im a big baby" \\ "big"  
"Im a  baby"
</code></pre>
<p>Doing [1..10] \ [2,5,9] is like doing delete 2 . delete 5 . delete 9 $ [1..10].</p>
<p>union also acts like a function on sets. It returns the union of two lists. It pretty much goes over every element in the second list and appends it to the first one if it isn't already in yet. Watch out though, duplicates are removed from the second list!</p>
<pre><code>Prelude&gt; "hey man" `union` "man what's up"  
"hey manwt'sup"  
Prelude&gt; [1..7] `union` [5..10]  
[1,2,3,4,5,6,7,8,9,10]
</code></pre>
<p>intersect works like set intersection. It returns only the elements that are found in both lists.</p>
<pre><code>Prelude&gt; [1..7] `intersect` [5..10]  
[5,6,7]
</code></pre>
<p>insert takes an element and a list of elements that can be sorted and inserts it into the last position where it's still less than or equal to the next element. In other words, insert will start at the beginning of the list and then keep going until it finds an element that's equal to or greater than the element that we're inserting and it will insert it just before the element.</p>
<pre><code>Prelude&gt; insert 4 [3,5,1,2,8,2]  
[3,4,5,1,2,8,2]  
Prelude&gt; insert 4 [1,3,4,4,1]  
[1,3,4,4,4,1]
</code></pre>
<p>The 4 is inserted right after the 3 and before the 5 in the first example and in between the 3 and 4 in the second example.
If we use insert to insert into a sorted list, the resulting list will be kept sorted.</p>
<pre><code>Prelude&gt; insert 4 [1,2,3,5,6,7]  
[1,2,3,4,5,6,7]  
Prelude&gt; insert 'g' $ ['a'..'f'] ++ ['h'..'z']  
"abcdefghijklmnopqrstuvwxyz"  
Prelude&gt; insert 3 [1,2,4,3,2,1]  
[1,2,3,4,3,2,1]
</code></pre>
<p>What length, take, drop, splitAt, !! and replicate have in common is that they take an Int as one of their parameters (or return an Int), even though they could be more generic and usable if they just took any type that's part of the Integral or Num typeclasses (depending on the functions). They do that for historical reasons. However, fixing that would probably break a lot of existing code. That's why Data.List has their more generic equivalents, named genericLength, genericTake, genericDrop, genericSplitAt, genericIndex and genericReplicate. For instance, length has a type signature of length :: [a] -&gt; Int. If we try to get the average of a list of numbers by doing let xs = [1..6] in sum xs / length xs, we get a type error, because you can't use / with an Int. genericLength, on the other hand, has a type signature of genericLength :: (Num a) =&gt; [b] -&gt; a. Because a Num can act like a floating point number, getting the average by doing let xs = [1..6] in sum xs / genericLength xs works out just fine.</p>
<p>The nub, delete, union, intersect and group functions all have their more general counterparts called nubBy, deleteBy, unionBy, intersectBy and groupBy. The difference between them is that the first set of functions use == to test for equality, whereas the By ones also take an equality function and then compare them by using that equality function. group is the same as groupBy (==).</p>
<p>For instance, say we have a list that describes the value of a function for every second. We want to segment it into sublists based on when the value was below zero and when it went above. If we just did a normal group, it would just group the equal adjacent values together. But what we want is to group them by whether they are negative or not. That's where groupBy comes in! The equality function supplied to the By functions should take two elements of the same type and return True if it considers them equal by its standards.</p>
<pre><code>Prelude&gt; let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]  
Prelude&gt; groupBy (\x y -&gt; (x &gt; 0) == (y &gt; 0)) values  
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
</code></pre>
<p>From this, we clearly see which sections are positive and which are negative. The equality function supplied takes two elements and then returns True only if they're both negative or if they're both positive. This equality function can also be written as \x y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0) &amp;&amp; (y &lt;= 0), although I think the first way is more readable. An even clearer way to write equality functions for the By functions is if you import the on function from Data.Function. on is defined like this:</p>
<pre><code>on :: (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c  
f `on` g = \x y -&gt; f (g x) (g y)
</code></pre>
<p>So doing (==) <code>on</code> (&gt; 0) returns an equality function that looks like \x y -&gt; (x &gt; 0) == (y &gt; 0). on is used a lot with the By functions because with it, we can do:</p>
<pre><code>Prelude&gt; groupBy ((==) `on` (&gt; 0)) values  
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
</code></pre>
<p>Very readable indeed! You can read it out loud: Group this by equality on whether the elements are greater than zero.</p>
<p>Similarly, the sort, insert, maximum and minimum also have their more general equivalents. Functions like groupBy take a function that determines when two elements are equal. sortBy, insertBy, maximumBy and minimumBy take a function that determine if one element is greater, smaller or equal to the other. The type signature of sortBy is sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]. If you remember from before, the Ordering type can have a value of LT, EQ or GT. sort is the equivalent of sortBy compare, because compare just takes two elements whose type is in the Ord typeclass and returns their ordering relationship.</p>
<p>Lists can be compared, but when they are, they are compared lexicographically. What if we have a list of lists and we want to sort it not based on the inner lists' contents but on their lengths? Well, as you've probably guessed, we'll use the sortBy function.</p>
<pre><code>Prelude&gt; let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]  
Prelude&gt; sortBy (compare `on` length) xs  
[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]
</code></pre>
<p>Awesome! compare <code>on</code> length ... man, that reads almost like real English! If you're not sure how exactly the on works here, compare <code>on</code> length is the equivalent of \x y -&gt; length x <code>compare</code> length y. When you're dealing with By functions that take an equality function, you usually do (==) <code>on</code> something and when you're dealing with By functions that take an ordering function, you usually do compare <code>on</code> something.
Data.Char
lego char</p>
<p>The Data.Char module does what its name suggests. It exports functions that deal with characters. It's also helpful when filtering and mapping over strings because they're just lists of characters.</p>
<p>Data.Char exports a bunch of predicates over characters. That is, functions that take a character and tell us whether some assumption about it is true or false. Here's what they are:</p>
<p>isControl checks whether a character is a control character.</p>
<p>isSpace checks whether a character is a white-space characters. That includes spaces, tab characters, newlines, etc.</p>
<p>isLower checks whether a character is lower-cased.</p>
<p>isUpper checks whether a character is upper-cased.</p>
<p>isAlpha checks whether a character is a letter.</p>
<p>isAlphaNum checks whether a character is a letter or a number.</p>
<p>isPrint checks whether a character is printable. Control characters, for instance, are not printable.</p>
<p>isDigit checks whether a character is a digit.</p>
<p>isOctDigit checks whether a character is an octal digit.</p>
<p>isHexDigit checks whether a character is a hex digit.</p>
<p>isLetter checks whether a character is a letter.</p>
<p>isMark checks for Unicode mark characters. Those are characters that combine with preceding letters to form latters with accents. Use this if you are French.</p>
<p>isNumber checks whether a character is numeric.</p>
<p>isPunctuation checks whether a character is punctuation.</p>
<p>isSymbol checks whether a character is a fancy mathematical or currency symbol.</p>
<p>isSeparator checks for Unicode spaces and separators.</p>
<p>isAscii checks whether a character falls into the first 128 characters of the Unicode character set.</p>
<p>isLatin1 checks whether a character falls into the first 256 characters of Unicode.</p>
<p>isAsciiUpper checks whether a character is ASCII and upper-case.</p>
<p>isAsciiLower checks whether a character is ASCII and lower-case.</p>
<p>All these predicates have a type signature of Char -&gt; Bool. Most of the time you'll use this to filter out strings or something like that. For instance, let's say we're making a program that takes a username and the username can only be comprised of alphanumeric characters. We can use the Data.List function all in combination with the Data.Char predicates to determine if the username is alright.</p>
<pre><code>Prelude&gt; all isAlphaNum "bobby283"  
True  
Prelude&gt; all isAlphaNum "eddy the fish!"  
False
</code></pre>
<p>Kewl. In case you don't remember, all takes a predicate and a list and returns True only if that predicate holds for every element in the list.</p>
<p>We can also use isSpace to simulate the Data.List function words.</p>
<pre><code>Prelude&gt; words "hey guys its me"  
["hey","guys","its","me"]  
Prelude&gt; groupBy ((==) `on` isSpace) "hey guys its me"  
["hey"," ","guys"," ","its"," ","me"]  
Prelude&gt;
</code></pre>
<p>Hmmm, well, it kind of does what words does but we're left with elements of only spaces. Hmm, whatever shall we do? I know, let's filter that sucker.</p>
<pre><code>Prelude&gt; filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"  
["hey","guys","its","me"]
</code></pre>
<p>Ah.</p>
<p>The Data.Char also exports a datatype that's kind of like Ordering. The Ordering type can have a value of LT, EQ or GT. It's a sort of enumeration. It describes a few possible results that can arise from comparing two elements. The GeneralCategory type is also an enumeration. It presents us with a few possible categories that a character can fall into. The main function for getting the general category of a character is generalCategory. It has a type of generalCategory :: Char -&gt; GeneralCategory. There are about 31 categories so we won't list them all here, but let's play around with the function.</p>
<pre><code>Prelude&gt; generalCategory ' '  
Space  
Prelude&gt; generalCategory 'A'  
UppercaseLetter  
Prelude&gt; generalCategory 'a'  
LowercaseLetter  
Prelude&gt; generalCategory '.'  
OtherPunctuation  
Prelude&gt; generalCategory '9'  
DecimalNumber  
Prelude&gt; map generalCategory " \t\nA9?|"  
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]
</code></pre>
<p>Since the GeneralCategory type is part of the Eq typeclass, we can also test for stuff like generalCategory c == Space.</p>
<p>toUpper converts a character to upper-case. Spaces, numbers, and the like remain unchanged.</p>
<p>toLower converts a character to lower-case.</p>
<p>toTitle converts a character to title-case. For most characters, title-case is the same as upper-case.</p>
<p>digitToInt converts a character to an Int. To succeed, the character must be in the ranges '0'..'9', 'a'..'f' or 'A'..'F'.</p>
<pre><code>Prelude&gt; map digitToInt "34538"  
[3,4,5,3,8]  
Prelude&gt; map digitToInt "FF85AB"  
[15,15,8,5,10,11]
</code></pre>
<p>intToDigit is the inverse function of digitToInt. It takes an Int in the range of 0..15 and converts it to a lower-case character.</p>
<pre><code>Prelude&gt; intToDigit 15  
'f'  
Prelude&gt; intToDigit 5  
'5'
</code></pre>
<p>The ord and chr functions convert characters to their corresponding numbers and vice versa:</p>
<pre><code>Prelude&gt; ord 'a'  
97  
Prelude&gt; chr 97  
'a'  
Prelude&gt; map ord "abcdefgh"  
[97,98,99,100,101,102,103,104]
</code></pre>
<p>The difference between the ord values of two characters is equal to how far apart they are in the Unicode table.</p>
<p>The Caesar cipher is a primitive method of encoding messages by shifting each character in them by a fixed number of positions in the alphabet. We can easily create a sort of Caesar cipher of our own, only we won't constrict ourselves to the alphabet.</p>
<pre><code>encode :: Int -&gt; String -&gt; String  
encode shift msg = 
    let ords = map ord msg  
        shifted = map (+ shift) ords  
    in  map chr shifted
</code></pre>
<p>Here, we first convert the string to a list of numbers. Then we add the shift amount to each number before converting the list of numbers back to characters. If you're a composition cowboy, you could write the body of this function as map (chr . (+ shift) . ord) msg. Let's try encoding a few messages.</p>
<pre><code>Prelude&gt; encode 3 "Heeeeey"  
"Khhhhh|"  
Prelude&gt; encode 4 "Heeeeey"  
"Liiiii}"  
Prelude&gt; encode 1 "abcd"  
"bcde"  
Prelude&gt; encode 5 "Marry Christmas! Ho ho ho!"  
"Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;"
</code></pre>
<p>That's encoded alright. Decoding a message is basically just shifting it back by the number of places it was shifted by in the first place.</p>
<pre><code>decode :: Int -&gt; String -&gt; String  
decode shift msg = encode (negate shift) msg

Prelude&gt; encode 3 "Im a little teapot"  
"Lp#d#olwwoh#whdsrw"  
Prelude&gt; decode 3 "Lp#d#olwwoh#whdsrw"  
"Im a little teapot"  
Prelude&gt; decode 5 . encode 5 $ "This is a sentence"  
"This is a sentence"
</code></pre>
<p>Data.Map</p>
<p>Association lists (also called dictionaries) are lists that are used to store key-value pairs where ordering doesn't matter. For instance, we might use an association list to store phone numbers, where phone numbers would be the values and people's names would be the keys. We don't care in which order they're stored, we just want to get the right phone number for the right person.</p>
<p>The most obvious way to represent association lists in Haskell would be by having a list of pairs. The first component in the pair would be the key, the second component the value. Here's an example of an association list with phone numbers:</p>
<pre><code>phoneBook =   
    [("betty","555-2938")  
    ,("bonnie","452-2928")  
    ,("patsy","493-2928")  
    ,("lucille","205-2928")  
    ,("wendy","939-8282")  
    ,("penny","853-2492")  
    ]
</code></pre>
<p>Despite this seemingly odd indentation, this is just a list of pairs of strings. The most common task when dealing with association lists is looking up some value by key. Let's make a function that looks up some value given a key.</p>
<pre><code>findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; v  
findKey key xs = snd . head . filter (\(k,v) -&gt; key == k) $ xs
</code></pre>
<p>Pretty simple. The function that takes a key and a list, filters the list so that only matching keys remain, gets the first key-value that matches and returns the value. But what happens if the key we're looking for isn't in the association list? Hmm. Here, if a key isn't in the association list, we'll end up trying to get the head of an empty list, which throws a runtime error. However, we should avoid making our programs so easy to crash, so let's use the Maybe data type. If we don't find the key, we'll return a Nothing. If we find it, we'll return Just something, where something is the value corresponding to that key.</p>
<pre><code>findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v  
findKey key [] = Nothing  
findKey key ((k,v):xs) = if key == k  
                            then Just v  
                            else findKey key xs
</code></pre>
<p>Look at the type declaration. It takes a key that can be equated, an association list and then it maybe produces a value. Sounds about right.</p>
<p>This is a textbook recursive function that operates on a list. Edge case, splitting a list into a head and a tail, recursive calls, they're all there. This is the classic fold pattern, so let's see how this would be implemented as a fold.</p>
<pre><code>findKey :: (Eq k) =&gt; k -&gt; [(k,v)] -&gt; Maybe v  
findKey key = foldr (\(k,v) acc -&gt; if key == k then Just v else acc) Nothing
</code></pre>
<p>Note: It's usually better to use folds for this standard list recursion pattern instead of explicitly writing the recursion because they're easier to read and identify. Everyone knows it's a fold when they see the foldr call, but it takes some more thinking to read explicit recursion.</p>
<pre><code>Prelude&gt; findKey "penny" phoneBook  
Just "853-2492"  
Prelude&gt; findKey "betty" phoneBook  
Just "555-2938"  
Prelude&gt; findKey "wilma" phoneBook  
Nothing
</code></pre>
<p>legomap</p>
<p>Works like a charm! If we have the girl's phone number, we Just get the number, otherwise we get Nothing.</p>
<p>We just implemented the lookup function from Data.List. If we want to find the corresponding value to a key, we have to traverse all the elements of the list until we find it. The Data.Map module offers association lists that are much faster (because they're internally implemented with trees) and also it provides a lot of utility functions. From now on, we'll say we're working with maps instead of association lists.</p>
<p>Because Data.Map exports functions that clash with the Prelude and Data.List ones, we'll do a qualified import.</p>
<pre><code>import qualified Data.Map as Map
</code></pre>
<p>Put this import statement into a script and then load the script via GHCI.</p>
<p>Let's go ahead and see what Data.Map has in store for us! Here's the basic rundown of its functions.</p>
<p>The fromList function takes an association list (in the form of a list) and returns a map with the same associations.</p>
<pre><code>Prelude&gt; Map.fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]  
fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]  
Prelude&gt; Map.fromList [(1,2),(3,4),(3,2),(5,5)]  
fromList [(1,2),(3,2),(5,5)]
</code></pre>
<p>If there are duplicate keys in the original association list, the duplicates are just discarded. This is the type signature of fromList</p>
<pre><code>Map.fromList :: (Ord k) =&gt; [(k, v)] -&gt; Map.Map k v
</code></pre>
<p>It says that it takes a list of pairs of type k and v and returns a map that maps from keys of type k to type v. Notice that when we were doing association lists with normal lists, the keys only had to be equatable (their type belonging to the Eq typeclass) but now they have to be orderable. That's an essential constraint in the Data.Map module. It needs the keys to be orderable so it can arrange them in a tree.</p>
<p>You should always use Data.Map for key-value associations unless you have keys that aren't part of the Ord typeclass.</p>
<p>empty represents an empty map. It takes no arguments, it just returns an empty map.</p>
<pre><code>Prelude&gt; Map.empty  
fromList []
</code></pre>
<p>insert takes a key, a value and a map and returns a new map that's just like the old one, only with the key and value inserted.</p>
<pre><code>Prelude&gt; Map.empty  
fromList []  
Prelude&gt; Map.insert 3 100 Map.empty  
fromList [(3,100)]  
Prelude&gt; Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))  
fromList [(3,100),(4,200),(5,600)]  
Prelude&gt; Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty  
fromList [(3,100),(4,200),(5,600)]
</code></pre>
<p>We can implement our own fromList by using the empty map, insert and a fold. Watch:</p>
<pre><code>fromList' :: (Ord k) =&gt; [(k,v)] -&gt; Map.Map k v  
fromList' = foldr (\(k,v) acc -&gt; Map.insert k v acc) Map.empty
</code></pre>
<p>It's a pretty straightforward fold. We start of with an empty map and we fold it up from the right, inserting the key value pairs into the accumulator as we go along.</p>
<p>null checks if a map is empty.</p>
<pre><code>Prelude&gt; Map.null Map.empty  
True  
Prelude&gt; Map.null $ Map.fromList [(2,3),(5,5)]  
False
</code></pre>
<p>size reports the size of a map.</p>
<pre><code>Prelude&gt; Map.size Map.empty  
0  
Prelude&gt; Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]  
5
</code></pre>
<p>singleton takes a key and a value and creates a map that has exactly one mapping.</p>
<pre><code>Prelude&gt; Map.singleton 3 9  
fromList [(3,9)]  
Prelude&gt; Map.insert 5 9 $ Map.singleton 3 9  
fromList [(3,9),(5,9)]
</code></pre>
<p>lookup works like the Data.List lookup, only it operates on maps. It returns Just something if it finds something for the key and Nothing if it doesn't.</p>
<p>member is a predicate takes a key and a map and reports whether the key is in the map or not.</p>
<pre><code>Prelude&gt; Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]  
True  
Prelude&gt; Map.member 3 $ Map.fromList [(2,5),(4,5)]  
False
</code></pre>
<p>map and filter work much like their list equivalents.</p>
<pre><code>Prelude&gt; Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]  
fromList [(1,100),(2,400),(3,900)]  
Prelude&gt; Map.filter isUpper $ Map.fromList [(1,'a'),(2,'A'),(3,'b'),(4,'B')]  
fromList [(2,'A'),(4,'B')]
</code></pre>
<p>toList is the inverse of fromList.</p>
<pre><code>Prelude&gt; Map.toList . Map.insert 9 2 $ Map.singleton 4 3  
[(4,3),(9,2)]
</code></pre>
<p>keys and elems return lists of keys and values respectively. keys is the equivalent of map fst . Map.toList and elems is the equivalent of map snd . Map.toList.</p>
<p>fromListWith is a cool little function. It acts like fromList, only it doesn't discard duplicate keys but it uses a function supplied to it to decide what to do with them. Let's say that a girl can have several numbers and we have an association list set up like this.</p>
<pre><code>phoneBook =   
    [("betty","555-2938")  
    ,("betty","342-2492")  
    ,("bonnie","452-2928")  
    ,("patsy","493-2928")  
    ,("patsy","943-2929")  
    ,("patsy","827-9162")  
    ,("lucille","205-2928")  
    ,("wendy","939-8282")  
    ,("penny","853-2492")  
    ,("penny","555-2111")  
    ]
</code></pre>
<p>Now if we just use fromList to put that into a map, we'll lose a few numbers! So here's what we'll do:</p>
<pre><code>phoneBookToMap :: (Ord k) =&gt; [(k, String)] -&gt; Map.Map k String  
phoneBookToMap xs = Map.fromListWith (\number1 number2 -&gt; number1 ++ ", " ++ number2) xs

Prelude&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook  
"827-9162, 943-2929, 493-2928"  
Prelude&gt; Map.lookup "wendy" $ phoneBookToMap phoneBook  
"939-8282"  
Prelude&gt; Map.lookup "betty" $ phoneBookToMap phoneBook  
"342-2492, 555-2938"
</code></pre>
<p>If a duplicate key is found, the function we pass is used to combine the values of those keys into some other value. We could also first make all the values in the association list singleton lists and then we can use ++ to combine the numbers.</p>
<pre><code>phoneBookToMap :: (Ord k) =&gt; [(k, a)] -&gt; Map.Map k [a]  
phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -&gt; (k,[v])) xs

Prelude&gt; Map.lookup "patsy" $ phoneBookToMap phoneBook  
["827-9162","943-2929","493-2928"]
</code></pre>
<p>Pretty neat! Another use case is if we're making a map from an association list of numbers and when a duplicate key is found, we want the biggest value for the key to be kept.</p>
<pre><code>Prelude&gt; Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]  
fromList [(2,100),(3,29),(4,22)]
</code></pre>
<p>Or we could choose to add together values on the same keys.</p>
<pre><code>Prelude&gt; Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]  
fromList [(2,108),(3,62),(4,37)]
</code></pre>
<p>insertWith is to insert what fromListWith is to fromList. It inserts a key-value pair into a map, but if that map already contains the key, it uses the function passed to it to determine what to do.</p>
<pre><code>Prelude&gt; Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]  
fromList [(3,104),(5,103),(6,339)]
</code></pre>
<p>These were just a few functions from Data.Map. You can see a complete list of functions in the documentation.
Data.Set
legosets</p>
<p>The Data.Set module offers us, well, sets. Like sets from mathematics. Sets are kind of like a cross between lists and maps. All the elements in a set are unique. And because they're internally implemented with trees (much like maps in Data.Map), they're ordered. Checking for membership, inserting, deleting, etc. is much faster than doing the same thing with lists. The most common operation when dealing with sets are inserting into a set, checking for membership and converting a set to a list.</p>
<p>Because the names in Data.Set clash with a lot of Prelude and Data.List names, we do a qualified import.</p>
<p>Put this import statement in a script:</p>
<pre><code>import qualified Data.Set as Set
</code></pre>
<p>And then load the script via GHCI.</p>
<p>Let's say we have two pieces of text. We want to find out which characters were used in both of them.</p>
<pre><code>text1 = "I just had an anime dream. Anime... Reality... Are they so different?"  
text2 = "The old man left his garbage can out and now his trash is all over my lawn!"
</code></pre>
<p>The fromList function works much like you would expect. It takes a list and converts it into a set.</p>
<pre><code>Prelude&gt; let set1 = Set.fromList text1  
Prelude&gt; let set2 = Set.fromList text2  
Prelude&gt; set1  
fromList " .?AIRadefhijlmnorstuy"  
Prelude&gt; set2  
fromList " !Tabcdefghilmnorstuvwy"
</code></pre>
<p>As you can see, the items are ordered and each element is unique. Now let's use the intersection function to see which elements they both share.</p>
<pre><code>Prelude&gt; Set.intersection set1 set2  
fromList " adefhilmnorstuy"
</code></pre>
<p>We can use the difference function to see which letters are in the first set but aren't in the second one and vice versa.</p>
<pre><code>Prelude&gt; Set.difference set1 set2  
fromList ".?AIRj"  
Prelude&gt; Set.difference set2 set1  
fromList "!Tbcgvw"
</code></pre>
<p>Or we can see all the unique letters used in both sentences by using union.</p>
<pre><code>Prelude&gt; Set.union set1 set2  
fromList " !.?AIRTabcdefghijlmnorstuvwy"
</code></pre>
<p>The null, size, member, empty, singleton, insert and delete functions all work like you'd expect them to.</p>
<pre><code>Prelude&gt; Set.null Set.empty  
True  
Prelude&gt; Set.null $ Set.fromList [3,4,5,5,4,3]  
False  
Prelude&gt; Set.size $ Set.fromList [3,4,5,3,4,5]  
3  
Prelude&gt; Set.singleton 9  
fromList [9]  
Prelude&gt; Set.insert 4 $ Set.fromList [9,3,8,1]  
fromList [1,3,4,8,9]  
Prelude&gt; Set.insert 8 $ Set.fromList [5..10]  
fromList [5,6,7,8,9,10]  
Prelude&gt; Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]  
fromList [3,5]
</code></pre>
<p>We can also check for subsets or proper subset. Set A is a subset of set B if B contains all the elements that A does. Set A is a proper subset of set B if B contains all the elements that A does but has more elements.</p>
<pre><code>Prelude&gt; Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  
True  
Prelude&gt; Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  
True  
Prelude&gt; Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]  
False  
Prelude&gt; Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  
False
</code></pre>
<p>We can also map over sets and filter them.</p>
<pre><code>Prelude&gt; Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]  
fromList [3,5,7]  
Prelude&gt; Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]  
fromList [3,4,5,6,7,8]
</code></pre>
<p>Sets are often used to weed a list of duplicates from a list by first making it into a set with fromList and then converting it back to a list with toList. The Data.List function nub already does that, but weeding out duplicates for large lists is much faster if you cram them into a set and then convert them back to a list than using nub. But using nub only requires the type of the list's elements to be part of the Eq typeclass, whereas if you want to cram elements into a set, the type of the list has to be in Ord.</p>
<pre><code>Prelude&gt; let setNub xs = Set.toList $ Set.fromList xs  
Prelude&gt; setNub "HEY WHATS CRACKALACKIN"  
" ACEHIKLNRSTWY"  
Prelude&gt; nub "HEY WHATS CRACKALACKIN"  
"HEY WATSCRKLIN"
</code></pre>
<p>setNub is generally faster than nub on big lists but as you can see, nub preserves the ordering of the list's elements, while setNub does not.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Making our own modules</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>We've looked at some cool modules so far, but how do we make our own module? Almost every programming language enables you to split your code up into several files and Haskell is no different. When making programs, it's good practice to take functions and types that work towards a similar purpose and put them in a module. That way, you can easily reuse those functions in other programs by just importing your module.</p>
<p>Let's see how we can make our own modules by making a little module that provides some functions for calculating the volume and area of a few geometrical objects. We'll start by creating a file called Geometry.hs.</p>
<p>We say that a module exports functions. What that means is that when I import a module, I can use the functions that it exports. It can define functions that its functions call internally, but we can only see and use the ones that it exports.</p>
<p>At the beginning of a module, we specify the module name. If we have a file called Geometry.hs, then we should name our module Geometry. Then, we specify the functions that it exports and after that, we can start writing the functions. So we'll start with this.</p>
<pre><code>module Geometry  
( sphereVolume  
, sphereArea  
, cubeVolume  
, cubeArea  
, cuboidArea  
, cuboidVolume  
) where
</code></pre>
<p>As you can see, we'll be doing areas and volumes for spheres, cubes and cuboids. Let's go ahead and define our functions then:</p>
<pre><code>module Geometry  
( sphereVolume  
, sphereArea  
, cubeVolume  
, cubeArea  
, cuboidArea  
, cuboidVolume  
) where

sphereVolume :: Float -&gt; Float  
sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)

sphereArea :: Float -&gt; Float  
sphereArea radius = 4 * pi * (radius ^ 2)

cubeVolume :: Float -&gt; Float  
cubeVolume side = cuboidVolume side side side

cubeArea :: Float -&gt; Float  
cubeArea side = cuboidArea side side side

cuboidVolume :: Float -&gt; Float -&gt; Float -&gt; Float  
cuboidVolume a b c = rectangleArea a b * c

cuboidArea :: Float -&gt; Float -&gt; Float -&gt; Float  
cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float  
rectangleArea a b = a * b
</code></pre>
<p>Pretty standard geometry right here. There are a few things to take note of though. Because a cube is only a special case of a cuboid, we defined its area and volume by treating it as a cuboid whose sides are all of the same length. We also defined a helper function called rectangleArea, which calculates a rectangle's area based on the lenghts of its sides. It's rather trivial because it's just multiplication. Notice that we used it in our functions in the module (namely cuboidArea and cuboidVolume) but we didn't export it! Because we want our module to just present functions for dealing with three dimensional objects, we used rectangleArea but we didn't export it.</p>
<p>When making a module, we usually export only those functions that act as a sort of interface to our module so that the implementation is hidden. If someone is using our Geometry module, they don't have to concern themselves with functions that we don't export. We can decide to change those functions completely or delete them in a newer version (we could delete rectangleArea and just use * instead) and no one will mind because we weren't exporting them in the first place.</p>
<p>To use our module, we just do:</p>
<pre><code>import Geometry
</code></pre>
<p>Geometry.hs has to be in the same folder that the program that's importing it is in, though.</p>
<p>Modules can also be given a hierarchical structures. Each module can have a number of sub-modules and they can have sub-modules of their own. Let's section these functions off so that Geometry is a module that has three sub-modules, one for each type of object.</p>
<p>First, we'll make a folder called Geometry. Mind the capital G. In it, we'll place three files: Sphere.hs, Cuboid.hs, and Cube.hs. Here's what the files will contain:</p>
<p>Sphere.hs</p>
<pre><code>module Geometry.Sphere  
( volume  
, area  
) where

volume :: Float -&gt; Float  
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)

area :: Float -&gt; Float  
area radius = 4 * pi * (radius ^ 2)
</code></pre>
<p>Cuboid.hs</p>
<pre><code>module Geometry.Cuboid  
( volume  
, area  
) where

volume :: Float -&gt; Float -&gt; Float -&gt; Float  
volume a b c = rectangleArea a b * c

area :: Float -&gt; Float -&gt; Float -&gt; Float  
area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2

rectangleArea :: Float -&gt; Float -&gt; Float  
rectangleArea a b = a * b
</code></pre>
<p>Cube.hs</p>
<pre><code>module Geometry.Cube  
( volume  
, area  
) where

import qualified Geometry.Cuboid as Cuboid

volume :: Float -&gt; Float  
volume side = Cuboid.volume side side side

area :: Float -&gt; Float  
area side = Cuboid.area side side side
</code></pre>
<p>Alright! So first is Geometry.Sphere. Notice how we placed it in a folder called Geometry and then defined the module name as Geometry.Sphere. We did the same for the cuboid. Also notice how in all three sub-modules, we defined functions with the same names. We can do this because they're separate modules. We want to use functions from Geometry.Cuboid in Geometry.Cube but we can't just straight up do import Geometry.Cuboid because it exports functions with the same names as Geometry.Cube. That's why we do a qualified import and all is well.</p>
<p>So now if we're in a file that's on the same level as the Geometry folder, we can do, say:</p>
<pre><code>import Geometry.Sphere
</code></pre>
<p>And then we can call area and volume and they'll give us the area and volume for a sphere. And if we want to juggle two or more of these modules, we have to do qualified imports because they export functions with the same names. So we just do something like:</p>
<pre><code>import qualified Geometry.Sphere as Sphere  
import qualified Geometry.Cuboid as Cuboid  
import qualified Geometry.Cube as Cube
</code></pre>
<p>And then we can call Sphere.area, Sphere.volume, Cuboid.area, etc. and each will calculate the area or volume for their corresponding object.</p>
<p>The next time you find yourself writing a file that's really big and has a lot of functions, try to see which functions serve some common purpose and then see if you can put them in their own module. You'll be able to just import your module the next time you're writing a program that requires some of the same functionality.</p>
<pre><code>Higher Order Functions Table of contents Making Our Own Types and Typeclasses
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Making Our Own Types and Typeclasses</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>In the previous chapters, we covered some existing Haskell types and typeclasses. In this chapter, we'll learn how to make our own and how to put them to work!
Algebraic data types intro</p>
<p>So far, we've run into a lot of data types. Bool, Int, Char, Maybe, etc. But how do we make our own? Well, one way is to use the data keyword to define a type. Let's see how the Bool type is defined in the standard library.</p>
<pre><code>data Bool = False | True
</code></pre>
<p>data means that we're defining a new data type. The part before the = denotes the type, which is Bool. The parts after the = are value constructors. They specify the different values that this type can have. The | is read as or. So we can read this as: the Bool type can have a value of True or False. Both the type name and the value constructors have to be capital cased.</p>
<p>In a similar fashion, we can think of the Int type as being defined like this:</p>
<pre><code>data Int = -2147483648 | -2147483647 | ... | -1 | 0 | 1 | 2 | ... | 2147483647
</code></pre>
<p>caveman</p>
<p>The first and last value constructors are the minimum and maximum possible values of Int. It's not actually defined like this, the ellipses are here because we omitted a heapload of numbers, so this is just for illustrative purposes.</p>
<p>Now, let's think about how we would represent a shape in Haskell. One way would be to use tuples. A circle could be denoted as (43.1, 55.0, 10.4) where the first and second fields are the coordinates of the circle's center and the third field is the radius. Sounds OK, but those could also represent a 3D vector or anything else. A better solution would be to make our own type to represent a shape. Let's say that a shape can be a circle or a rectangle. Here it is:</p>
<pre><code>data Shape = Circle Float Float Float | Rectangle Float Float Float Float
</code></pre>
<p>Now what's this? Think of it like this. The Circle value constructor has three fields, which take floats. So when we write a value constructor, we can optionally add some types after it and those types define the values it will contain. Here, the first two fields are the coordinates of its center, the third one its radius. The Rectangle value constructor has four fields which accept floats. The first two are the coordinates to its upper left corner and the second two are coordinates to its lower right one.</p>
<p>Now when I say fields, I actually mean parameters. Value constructors are actually functions that ultimately return a value of a data type. Let's take a look at the type signatures for these two value constructors.</p>
<pre><code>Prelude&gt; :t Circle  
Circle :: Float -&gt; Float -&gt; Float -&gt; Shape  
Prelude&gt; :t Rectangle  
Rectangle :: Float -&gt; Float -&gt; Float -&gt; Float -&gt; Shape
</code></pre>
<p>Cool, so value constructors are functions like everything else. Who would have thought? Let's make a function that takes a shape and returns its surface.</p>
<pre><code>surface :: Shape -&gt; Float  
surface (Circle _ _ r) = pi * r ^ 2  
surface (Rectangle x1 y1 x2 y2) = (abs $ x2 - x1) * (abs $ y2 - y1)
</code></pre>
<p>The first notable thing here is the type declaration. It says that the function takes a shape and returns a float. We couldn't write a type declaration of Circle -&gt; Float because Circle is not a type, Shape is. Just like we can't write a function with a type declaration of True -&gt; Int. The next thing we notice here is that we can pattern match against constructors. We pattern matched against constructors before (all the time actually) when we pattern matched against values like [] or False or 5, only those values didn't have any fields. We just write a constructor and then bind its fields to names. Because we're interested in the radius, we don't actually care about the first two fields, which tell us where the circle is.</p>
<pre><code>Prelude&gt; surface $ Circle 10 20 10  
314.15927  
Prelude&gt; surface $ Rectangle 0 0 100 100  
10000.0
</code></pre>
<p>Yay, it works! But if we try to just print out Circle 10 20 5 in the prompt, we'll get an error. That's because Haskell doesn't know how to display our data type as a string (yet). Remember, when we try to print a value out in the prompt, Haskell first runs the show function to get the string representation of our value and then it prints that out to the terminal. To make our Shape type part of the Show typeclass, we modify it like this:</p>
<pre><code>data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
</code></pre>
<p>We won't concern ourselves with deriving too much for now. Let's just say that if we add deriving (Show) at the end of a data declaration, Haskell automagically makes that type part of the Show typeclass. So now, we can do this:</p>
<pre><code>Prelude&gt; Circle 10 20 5  
Circle 10.0 20.0 5.0  
Prelude&gt; Rectangle 50 230 60 90  
Rectangle 50.0 230.0 60.0 90.0
</code></pre>
<p>Value constructors are functions, so we can map them and partially apply them and everything. If we want a list of concentric circles with different radii, we can do this.</p>
<pre><code>Prelude&gt; map (Circle 10 20) [4,5,6,6]  
[Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]
</code></pre>
<p>Our data type is good, although it could be better. Let's make an intermediate data type that defines a point in two-dimensional space. Then we can use that to make our shapes more understandable.</p>
<pre><code>data Point = Point Float Float deriving (Show)  
data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
</code></pre>
<p>Notice that when defining a point, we used the same name for the data type and the value constructor. This has no special meaning, although it's common to use the same name as the type if there's only one value constructor. So now the Circle has two fields, one is of type Point and the other of type Float. This makes it easier to understand what's what. Same goes for the rectangle. We have to adjust our surface function to reflect these changes.</p>
<pre><code>surface :: Shape -&gt; Float  
surface (Circle _ r) = pi * r ^ 2  
surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1)
</code></pre>
<p>The only thing we had to change were the patterns. We disregarded the whole point in the circle pattern. In the rectangle pattern, we just used a nested pattern matching to get the fields of the points. If we wanted to reference the points themselves for some reason, we could have used as-patterns.</p>
<pre><code>Prelude&gt; surface (Rectangle (Point 0 0) (Point 100 100))  
10000.0  
Prelude&gt; surface (Circle (Point 0 0) 24)  
1809.5574
</code></pre>
<p>How about a function that nudges a shape? It takes a shape, the amount to move it on the x axis and the amount to move it on the y axis and then returns a new shape that has the same dimensions, only it's located somewhere else.</p>
<pre><code>nudge :: Shape -&gt; Float -&gt; Float -&gt; Shape  
nudge (Circle (Point x y) r) a b = Circle (Point (x+a) (y+b)) r  
nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b = Rectangle (Point (x1+a) (y1+b)) (Point (x2+a) (y2+b))
</code></pre>
<p>Pretty straightforward. We add the nudge amounts to the points that denote the position of the shape.</p>
<pre><code>Prelude&gt; nudge (Circle (Point 34 34) 10) 5 10  
Circle (Point 39.0 44.0) 10.0
</code></pre>
<p>If we don't want to deal directly with points, we can make some auxilliary functions that create shapes of some size at the zero coordinates and then nudge those.</p>
<pre><code>baseCircle :: Float -&gt; Shape  
baseCircle r = Circle (Point 0 0) r

baseRect :: Float -&gt; Float -&gt; Shape  
baseRect width height = Rectangle (Point 0 0) (Point width height)

Prelude&gt; nudge (baseRect 40 100) 60 23  
Rectangle (Point 60.0 23.0) (Point 100.0 123.0)
</code></pre>
<p>You can, of course, export your data types in your modules. To do that, just write your type along with the functions you are exporting and then add some parentheses and in them specify the value constructors that you want to export for it, separated by commas. If you want to export all the value constructors for a given type, just write ...</p>
<p>If we wanted to export the functions and types that we defined here in a module, we could start it off like this:</p>
<pre><code>module Shapes   
( Point(..)  
, Shape(..)  
, surface  
, nudge  
, baseCircle  
, baseRect  
) where
</code></pre>
<p>By doing Shape(..), we exported all the value constructors for Shape, so that means that whoever imports our module can make shapes by using the Rectangle and Circle value constructors. It's the same as writing Shape (Rectangle, Circle).</p>
<p>We could also opt not to export any value constructors for Shape by just writing Shape in the export statement. That way, someone importing our module could only make shapes by using the auxilliary functions baseCircle and baseRect. Data.Map uses that approach. You can't create a map by doing Map.Map [(1,2),(3,4)] because it doesn't export that value constructor. However, you can make a mapping by using one of the auxilliary functions like Map.fromList. Remember, value constructors are just functions that take the fields as parameters and return a value of some type (like Shape) as a result. So when we choose not to export them, we just prevent the person importing our module from using those functions, but if some other functions that are exported return a type, we can use them to make values of our custom data types.</p>
<p>Not exporting the value constructors of a data types makes them more abstract in such a way that we hide their implementation. Also, whoever uses our module can't pattern match against the value constructors.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Record syntax</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>OK, we've been tasked with creating a data type that describes a person. The info that we want to store about that person is: first name, last name, age, height, phone number, and favorite ice-cream flavor. I don't know about you, but that's all I ever want to know about a person. Let's give it a go!</p>
<pre><code>data Person = Person String String Int Float String String deriving (Show)
</code></pre>
<p>O-kay. The first field is the first name, the second is the last name, the third is the age and so on. Let's make a person.</p>
<pre><code>Prelude&gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"  
Prelude&gt; guy  
Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
</code></pre>
<p>That's kind of cool, although slightly unreadable. What if we want to create a function to get seperate info from a person? A function that gets some person's first name, a function that gets some person's last name, etc. Well, we'd have to define them kind of like this.</p>
<pre><code>firstName :: Person -&gt; String  
firstName (Person firstname _ _ _ _ _) = firstname

lastName :: Person -&gt; String  
lastName (Person _ lastname _ _ _ _) = lastname

age :: Person -&gt; Int  
age (Person _ _ age _ _ _) = age

height :: Person -&gt; Float  
height (Person _ _ _ height _ _) = height

phoneNumber :: Person -&gt; String  
phoneNumber (Person _ _ _ _ number _) = number

flavor :: Person -&gt; String  
flavor (Person _ _ _ _ _ flavor) = flavor
</code></pre>
<p>Whew! I certainly did not enjoy writing that! Despite being very cumbersome and BORING to write, this method works.</p>
<pre><code>Prelude&gt; let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"  
Prelude&gt; firstName guy  
"Buddy"  
Prelude&gt; height guy  
184.2  
Prelude&gt; flavor guy  
"Chocolate"
</code></pre>
<p>There must be a better way, you say! Well no, there isn't, sorry.</p>
<p>Just kidding, there is. Hahaha! The makers of Haskell were very smart and anticipated this scenario. They included an alternative way to write data types. Here's how we could achieve the above functionality with record syntax.</p>
<pre><code>data Person = Person { firstName :: String  
                     , lastName :: String  
                     , age :: Int  
                     , height :: Float  
                     , phoneNumber :: String  
                     , flavor :: String  
                     } deriving (Show)
</code></pre>
<p>So instead of just naming the field types one after another and separating them with spaces, we use curly brackets. First we write the name of the field, for instance, firstName and then we write a double colon :: (also called Paamayim Nekudotayim, haha) and then we specify the type. The resulting data type is exactly the same. The main benefit of this is that it creates functions that lookup fields in the data type. By using record syntax to create this data type, Haskell automatically made these functions: firstName, lastName, age, height, phoneNumber and flavor.</p>
<pre><code>Prelude&gt; :t flavor  
flavor :: Person -&gt; String  
Prelude&gt; :t firstName  
firstName :: Person -&gt; String
</code></pre>
<p>There's another benefit to using record syntax. When we derive Show for the type, it displays it differently if we use record syntax to define and instantiate the type. Say we have a type that represents a car. We want to keep track of the company that made it, the model name and its year of production. Watch.</p>
<pre><code>data Car = Car String String Int deriving (Show)

Prelude&gt; Car "Ford" "Mustang" 1967  
Car "Ford" "Mustang" 1967
</code></pre>
<p>If we define it using record syntax, we can make a new car like this.</p>
<pre><code>data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)

Prelude&gt; Car {company="Ford", model="Mustang", year=1967}  
Car {company = "Ford", model = "Mustang", year = 1967}
</code></pre>
<p>When making a new car, we don't have to necessarily put the fields in the proper order, as long as we list all of them. But if we don't use record syntax, we have to specify them in order.</p>
<p>Use record syntax when a constructor has several fields and it's not obvious which field is which. If we make a 3D vector data type by doing data Vector = Vector Int Int Int, it's pretty obvious that the fields are the components of a vector. However, in our Person and Car types, it wasn't so obvious and we greatly benefited from using record syntax.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Type parameters</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>A value constructor can take some values parameters and then produce a new value. For instance, the Car constructor takes three values and produces a car value. In a similar manner, type constructors can take types as parameters to produce new types. This might sound a bit too meta at first, but it's not that complicated. If you're familiar with templates in C++, you'll see some parallels. To get a clear picture of what type parameters work like in action, let's take a look at how a type we've already met is implemented.</p>
<pre><code>data Maybe a = Nothing | Just a
</code></pre>
<p>yeti</p>
<p>The a here is the type parameter. And because there's a type parameter involved, we call Maybe a type constructor. Depending on what we want this data type to hold when it's not Nothing, this type constructor can end up producing a type of Maybe Int, Maybe Car, Maybe String, etc. No value can have a type of just Maybe, because that's not a type per se, it's a type constructor. In order for this to be a real type that a value can be part of, it has to have all its type parameters filled up.</p>
<p>So if we pass Char as the type parameter to Maybe, we get a type of Maybe Char. The value Just 'a' has a type of Maybe Char, for example.</p>
<p>You might not know it, but we used a type that has a type parameter before we used Maybe. That type is the list type. Although there's some syntactic sugar in play, the list type takes a parameter to produce a concrete type. Values can have an [Int] type, a [Char] type, a [[String]] type, but you can't have a value that just has a type of [].</p>
<p>Let's play around with the Maybe type.</p>
<pre><code>Prelude&gt; Just "Haha"  
Just "Haha"  
Prelude&gt; Just 84  
Just 84  
Prelude&gt; :t Just "Haha"  
Just "Haha" :: Maybe [Char]  
Prelude&gt; :t Just 84  
Just 84 :: (Num t) =&gt; Maybe t  
Prelude&gt; :t Nothing  
Nothing :: Maybe a  
Prelude&gt; Just 10 :: Maybe Double  
Just 10.0
</code></pre>
<p>Type parameters are useful because we can make different types with them depending on what kind of types we want contained in our data type. When we do :t Just "Haha", the type inference engine figures it out to be of the type Maybe [Char], because if the a in the Just a is a string, then the a in Maybe a must also be a string.</p>
<p>Notice that the type of Nothing is Maybe a. Its type is polymorphic. If some function requires a Maybe Int as a parameter, we can give it a Nothing, because a Nothing doesn't contain a value anyway and so it doesn't matter. The Maybe a type can act like a Maybe Int if it has to, just like 5 can act like an Int or a Double. Similarly, the type of the empty list is [a]. An empty list can act like a list of anything. That's why we can do [1,2,3] ++ [] and ["ha","ha","ha"] ++ [].</p>
<p>Using type parameters is very beneficial, but only when using them makes sense. Usually we use them when our data type would work regardless of the type of the value it then holds inside it, like with our Maybe a type. If our type acts as some kind of box, it's good to use them. We could change our Car data type from this:</p>
<pre><code>data Car = Car { company :: String  
               , model :: String  
               , year :: Int  
               } deriving (Show)
</code></pre>
<p>To this:</p>
<pre><code>data Car a b c = Car { company :: a  
                     , model :: b  
                     , year :: c   
                     } deriving (Show)
</code></pre>
<p>But would we really benefit? The answer is: probably no, because we'd just end up defining functions that only work on the Car String String Int type. For instance, given our first definition of Car, we could make a function that displays the car's properties in a nice little text.</p>
<pre><code>tellCar :: Car -&gt; String  
tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y

Prelude&gt; let stang = Car {company="Ford", model="Mustang", year=1967}  
Prelude&gt; tellCar stang  
"This Ford Mustang was made in 1967"
</code></pre>
<p>A cute little function! The type declaration is cute and it works nicely. Now what if Car was Car a b c?</p>
<pre><code>tellCar :: (Show a) =&gt; Car String String a -&gt; String  
tellCar (Car {company = c, model = m, year = y}) = "This " ++ c ++ " " ++ m ++ " was made in " ++ show y
</code></pre>
<p>We'd have to force this function to take a Car type of (Show a) =&gt; Car String String a. You can see that the type signature is more complicated and the only benefit we'd actually get would be that we can use any type that's an instance of the Show typeclass as the type for c.</p>
<pre><code>Prelude&gt; tellCar (Car "Ford" "Mustang" 1967)  
"This Ford Mustang was made in 1967"  
Prelude&gt; tellCar (Car "Ford" "Mustang" "nineteen sixty seven")  
"This Ford Mustang was made in \"nineteen sixty seven\""  
Prelude&gt; :t Car "Ford" "Mustang" 1967  
Car "Ford" "Mustang" 1967 :: (Num t) =&gt; Car [Char] [Char] t  
Prelude&gt; :t Car "Ford" "Mustang" "nineteen sixty seven"  
Car "Ford" "Mustang" "nineteen sixty seven" :: Car [Char] [Char] [Char]
</code></pre>
<p>meekrat</p>
<p>In real life though, we'd end up using Car String String Int most of the time and so it would seem that parameterizing the Car type isn't really worth it. We usually use type parameters when the type that's contained inside the data type's various value constructors isn't really that important for the type to work. A list of stuff is a list of stuff and it doesn't matter what the type of that stuff is, it can still work. If we want to sum a list of numbers, we can specify later in the summing function that we specifically want a list of numbers. Same goes for Maybe. Maybe represents an option of either having nothing or having one of something. It doesn't matter what the type of that something is.</p>
<p>Another example of a parameterized type that we've already met is Map k v from Data.Map. The k is the type of the keys in a map and the v is the type of the values. This is a good example of where type parameters are very useful. Having maps parameterized enables us to have mappings from any type to any other type, as long as the type of the key is part of the Ord typeclass. If we were defining a mapping type, we could add a typeclass constraint in the data declaration:</p>
<pre><code>data (Ord k) =&gt; Map k v = ...
</code></pre>
<p>However, it's a very strong convention in Haskell to never add typeclass constraints in data declarations. Why? Well, because we don't benefit a lot, but we end up writing more class constraints, even when we don't need them. If we put or don't put the Ord k constraint in the data declaration for Map k v, we're going to have to put the constraint into functions that assume the keys in a map can be ordered. But if we don't put the constraint in the data declaration, we don't have to put (Ord k) =&gt; in the type declarations of functions that don't care whether the keys can be ordered or not. An example of such a function is toList, that just takes a mapping and converts it to an associative list. Its type signature is toList :: Map k a -&gt; [(k, a)]. If Map k v had a type constraint in its data declaration, the type for toList would have to be toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)], even though the function doesn't do any comparing of keys by order.</p>
<p>So don't put type constraints into data declarations even if it seems to make sense, because you'll have to put them into the function type declarations either way.</p>
<p>Let's implement a 3D vector type and add some operations for it. We'll be using a parameterized type because even though it will usually contain numeric types, it will still support several of them.</p>
<pre><code>data Vector a = Vector a a a deriving (Show)

vplus :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; Vector t  
(Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n)

vectMult :: (Num t) =&gt; Vector t -&gt; t -&gt; Vector t  
(Vector i j k) `vectMult` m = Vector (i*m) (j*m) (k*m)

scalarMult :: (Num t) =&gt; Vector t -&gt; Vector t -&gt; t  
(Vector i j k) `scalarMult` (Vector l m n) = i*l + j*m + k*n
</code></pre>
<p>vplus is for adding two vectors together. Two vectors are added just by adding their corresponding components. scalarMult is for the scalar product of two vectors and vectMult is for multiplying a vector with a scalar. These functions can operate on types of Vector Int, Vector Integer, Vector Float, whatever, as long as the a from Vector a is from the Num typeclass. Also, if you examine the type declaration for these functions, you'll see that they can operate only on vectors of the same type and the numbers involved must also be of the type that is contained in the vectors. Notice that we didn't put a Num class constraint in the data declaration, because we'd have to repeat it in the functions anyway.</p>
<p>Once again, it's very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the = is the type constructor and the constructors after it (possibly separated by |'s) are value constructors. Giving a function a type of Vector t t t -&gt; Vector t t t -&gt; t would be wrong, because we have to put types in type declaration and the vector type constructor takes only one parameter, whereas the value constructor takes three. Let's play around with our vectors.</p>
<pre><code>Prelude&gt; Vector 3 5 8 `vplus` Vector 9 2 8  
Vector 12 7 16  
Prelude&gt; Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3  
Vector 12 9 19  
Prelude&gt; Vector 3 9 7 `vectMult` 10  
Vector 30 90 70  
Prelude&gt; Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0  
74.0  
Prelude&gt; Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)  
Vector 148 666 222
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Derived instances</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>In the Typeclasses 101 section, we explained the basics of typeclasses. We explained that a typeclass is a sort of an interface that defines some behavior. A type can be made an instance of a typeclass if it supports that behavior. Example: the Int type is an instance of the Eq typeclass because the Eq typeclass defines behavior for stuff that can be equated. And because integers can be equated, Int is a part of the Eq typeclass. The real usefulness comes with the functions that act as the interface for Eq, namely == and /=. If a type is a part of the Eq typeclass, we can use the == functions with values of that type. That's why expressions like 4 == 4 and "foo" /= "bar" typecheck.</p>
<p>We also mentioned that they're often confused with classes in languages like Java, Python, C++ and the like, which then baffles a lot of people. In those languages, classes are a blueprint from which we then create objects that contain state and can do some actions. Typeclasses are more like interfaces. We don't make data from typeclasses. Instead, we first make our data type and then we think about what it can act like. If it can act like something that can be equated, we make it an instance of the Eq typeclass. If it can act like something that can be ordered, we make it an instance of the Ord typeclass.</p>
<p>In the next section, we'll take a look at how we can manually make our types instances of typeclasses by implementing the functions defined by the typeclasses. But right now, let's see how Haskell can automatically make our type an instance of any of the following typeclasses: Eq, Ord, Enum, Bounded, Show, Read. Haskell can derive the behavior of our types in these contexts if we use the deriving keyword when making our data type.</p>
<p>Consider this data type:</p>
<pre><code>data Person = Person { firstName :: String  
                     , lastName :: String  
                     , age :: Int  
                     }
</code></pre>
<p>It describes a person. Let's assume that no two people have the same combination of first name, last name and age. Now, if we have records for two people, does it make sense to see if they represent the same person? Sure it does. We can try to equate them and see if they're equal or not. That's why it would make sense for this type to be part of the Eq typeclass. We'll derive the instance.</p>
<pre><code>data Person = Person { firstName :: String  
                     , lastName :: String  
                     , age :: Int  
                     } deriving (Eq)
</code></pre>
<p>When we derive the Eq instance for a type and then try to compare two values of that type with == or /=, Haskell will see if the value constructors match (there's only one value constructor here though) and then it will check if all the data contained inside matches by testing each pair of fields with ==. There's only one catch though, the types of all the fields also have to be part of the Eq typeclass. But since both String and Int are, we're OK. Let's test our Eq instance.</p>
<pre><code>Prelude&gt; let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}  
Prelude&gt; let adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}  
Prelude&gt; let mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}  
Prelude&gt; mca == adRock  
False  
Prelude&gt; mikeD == adRock  
False  
Prelude&gt; mikeD == mikeD  
True  
Prelude&gt; mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}  
True
</code></pre>
<p>Of course, since Person is now in Eq, we can use it as the a for all functions that have a class constraint of Eq a in their type signature, such as elem.</p>
<pre><code>Prelude&gt; let beastieBoys = [mca, adRock, mikeD]  
Prelude&gt; mikeD `elem` beastieBoys  
True
</code></pre>
<p>The Show and Read typeclasses are for things that can be converted to or from strings, respectively. Like with Eq, if a type's constructors have fields, their type has to be a part of Show or Read if we want to make our type an instance of them. Let's make our Person data type a part of Show and Read as well.</p>
<pre><code>data Person = Person { firstName :: String  
                     , lastName :: String  
                     , age :: Int  
                     } deriving (Eq, Show, Read)
</code></pre>
<p>Now we can print a person out to the terminal.</p>
<pre><code>Prelude&gt; let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}  
Prelude&gt; mikeD  
Person {firstName = "Michael", lastName = "Diamond", age = 43}  
Prelude&gt; "mikeD is: " ++ show mikeD  
"mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"
</code></pre>
<p>Had we tried to print a person on the terminal before making the Person data type part of Show, Haskell would have complained at us, claiming it doesn't know how to represent a person as a string. But now that we've derived a Show instance for it, it does know.</p>
<p>Read is pretty much the inverse typeclass of Show. Show is for converting values of our a type to a string, Read is for converting strings to values of our type. Remember though, when we use the read function, we have to use an explicit type annotation to tell Haskell which type we want to get as a result. If we don't make the type we want as a result explicit, Haskell doesn't know which type we want.</p>
<pre><code>Prelude&gt; read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person  
Person {firstName = "Michael", lastName = "Diamond", age = 43}
</code></pre>
<p>If we use the result of our read later on in a way that Haskell can infer that it should read it as a person, we don't have to use type annotation.</p>
<pre><code>Prelude&gt; read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" == mikeD  
True
</code></pre>
<p>We can also read parameterized types, but we have to fill in the type parameters. So we can't do read "Just 't'" :: Maybe a, but we can do read "Just 't'" :: Maybe Char.</p>
<p>We can derive instances for the Ord type class, which is for types that have values that can be ordered. If we compare two values of the same type that were made using different constructors, the value which was made with a constructor that's defined first is considered smaller. For instance, consider the Bool type, which can have a value of either False or True. For the purpose of seeing how it behaves when compared, we can think of it as being implemented like this:</p>
<pre><code>data Bool = False | True deriving (Ord)
</code></pre>
<p>Because the False value constructor is specified first and the True value constructor is specified after it, we can consider True as greater than False.</p>
<pre><code>Prelude&gt; True `compare` False  
GT  
Prelude&gt; True &gt; False  
True  
Prelude&gt; True &lt; False  
False
</code></pre>
<p>In the Maybe a data type, the Nothing value constructor is specified before the Just value constructor, so a value of Nothing is always smaller than a value of Just something, even if that something is minus one billion trillion. But if we compare two Just values, then it goes to compare what's inside them.</p>
<pre><code>Prelude&gt; Nothing &lt; Just 100  
True  
Prelude&gt; Nothing &gt; Just (-49999)  
False  
Prelude&gt; Just 3 `compare` Just 2  
GT  
Prelude&gt; Just 100 &gt; Just 50  
True
</code></pre>
<p>But we can't do something like Just (<em>3) &gt; Just (</em>2), because (<em>3) and (</em>2) are functions, which aren't instances of Ord.</p>
<p>We can easily use algebraic data types to make enumerations and the Enum and Bounded typeclasses help us with that. Consider the following data type:</p>
<pre><code>data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
</code></pre>
<p>Because all the value constructors are nullary (take no parameters, i.e. fields), we can make it part of the Enum typeclass. The Enum typeclass is for things that have predecessors and successors. We can also make it part of the Bounded typeclass, which is for things that have a lowest possible value and highest possible value. And while we're at it, let's also make it an instance of all the other derivable typeclasses and see what we can do with it.</p>
<pre><code>data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday   
           deriving (Eq, Ord, Show, Read, Bounded, Enum)
</code></pre>
<p>Because it's part of the Show and Read typeclasses, we can convert values of this type to and from strings.</p>
<pre><code>Prelude&gt; Wednesday  
Wednesday  
Prelude&gt; show Wednesday  
"Wednesday"  
Prelude&gt; read "Saturday" :: Day  
Saturday
</code></pre>
<p>Because it's part of the Eq and Ord typeclasses, we can compare or equate days.</p>
<pre><code>Prelude&gt; Saturday == Sunday  
False  
Prelude&gt; Saturday == Saturday  
True  
Prelude&gt; Saturday &gt; Friday  
True  
Prelude&gt; Monday `compare` Wednesday  
LT
</code></pre>
<p>It's also part of Bounded, so we can get the lowest and highest day.</p>
<pre><code>Prelude&gt; minBound :: Day  
Monday  
Prelude&gt; maxBound :: Day  
Sunday
</code></pre>
<p>It's also an instance of Enum. We can get predecessors and successors of days and we can make list ranges from them!</p>
<pre><code>Prelude&gt; succ Monday  
Tuesday  
Prelude&gt; pred Saturday  
Friday  
Prelude&gt; [Thursday .. Sunday]  
[Thursday,Friday,Saturday,Sunday]  
Prelude&gt; [minBound .. maxBound] :: [Day]  
[Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]
</code></pre>
<p>That's pretty awesome.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Type synonyms</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Previously, we mentioned that when writing types, the [Char] and String types are equivalent and interchangeable. That's implemented with type synonyms. Type synonyms don't really do anything per se, they're just about giving some types different names so that they make more sense to someone reading our code and documentation. Here's how the standard library defines String as a synonym for [Char].</p>
<pre><code>type String = [Char]
</code></pre>
<p>chicken</p>
<p>We've introduced the type keyword. The keyword might be misleading to some, because we're not actually making anything new (we did that with the data keyword), but we're just making a synonym for an already existing type.</p>
<p>If we make a function that converts a string to uppercase and call it toUpperString or something, we can give it a type declaration of toUpperString :: [Char] -&gt; [Char] or toUpperString :: String -&gt; String. Both of these are essentially the same, only the latter is nicer to read.</p>
<p>When we were dealing with the Data.Map module, we first represented a phonebook with an association list before converting it into a map. As we've already found out, an association list is a list of key-value pairs. Let's look at a phonebook that we had.</p>
<pre><code>phoneBook :: [(String,String)]  
phoneBook =      
    [("betty","555-2938")     
    ,("bonnie","452-2928")     
    ,("patsy","493-2928")     
    ,("lucille","205-2928")     
    ,("wendy","939-8282")     
    ,("penny","853-2492")     
    ]
</code></pre>
<p>We see that the type of phoneBook is [(String,String)]. That tells us that it's an association list that maps from strings to strings, but not much else. Let's make a type synonym to convey some more information in the type declaration.</p>
<pre><code>type PhoneBook = [(String,String)]
</code></pre>
<p>Now the type declaration for our phonebook can be phoneBook :: PhoneBook. Let's make a type synonym for String as well.</p>
<pre><code>type PhoneNumber = String  
type Name = String  
type PhoneBook = [(Name,PhoneNumber)]
</code></pre>
<p>Giving the String type synonyms is something that Haskell programmers do when they want to convey more information about what strings in their functions should be used as and what they represent.</p>
<p>So now, when we implement a function that takes a name and a number and sees if that name and number combination is in our phonebook, we can give it a very pretty and descriptive type declaration.</p>
<pre><code>inPhoneBook :: Name -&gt; PhoneNumber -&gt; PhoneBook -&gt; Bool  
inPhoneBook name pnumber pbook = (name,pnumber) `elem` pbook
</code></pre>
<p>If we decided not to use type synonyms, our function would have a type of String -&gt; String -&gt; [(String,String)] -&gt; Bool. In this case, the type declaration that took advantage of type synonyms is easier to understand. However, you shouldn't go overboard with them. We introduce type synonyms either to describe what some existing type represents in our functions (and thus our type declarations become better documentation) or when something has a long-ish type that's repeated a lot (like [(String,String)]) but represents something more specific in the context of our functions.</p>
<p>Type synonyms can also be parameterized. If we want a type that represents an association list type but still want it to be general so it can use any type as the keys and values, we can do this:</p>
<pre><code>type AssocList k v = [(k,v)]
</code></pre>
<p>Now, a function that gets the value by a key in an association list can have a type of (Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v. AssocList is a type constructor that takes two types and produces a concrete type, like AssocList Int String, for instance.
Fonzie says: Aaay! When I talk about concrete types I mean like fully applied types like Map Int String or if we're dealin' with one of them polymorphic functions, [a] or (Ord a) =&gt; Maybe a and stuff. And like, sometimes me and the boys say that Maybe is a type, but we don't mean that, cause every idiot knows Maybe is a type constructor. When I apply an extra type to Maybe, like Maybe String, then I have a concrete type. You know, values can only have types that are concrete types! So in conclusion, live fast, love hard and don't let anybody else use your comb!</p>
<p>Just like we can partially apply functions to get new functions, we can partially apply type parameters and get new type constructors from them. Just like we call a function with too few parameters to get back a new function, we can specify a type constructor with too few type parameters and get back a partially applied type constructor. If we wanted a type that represents a map (from Data.Map) from integers to something, we could either do this:</p>
<pre><code>type IntMap v = Map Int v
</code></pre>
<p>Or we could do it like this:</p>
<pre><code>type IntMap = Map Int
</code></pre>
<p>Either way, the IntMap type constructor takes one parameter and that is the type of what the integers will point to.
Oh yeah. If you're going to try and implement this, you'll probably going to do a qualified import of Data.Map. When you do a qualified import, type constructors also have to be preceeded with a module name. So you'd write type IntMap = Map.Map Int.</p>
<p>Make sure that you really understand the distinction between type constructors and value constructors. Just because we made a type synonym called IntMap or AssocList doesn't mean that we can do stuff like AssocList [(1,2),(4,5),(7,9)]. All it means is that we can refer to its type by using different names. We can do [(1,2),(3,5),(8,9)] :: AssocList Int Int, which will make the numbers inside assume a type of Int, but we can still use that list as we would any normal list that has pairs of integers inside. Type synonyms (and types generally) can only be used in the type portion of Haskell. We're in Haskell's type portion whenever we're defining new types (so in data and type declarations) or when we're located after a ::. The :: is in type declarations or in type annotations.</p>
<p>Another cool data type that takes two types as its parameters is the Either a b type. This is roughly how it's defined:</p>
<pre><code>data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
</code></pre>
<p>It has two value constructors. If the Left is used, then its contents are of type a and if Right is used, then its contents are of type b. So we can use this type to encapsulate a value of one type or another and then when we get a value of type Either a b, we usually pattern match on both Left and Right and we different stuff based on which one of them it was.</p>
<pre><code>Prelude&gt; Right 20  
Right 20  
Prelude&gt; Left "w00t"  
Left "w00t"  
Prelude&gt; :t Right 'a'  
Right 'a' :: Either a Char  
Prelude&gt; :t Left True  
Left True :: Either Bool b
</code></pre>
<p>So far, we've seen that Maybe a was mostly used to represent the results of computations that could have either failed or not. But somtimes, Maybe a isn't good enough because Nothing doesn't really convey much information other than that something has failed. That's cool for functions that can fail in only one way or if we're just not interested in how and why they failed. A Data.Map lookup fails only if the key we were looking for wasn't in the map, so we know exactly what happened. However, when we're interested in how some function failed or why, we usually use the result type of Either a b, where a is some sort of type that can tell us something about the possible failure and b is the type of a successful computation. Hence, errors use the Left value constructor while results use Right.</p>
<p>An example: a high-school has lockers so that students have some place to put their Guns'n'Roses posters. Each locker has a code combination. When a student wants a new locker, they tell the locker supervisor which locker number they want and he gives them the code. However, if someone is already using that locker, he can't tell them the code for the locker and they have to pick a different one. We'll use a map from Data.Map to represent the lockers. It'll map from locker numbers to a pair of whether the locker is in use or not and the locker code.</p>
<pre><code>import qualified Data.Map as Map

data LockerState = Taken | Free deriving (Show, Eq)

type Code = String

type LockerMap = Map.Map Int (LockerState, Code)
</code></pre>
<p>Simple stuff. We introduce a new data type to represent whether a locker is taken or free and we make a type synonym for the locker code. We also make a type synonym for the type that maps from integers to pairs of locker state and code. And now, we're going to make a function that searches for the code in a locker map. We're going to use an Either String Code type to represent our result, because our lookup can fail in two ways — the locker can be taken, in which case we can't tell the code or the locker number might not exist at all. If the lookup fails, we're just going to use a String to tell what's happened.</p>
<pre><code>lockerLookup :: Int -&gt; LockerMap -&gt; Either String Code  
lockerLookup lockerNumber map =   
    case Map.lookup lockerNumber map of   
        Nothing -&gt; Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"  
        Just (state, code) -&gt; if state /= Taken   
                                then Right code  
                                else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"
</code></pre>
<p>We do a normal lookup in the map. If we get a Nothing, we return a value of type Left String, saying that the locker doesn't exist at all. If we do find it, then we do an additional check to see if the locker is taken. If it is, return a Left saying that it's already taken. If it isn't, then return a value of type Right Code, in which we give the student the correct code for the locker. It's actually a Right String, but we introduced that type synonym to introduce some additional documentation into the type declaration. Here's an example map:</p>
<pre><code>lockers :: LockerMap  
lockers = Map.fromList   
    [(100,(Taken,"ZD39I"))  
    ,(101,(Free,"JAH3I"))  
    ,(103,(Free,"IQSA9"))  
    ,(105,(Free,"QOTSA"))  
    ,(109,(Taken,"893JJ"))  
    ,(110,(Taken,"99292"))  
    ]
</code></pre>
<p>Now let's try looking up some locker codes.</p>
<pre><code>Prelude&gt; lockerLookup 101 lockers  
Right "JAH3I"  
Prelude&gt; lockerLookup 100 lockers  
Left "Locker 100 is already taken!"  
Prelude&gt; lockerLookup 102 lockers  
Left "Locker number 102 doesn't exist!"  
Prelude&gt; lockerLookup 110 lockers  
Left "Locker 110 is already taken!"  
Prelude&gt; lockerLookup 105 lockers  
Right "QOTSA"
</code></pre>
<p>We could have used a Maybe a to represent the result but then we wouldn't know why we couldn't get the code. But now, we have information about the failure in our result type.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Recursive data structures</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>As we've seen, a constructor in an algebraic data type can have several (or none at all) fields and each field must be of some concrete type. With that in mind, we can make types whose constructors have fields that are of the same type! Using that, we can create recursive data types, where one value of some type contains values of that type, which in turn contain more values of the same type and so on.</p>
<p>Think about this list: [5]. That's just syntactic sugar for 5:[]. On the left side of the :, there's a value and on the right side, there's a list. And in this case, it's an empty list. Now how about the list [4,5]? Well, that desugars to 4:(5:[]). Looking at the first :, we see that it also has an element on its left side and a list (5:[]) on its right side. Same goes for a list like 3:(4:(5:6:[])), which could be written either like that or like 3:4:5:6:[] (because : is right-associative) or [3,4,5,6].</p>
<p>We could say that a list can be an empty list or it can be an element joined together with a : with another list (that can be either the empty list or not).</p>
<p>Let's use algebraic data types to implement our own list then!</p>
<pre><code>data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
</code></pre>
<p>This reads just like our definition of lists from one of the previous paragraphs. It's either an empty list or a combination of a head with some value and a list. If you're confused about this, you might find it easier to understand in record syntax.</p>
<pre><code>data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)
</code></pre>
<p>You might also be confused about the Cons constructor here. cons is another word for :. You see, in lists, : is actually a constructor that takes a value and another list and returns a list. We can already use our new list type! In other words, it has two fields. One field is of the type of a and the other is of the type [a].</p>
<pre><code>Prelude&gt; Empty  
Empty  
Prelude&gt; 5 `Cons` Empty  
Cons 5 Empty  
Prelude&gt; 4 `Cons` (5 `Cons` Empty)  
Cons 4 (Cons 5 Empty)  
Prelude&gt; 3 `Cons` (4 `Cons` (5 `Cons` Empty))  
Cons 3 (Cons 4 (Cons 5 Empty))
</code></pre>
<p>We called our Cons constructor in an infix manner so you can see how it's just like :. Empty is like [] and 4 <code>Cons</code> (5 <code>Cons</code> Empty) is like 4:(5:[]).</p>
<p>We can define functions to be automatically infix by making them comprised of only special characters. We can also do the same with constructors, since they're just functions that return a data type. So check this out.</p>
<pre><code>infixr 5 :-:  
data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
</code></pre>
<p>First off, we notice a new syntactic construct, the fixity declarations. When we define functions as operators, we can use that to give them a fixity (but we don't have to). A fixity states how tightly the operator binds and whether it's left-associative or right-associative. For instance, *'s fixity is infixl 7 * and +'s fixity is infixl 6. That means that they're both left-associative (4 * 3 * 2 is (4 * 3) * 2) but * binds tighter than +, because it has a greater fixity, so 5 * 4 + 3 is (5 * 4) + 3.</p>
<p>Otherwise, we just wrote a :-: (List a) instead of Cons a (List a). Now, we can write out lists in our list type like so:</p>
<pre><code>Prelude&gt; 3 :-: 4 :-: 5 :-: Empty  
(:-:) 3 ((:-:) 4 ((:-:) 5 Empty))  
Prelude&gt; let a = 3 :-: 4 :-: 5 :-: Empty  
Prelude&gt; 100 :-: a  
(:-:) 100 ((:-:) 3 ((:-:) 4 ((:-:) 5 Empty)))
</code></pre>
<p>When deriving Show for our type, Haskell will still display it as if the constructor was a prefix function, hence the parentheses around the operator (remember, 4 + 3 is (+) 4 3).</p>
<p>Let's make a function that adds two of our lists together. This is how ++ is defined for normal lists:</p>
<pre><code>infixr 5  ++ 
(++) :: [a] -&gt; [a] -&gt; [a]  
[]     ++ ys = ys  
(x:xs) ++ ys = x : (xs ++ ys)
</code></pre>
<p>So we'll just steal that for our own list. We'll name the function .++.</p>
<pre><code>infixr 5  .++  
(.++) :: List a -&gt; List a -&gt; List a   
Empty .++ ys = ys  
(x :-: xs) .++ ys = x :-: (xs .++ ys)
</code></pre>
<p>And let's see if it works ...</p>
<pre><code>Prelude&gt; let a = 3 :-: 4 :-: 5 :-: Empty  
Prelude&gt; let b = 6 :-: 7 :-: Empty  
Prelude&gt; a .++ b  
(:-:) 3 ((:-:) 4 ((:-:) 5 ((:-:) 6 ((:-:) 7 Empty))))
</code></pre>
<p>Nice. Is nice. If we wanted, we could implement all of the functions that operate on lists on our own list type.</p>
<p>Notice how we pattern matched on (x :-: xs). That works because pattern matching is actually about matching constructors. We can match on :-: because it is a constructor for our own list type and we can also match on : because it is a constructor for the built-in list type. Same goes for []. Because pattern matching works (only) on constructors, we can match for stuff like that, normal prefix constructors or stuff like 8 or 'a', which are basically constructors for the numeric and character types, respectively.
binary search tree</p>
<p>Now, we're going to implement a binary search tree. If you're not familiar with binary search trees from languages like C, here's what they are: an element points to two elements, one on its left and one on its right. The element to the left is smaller, the element to the right is bigger. Each of those elements can also point to two elements (or one, or none). In effect, each element has up to two sub-trees. And a cool thing about binary search trees is that we know that all the elements at the left sub-tree of, say, 5 are going to be smaller than 5. Elements in its right sub-tree are going to be bigger. So if we need to find if 8 is in our tree, we'd start at 5 and then because 8 is greater than 5, we'd go right. We're now at 7 and because 8 is greater than 7, we go right again. And we've found our element in three hops! Now if this were a normal list (or a tree, but really unbalanced), it would take us seven hops instead of three to see if 8 is in there.</p>
<p>Sets and maps from Data.Set and Data.Map are implemented using trees, only instead of normal binary search trees, they use balanced binary search trees, which are always balanced. But right now, we'll just be implementing normal binary search trees.</p>
<p>Here's what we're going to say: a tree is either an empty tree or it's an element that contains some value and two trees. Sounds like a perfect fit for an algebraic data type!</p>
<pre><code>data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
</code></pre>
<p>Okay, good, this is good. Instead of manually building a tree, we're going to make a function that takes a tree and an element and inserts an element. We do this by comparing the value we want to insert to the root node and then if it's smaller, we go left, if it's larger, we go right. We do the same for every subsequent node until we reach an empty tree. Once we've reached an empty tree, we just insert a node with that value instead of the empty tree.</p>
<p>In languages like C, we'd do this by modifying the pointers and values inside the tree. In Haskell, we can't really modify our tree, so we have to make a new sub-tree each time we decide to go left or right and in the end the insertion function returns a completely new tree, because Haskell doesn't really have a concept of pointer, just values. Hence, the type for our insertion function is going to be something like a -&gt; Tree a - &gt; Tree a. It takes an element and a tree and returns a new tree that has that element inside. This might seem like it's inefficient but laziness takes care of that problem.</p>
<p>So, here are two functions. One is a utility function for making a singleton tree (a tree with just one node) and a function to insert an element into a tree.</p>
<pre><code>singleton :: a -&gt; Tree a  
singleton x = Node x EmptyTree EmptyTree

treeInsert :: (Ord a) =&gt; a -&gt; Tree a -&gt; Tree a  
treeInsert x EmptyTree = singleton x  
treeInsert x (Node a left right)   
    | x == a = Node x left right  
    | x &lt; a  = Node a (treeInsert x left) right  
    | x &gt; a  = Node a left (treeInsert x right)
</code></pre>
<p>The singleton function is just a shortcut for making a node that has something and then two empty sub-trees. In the insertion function, we first have the edge condition as a pattern. If we've reached an empty sub-tree, that means we're where we want and instead of the empty tree, we put a singleton tree with our element. If we're not inserting into an empty tree, then we have to check some things. First off, if the element we're inserting is equal to the root element, just return a tree that's the same. If it's smaller, return a tree that has the same root value, the same right sub-tree but instead of its left sub-tree, put a tree that has our value inserted into it. Same (but the other way around) goes if our value is bigger than the root element.</p>
<p>Next up, we're going to make a function that checks if some element is in the tree. First, let's define the edge condition. If we're looking for an element in an empty tree, then it's certainly not there. Okay. Notice how this is the same as the edge condition when searching for elements in lists. If we're looking for an element in an empty list, it's not there. Anyway, if we're not looking for an element in an empty tree, then we check some things. If the element in the root node is what we're looking for, great! If it's not, what then? Well, we can take advantage of knowing that all the left elements are smaller than the root node. So if the element we're looking for is smaller than the root node, check to see if it's in the left sub-tree. If it's bigger, check to see if it's in the right sub-tree.</p>
<pre><code>treeElem :: (Ord a) =&gt; a -&gt; Tree a -&gt; Bool  
treeElem x EmptyTree = False  
treeElem x (Node a left right)  
    | x == a = True  
    | x &lt; a  = treeElem x left  
    | x &gt; a  = treeElem x right
</code></pre>
<p>All we had to do was write up the previous paragraph in code. Let's have some fun with our trees! Instead of manually building one (although we could), we'll use a fold to build up a tree from a list. Remember, pretty much everything that traverses a list one by one and then returns some sort of value can be implemented with a fold! We're going to start with the empty tree and then approach a list from the right and just insert element after element into our accumulator tree.</p>
<pre><code>Prelude&gt; let nums = [8,6,4,1,7,3,5]  
Prelude&gt; let numsTree = foldr treeInsert EmptyTree nums  
Prelude&gt; numsTree  
Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))
</code></pre>
<p>In that foldr, treeInsert was the folding function (it takes a tree and a list element and produces a new tree) and EmptyTree was the starting accumulator. nums, of course, was the list we were folding over.</p>
<p>When we print our tree to the console, it's not very readable, but if we try, we can make out its structure. We see that the root node is 5 and then it has two sub-trees, one of which has the root node of 3 and the other a 7, etc.</p>
<pre><code>Prelude&gt; 8 `treeElem` numsTree  
True  
Prelude&gt; 100 `treeElem` numsTree  
False  
Prelude&gt; 1 `treeElem` numsTree  
True  
Prelude&gt; 10 `treeElem` numsTree  
False
</code></pre>
<p>Checking for membership also works nicely. Cool.</p>
<p>So as you can see, algebraic data structures are a really cool and powerful concept in Haskell. We can use them to make anything from boolean values and weekday enumerations to binary search trees and more!
Typeclasses 102
tweet</p>
<p>So far, we've learned about some of the standard Haskell typeclasses and we've seen which types are in them. We've also learned how to automatically make our own types instances of the standard typeclasses by asking Haskell to derive the instances for us. In this section, we're going to learn how to make our own typeclasses and how to make types instances of them by hand.</p>
<p>A quick recap on typeclasses: typeclasses are like interfaces. A typeclass defines some behavior (like comparing for equality, comparing for ordering, enumeration) and then types that can behave in that way are made instances of that typeclass. The behavior of typeclasses is achieved by defining functions or just type declarations that we then implement. So when we say that a type is an instance of a typeclass, we mean that we can use the functions that the typeclass defines with that type.</p>
<p>Typeclasses have pretty much nothing to do with classes in languages like Java or Python. This confuses many people, so I want you to forget everything you know about classes in imperative languages right now.</p>
<p>For example, the Eq typeclass is for stuff that can be equated. It defines the functions == and /=. If we have a type (say, Car) and comparing two cars with the equality function == makes sense, then it makes sense for Car to be an instance of Eq.</p>
<p>This is how the Eq class is defined in the standard prelude:</p>
<pre><code>class Eq a where  
    (==) :: a -&gt; a -&gt; Bool  
    (/=) :: a -&gt; a -&gt; Bool  
    x == y = not (x /= y)  
    x /= y = not (x == y)
</code></pre>
<p>Woah, woah, woah! Some new strange syntax and keywords there! Don't worry, this will all be clear in a second. First off, when we write class Eq a where, this means that we're defining a new typeclass and that's called Eq. The a is the type variable and it means that a will play the role of the type that we will soon be making an instance of Eq. It doesn't have to be called a, it doesn't even have to be one letter, it just has to be a lowercase word. Then, we define several functions. It's not mandatory to implement the function bodies themselves, we just have to specify the type declarations for the functions.
Some people might understand this better if we wrote class Eq equatable where and then specified the type declarations like (==) :: equatable -&gt; equatable -&gt; Bool.</p>
<p>Anyway, we did implement the function bodies for the functions that Eq defines, only we defined them in terms of mutual recursion. We said that two instances of Eq are equal if they are not different and they are different if they are not equal. We didn't have to do this, really, but we did and we'll see how this helps us soon.
If we have say class Eq a where and then define a type declaration within that class like (==) :: a -&gt; -a -&gt; Bool, then when we examine the type of that function later on, it will have the type of (Eq a) =&gt; a -&gt; a -&gt; Bool.</p>
<p>So once we have a class, what can we do with it? Well, not much, really. But once we start making types instances of that class, we start getting some nice functionality. So check out this type:</p>
<pre><code>data TrafficLight = Red | Yellow | Green
</code></pre>
<p>It defines the states of a traffic light. Notice how we didn't derive any class instances for it. That's because we're going to write up some instances by hand, even though we could derive them for types like Eq and Show. Here's how we make it an instance of Eq.</p>
<pre><code>instance Eq TrafficLight where  
    Red == Red = True  
    Green == Green = True  
    Yellow == Yellow = True  
    _ == _ = False
</code></pre>
<p>We did it by using the instance keyword. So class is for defining new typeclasses and instance is for making our types instances of typeclasses. When we were defining Eq, we wrote class Eq a where and we said that a plays the role of whichever type will be made an instance later on. We can see that clearly here, because when we're making an instance, we write instance Eq TrafficLight where. We replace the a with the actual type.</p>
<p>Because == was defined in terms of /= and vice versa in the class declaration, we only had to overwrite one of them in the instance declaration. That's called the minimal complete definition for the typeclass — the minimum of functions that we have to implement so that our type can behave like the class advertises. To fulfill the minimal complete definition for Eq, we have to overwrite either one of == or /=. If Eq was defined simply like this:</p>
<pre><code>class Eq a where  
    (==) :: a -&gt; a -&gt; Bool  
    (/=) :: a -&gt; a -&gt; Bool
</code></pre>
<p>we'd have to implement both of these functions when making a type an instance of it, because Haskell wouldn't know how these two functions are related. The minimal complete definition would then be: both == and /=.</p>
<p>You can see that we implemented == simply by doing pattern matching. Since there are many more cases where two lights aren't equal, we specified the ones that are equal and then just did a catch-all pattern saying that if it's none of the previous combinations, then two lights aren't equal.</p>
<p>Let's make this an instance of Show by hand, too. To satisfy the minimal complete definition for Show, we just have to implement its show function, which takes a value and turns it into a string.</p>
<pre><code>instance Show TrafficLight where  
    show Red = "Red light"  
    show Yellow = "Yellow light"  
    show Green = "Green light"
</code></pre>
<p>Once again, we used pattern matching to achieve our goals. Let's see how it works in action:</p>
<pre><code>Prelude&gt; Red == Red  
True  
Prelude&gt; Red == Yellow  
False  
Prelude&gt; Red `elem` [Red, Yellow, Green]  
True  
Prelude&gt; [Red, Yellow, Green]  
[Red light,Yellow light,Green light]
</code></pre>
<p>Nice. We could have just derived Eq and it would have had the same effect (but we didn't for educational purposes). However, deriving Show would have just directly translated the value constructors to strings. But if we want lights to appear like "Red light", then we have to make the instance declaration by hand.</p>
<p>You can also make typeclasses that are subclasses of other typeclasses. The class declaration for Num is a bit long, but here's the first part:</p>
<pre><code>class (Eq a) =&gt; Num a where  
   ...
</code></pre>
<p>As we mentioned previously, there are a lot of places where we can cram in class constraints. So this is just like writing class Num a where, only we state that our type a must be an instance of Eq. We're essentially saying that we have to make a type an instance of Eq before we can make it an instance of Num. Before some type can be considered a number, it makes sense that we can determine whether values of that type can be equated or not. That's all there is to subclassing really, it's just a class constraint on a class declaration! When defining function bodies in the class declaration or when defining them in instance declarations, we can assume that a is a part of Eq and so we can use == on values of that type.</p>
<p>But how are the Maybe or list types made as instances of typeclasses? What makes Maybe different from, say, TrafficLight is that Maybe in itself isn't a concrete type, it's a type constructor that takes one type parameter (like Char or something) to produce a concrete type (like Maybe Char). Let's take a look at the Eq typeclass again:</p>
<pre><code>class Eq a where  
    (==) :: a -&gt; a -&gt; Bool  
    (/=) :: a -&gt; a -&gt; Bool  
    x == y = not (x /= y)  
    x /= y = not (x == y)
</code></pre>
<p>From the type declarations, we see that the a is used as a concrete type because all the types in functions have to be concrete (remember, you can't have a function of the type a -&gt; Maybe but you can have a function of a -&gt; Maybe a or Maybe Int -&gt; Maybe String). That's why we can't do something like</p>
<pre><code>instance Eq Maybe where  
    ...
</code></pre>
<p>Because like we've seen, the a has to be a concrete type but Maybe isn't a concrete type. It's a type constructor that takes one parameter and then produces a concrete type. It would also be tedious to write instance Eq (Maybe Int) where, instance Eq (Maybe Char) where, etc. for every type ever. So we could write it out like so:</p>
<pre><code>instance Eq (Maybe m) where  
    Just x == Just y = x == y  
    Nothing == Nothing = True  
    _ == _ = False
</code></pre>
<p>This is like saying that we want to make all types of the form Maybe something an instance of Eq. We actually could have written (Maybe something), but we usually opt for single letters to be true to the Haskell style. The (Maybe m) here plays the role of the a from class Eq a where. While Maybe isn't a concrete type, Maybe m is. By specifying a type parameter (m, which is in lowercase), we said that we want all types that are in the form of Maybe m, where m is any type, to be an instance of Eq.</p>
<p>There's one problem with this though. Can you spot it? We use == on the contents of the Maybe but we have no assurance that what the Maybe contains can be used with Eq! That's why we have to modify our instance declaration like this:</p>
<pre><code>instance (Eq m) =&gt; Eq (Maybe m) where  
    Just x == Just y = x == y  
    Nothing == Nothing = True  
    _ == _ = False
</code></pre>
<p>We had to add a class constraint! With this instance declaration, we say this: we want all types of the form Maybe m to be part of the Eq typeclass, but only those types where the m (so what's contained inside the Maybe) is also a part of Eq. This is actually how Haskell would derive the instance too.</p>
<p>Most of the times, class constraints in class declarations are used for making a typeclass a subclass of another typeclass and class constraints in instance declarations are used to express requirements about the contents of some type. For instance, here we required the contents of the Maybe to also be part of the Eq typeclass.</p>
<p>When making instances, if you see that a type is used as a concrete type in the type declarations (like the a in a -&gt; a -&gt; Bool), you have to supply type parameters and add parentheses so that you end up with a concrete type.
Take into account that the type you're trying to make an instance of will replace the parameter in the class declaration. The a from class Eq a where will be replaced with a real type when you make an instance, so try mentally putting your type into the function type declarations as well. (==) :: Maybe -&gt; Maybe -&gt; Bool doesn't make much sense but (==) :: (Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool does. But this is just something to think about, because == will always have a type of (==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool, no matter what instances we make.</p>
<p>Ooh, one more thing, check this out! If you want to see what the instances of a typeclass are, just do :info YourTypeClass in GHCI. So typing :info Num will show which functions the typeclass defines and it will give you a list of the types in the typeclass. :info works for types and type constructors too. If you do :info Maybe, it will show you all the typeclasses that Maybe is an instance of. Also :info can show you the type declaration of a function. I think that's pretty cool.
A yes-no typeclass
yesno</p>
<p>In JavaScript and some other weakly typed languages, you can put almost anything inside an if expression. For example, you can do all of the following: if (0) alert("YEAH!") else alert("NO!"), if ("") alert ("YEAH!") else alert("NO!"), if (false) alert("YEAH") else alert("NO!), etc. and all of these will throw an alert of NO!. If you do if ("WHAT") alert ("YEAH") else alert("NO!"), it will alert a "YEAH!" because JavaScript considers non-empty strings to be a sort of true-ish value.</p>
<p>Even though strictly using Bool for boolean semantics works better in Haskell, let's try and implement that JavaScript-ish behavior anyway. For fun! Let's start out with a class declaration.</p>
<pre><code>class YesNo a where  
    yesno :: a -&gt; Bool
</code></pre>
<p>Pretty simple. The YesNo typeclass defines one function. That function takes one value of a type that can be considered to hold some concept of true-ness and tells us for sure if it's true or not. Notice that from the way we use the a in the function, a has to be a concrete type.</p>
<p>Next up, let's define some instances. For numbers, we'll assume that (like in JavaScript) any number that isn't 0 is true-ish and 0 is false-ish.</p>
<pre><code>instance YesNo Int where  
    yesno 0 = False  
    yesno _ = True
</code></pre>
<p>Empty lists (and by extensions, strings) are a no-ish value, while non-empty lists are a yes-ish value.</p>
<pre><code>instance YesNo [a] where  
    yesno [] = False  
    yesno _ = True
</code></pre>
<p>Notice how we just put in a type parameter a in there to make the list a concrete type, even though we don't make any assumptions about the type that's contained in the list. What else, hmm ... I know, Bool itself also holds true-ness and false-ness and it's pretty obvious which is which.</p>
<pre><code>instance YesNo Bool where  
    yesno = id
</code></pre>
<p>Huh? What's id? It's just a standard library function that takes a parameter and returns the same thing, which is what we would be writing here anyway.</p>
<p>Let's make Maybe a an instance too.</p>
<pre><code>instance YesNo (Maybe a) where  
    yesno (Just _) = True  
    yesno Nothing = False
</code></pre>
<p>We didn't need a class constraint because we made no assumptions about the contents of the Maybe. We just said that it's true-ish if it's a Just value and false-ish if it's a Nothing. We still had to write out (Maybe a) instead of just Maybe because if you think about it, a Maybe -&gt; Bool function can't exist (because Maybe isn't a concrete type), whereas a Maybe a -&gt; Bool is fine and dandy. Still, this is really cool because now, any type of the form Maybe something is part of YesNo and it doesn't matter what that something is.</p>
<p>Previously, we defined a Tree a type, that represented a binary search tree. We can say an empty tree is false-ish and anything that's not an empty tree is true-ish.</p>
<pre><code>instance YesNo (Tree a) where  
    yesno EmptyTree = False  
    yesno _ = True
</code></pre>
<p>Can a traffic light be a yes or no value? Sure. If it's red, you stop. If it's green, you go. If it's yellow? Eh, I usually run the yellows because I live for adrenaline.</p>
<pre><code>instance YesNo TrafficLight where  
    yesno Red = False  
    yesno _ = True
</code></pre>
<p>Cool, now that we have some instances, let's go play!</p>
<pre><code>Prelude&gt; yesno $ length []  
False  
Prelude&gt; yesno "haha"  
True  
Prelude&gt; yesno ""  
False  
Prelude&gt; yesno $ Just 0  
True  
Prelude&gt; yesno True  
True  
Prelude&gt; yesno EmptyTree  
False  
Prelude&gt; yesno []  
False  
Prelude&gt; yesno [0,0,0]  
True  
Prelude&gt; :t yesno  
yesno :: (YesNo a) =&gt; a -&gt; Bool
</code></pre>
<p>Right, it works! Let's make a function that mimics the if statement, but it works with YesNo values.</p>
<pre><code>yesnoIf :: (YesNo y) =&gt; y -&gt; a -&gt; a -&gt; a  
yesnoIf yesnoVal yesResult noResult = if yesno yesnoVal then yesResult else noResult
</code></pre>
<p>Pretty straightforward. It takes a yes-no-ish value and two things. If the yes-no-ish value is more of a yes, it returns the first of the two things, otherwise it returns the second of them.</p>
<pre><code>Prelude&gt; yesnoIf [] "YEAH!" "NO!"  
"NO!"  
Prelude&gt; yesnoIf [2,3,4] "YEAH!" "NO!"  
"YEAH!"  
Prelude&gt; yesnoIf True "YEAH!" "NO!"  
"YEAH!"  
Prelude&gt; yesnoIf (Just 500) "YEAH!" "NO!"  
"YEAH!"  
Prelude&gt; yesnoIf Nothing "YEAH!" "NO!"  
"NO!"
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>The Functor typeclass</p>
<p>So far, we've encountered a lot of the typeclasses in the standard library. We've played with Ord, which is for stuff that can be ordered. We've palled around with Eq, which is for things that can be equated. We've seen Show, which presents an interface for types whose values can be displayed as strings. Our good friend Read is there whenever we need to convert a string to a value of some type. And now, we're going to take a look at the Functor typeclass, which is basically for things that can be mapped over. You're probably thinking about lists now, since mapping over lists is such a dominant idiom in Haskell. And you're right, the list type is part of the Functor typeclass.</p>
<p>What better way to get to know the Functor typeclass than to see how it's implemented? Let's take a peek.</p>
<pre><code>class Functor f where  
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>I AM FUNCTOOOOR!!!</p>
<p>Alright. We see that it defines one function, fmap, and doesn't provide any default implementation for it. The type of fmap is interesting. In the definitions of typeclasses so far, the type variable that played the role of the type in the typeclass was a concrete type, like the a in (==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool. But now, the f is not a concrete type (a type that a value can hold, like Int, Bool or Maybe String), but a type constructor that takes one type parameter. A quick refresher example: Maybe Int is a concrete type, but Maybe is a type constructor that takes one type as the parameter. Anyway, we see that fmap takes a function from one type to another and a functor applied with one type and returns a functor applied with another type.</p>
<p>If this sounds a bit confusing, don't worry. All will be revealed soon when we check out a few examples. Hmm, this type declaration for fmap reminds me of something. If you don't know what the type signature of map is, it's: map :: (a -&gt; b) -&gt; [a] -&gt; [b].</p>
<p>Ah, interesting! It takes a function from one type to another and a list of one type and returns a list of another type. My friends, I think we have ourselves a functor! In fact, map is just a fmap that works only on lists. Here's how the list is an instance of the Functor typeclass.</p>
<pre><code>instance Functor [] where  
    fmap = map
</code></pre>
<p>That's it! Notice how we didn't write instance Functor [a] where, because from fmap :: (a -&gt; b) -&gt; f a -&gt; f b, we see that the f has to be a type constructor that takes one type. [a] is already a concrete type (of a list with any type inside it), while [] is a type constructor that takes one type and can produce types such as [Int], [String] or even [[String]].</p>
<p>Since for lists, fmap is just map, we get the same results when using them on lists.</p>
<pre><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]  
Prelude&gt; fmap (*2) [1..3]  
[2,4,6]  
Prelude&gt; map (*2) [1..3]  
[2,4,6]
</code></pre>
<p>What happens when we map or fmap over an empty list? Well, of course, we get an empty list. It just turns an empty list of type [a] into an empty list of type [b].</p>
<p>Types that can act like a box can be functors. You can think of a list as a box that has an infinite amount of little compartments and they can all be empty, one can be full and the others empty or a number of them can be full. So, what else has the properties of being like a box? For one, the Maybe a type. In a way, it's like a box that can either hold nothing, in which case it has the value of Nothing, or it can hold one item, like "HAHA", in which case it has a value of Just "HAHA". Here's how Maybe is a functor.</p>
<pre><code>instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing
</code></pre>
<p>Again, notice how we wrote instance Functor Maybe where instead of instance Functor (Maybe m) where, like we did when we were dealing with Maybe and YesNo. Functor wants a type constructor that takes one type and not a concrete type. If you mentally replace the fs with Maybes, fmap acts like a (a -&gt; b) -&gt; Maybe a -&gt; Maybe b for this particular type, which looks OK. But if you replace f with (Maybe m), then it would seem to act like a (a -&gt; b) -&gt; Maybe m a -&gt; Maybe m b, which doesn't make any damn sense because Maybe takes just one type parameter.</p>
<p>Anyway, the fmap implementation is pretty simple. If it's an empty value of Nothing, then just return a Nothing. If we map over an empty box, we get an empty box. It makes sense. Just like if we map over an empty list, we get back an empty list. If it's not an empty value, but rather a single value packed up in a Just, then we apply the function on the contents of the Just.</p>
<pre><code>Prelude&gt; fmap (++ " HEY GUYS IM INSIDE THE JUST") (Just "Something serious.")  
Just "Something serious. HEY GUYS IM INSIDE THE JUST"  
Prelude&gt; fmap (++ " HEY GUYS IM INSIDE THE JUST") Nothing  
Nothing  
Prelude&gt; fmap (*2) (Just 200)  
Just 400  
Prelude&gt; fmap (*2) Nothing  
Nothing
</code></pre>
<p>Another thing that can be mapped over and made an instance of Functor is our Tree a type. It can be thought of as a box in a way (holds several or no values) and the Tree type constructor takes exactly one type parameter. If you look at fmap as if it were a function made only for Tree, its type signature would look like (a -&gt; b) -&gt; Tree a -&gt; Tree b. We're going to use recursion on this one. Mapping over an empty tree will produce an empty tree. Mapping over a non-empty tree will be a tree consisting of our function applied to the root value and its left and right sub-trees will be the previous sub-trees, only our function will be mapped over them.</p>
<pre><code>instance Functor Tree where  
    fmap f EmptyTree = EmptyTree  
    fmap f (Node x leftsub rightsub) = Node (f x) (fmap f leftsub) (fmap f rightsub)

Prelude&gt; fmap (*2) EmptyTree  
EmptyTree  
Prelude&gt; fmap (*4) (foldr treeInsert EmptyTree [5,7,3,2,1,7])  
Node 28 (Node 4 EmptyTree (Node 8 EmptyTree (Node 12 EmptyTree (Node 20 EmptyTree EmptyTree)))) EmptyTree
</code></pre>
<p>Nice! Now how about Either a b? Can this be made a functor? The Functor typeclass wants a type constructor that takes only one type parameter but Either takes two. Hmmm! I know, we'll partially apply Either by feeding it only one parameter so that it has one free parameter. Here's how Either a is a functor in the standard libraries:</p>
<pre><code>instance Functor (Either a) where  
    fmap f (Right x) = Right (f x)  
    fmap f (Left x) = Left x
</code></pre>
<p>Well well, what did we do here? You can see how we made Either a an instance instead of just Either. That's because Either a is a type constructor that takes one parameter, whereas Either takes two. If fmap was specifically for Either a, the type signature would then be (b -&gt; c) -&gt; Either a b -&gt; Either a c because that's the same as (b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c. In the implementation, we mapped in the case of a Right value constructor, but we didn't in the case of a Left. Why is that? Well, if we look back at how the Either a b type is defined, it's kind of like:</p>
<pre><code>data Either a b = Left a | Right b
</code></pre>
<p>Well, if we wanted to map one function over both of them, a and b would have to be the same type. I mean, if we tried to map a function that takes a string and returns a string and the b was a string but the a was a number, that wouldn't really work out. Also, from seeing what fmap's type would be if it operated only on Either values, we see that the first parameter has to remain the same while the second one can change and the first parameter is actualized by the Left value constructor.</p>
<p>This also goes nicely with our box analogy if we think of the Left part as sort of an empty box with an error message written on the side telling us why it's empty.</p>
<p>Maps from Data.Map can also be made a functor because they hold values (or not!). In the case of Map k v, fmap will map a function v -&gt; v' over a map of type Map k v and return a map of type Map k v'.
Note, the ' has no special meaning in types just like it doesn't have special meaning when naming values. It's used to denote things that are similar, only slightly changed.</p>
<p>Try figuring out how Map k is made an instance of Functor by yourself!</p>
<p>With the Functor typeclass, we've seen how typeclasses can represent pretty cool higher-order concepts. We've also had some more practice with partially applying types and making instances. In one of the next chapters, we'll also take a look at some laws that apply for functors.
Just one more thing! Functors should obey some laws so that they may have some properties that we can depend on and not think about too much. If we use fmap (+1) over the list [1,2,3,4], we expect the result to be [2,3,4,5] and not its reverse, [5,4,3,2]. If we use fmap (\a -&gt; a) (the identity function, which just returns its parameter) over some list, we expect to get back the same list as a result. For example, if we gave the wrong functor instance to our Tree type, using fmap over a tree where the left sub-tree of a node only has elements that are smaller than the node and the right sub-tree only has nodes that are larger than the node might produce a tree where that's not the case. We'll go over the functor laws in more detail in one of the next chapters.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Kinds and some type-foo</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Type constructors take other types as parameters to eventually produce concrete types. That kind of reminds me of functions, which take values as parameters to produce values. We've seen that type constructors can be partially applied (Either String is a type that takes one type and produces a concrete type, like Either String Int), just like functions can. This is all very interesting indeed. In this section, we'll take a look at formally defining how types are applied to type constructors, just like we took a look at formally defining how values are applied to functions by using type declarations. You don't really have to read this section to continue on your magical Haskell quest and if you don't understand it, don't worry about it. However, getting this will give you a very thorough understanding of the type system.</p>
<p>So, values like 3, "YEAH" or takeWhile (functions are also values, because we can pass them around and such) each have their own type. Types are little labels that values carry so that we can reason about the values. But types have their own little labels, called kinds. A kind is more or less the type of a type. This may sound a bit weird and confusing, but it's actually a really cool concept.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>Prelude&gt; :k Int  
Int :: *
</code></pre>
<p>A star? How quaint. What does that mean? A * means that the type is a concrete type. A concrete type is a type that doesn't take any type parameters and values can only have types that are concrete types. If I had to read * out loud (I haven't had to do that so far), I'd say star or just type.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Okay, now let's see what the kind of Maybe is.</p>
<pre><code>Prelude&gt; :k Maybe  
Maybe :: * -&gt; *
</code></pre>
<p>The Maybe type constructor takes one concrete type (like Int) and then returns a concrete type like Maybe Int. And that's what this kind tells us. Just like Int -&gt; Int means that a function takes an Int and returns an Int, * -&gt; * means that the type constructor takes one concrete type and returns a concrete type. Let's apply the type parameter to Maybe and see what the kind of that type is.</p>
<pre><code>Prelude&gt; :k Maybe Int  
Maybe Int :: *
</code></pre>
<p>Just like I expected! We applied the type parameter to Maybe and got back a concrete type (that's what * -&gt; * means. A parallel (although not equivalent, types and kinds are two different things) to this is if we do :t isUpper and :t isUpper 'A'. isUpper has a type of Char -&gt; Bool and isUpper 'A' has a type of Bool, because its value is basically True. Both those types, however, have a kind of *.</p>
<p>We used :k on a type to get its kind, just like we can use :t on a value to get its type. Like we said, types are the labels of values and kinds are the labels of types and there are parallels between the two.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Let's look at another kind.</p>
<pre><code>Prelude&gt; :k Either  
Either :: * -&gt; * -&gt; *
</code></pre>
<p>Aha, this tells us that Either takes two concrete types as type parameters to produce a concrete type. It also looks kind of like a type declaration of a function that takes two values and returns something. Type constructors are curried (just like functions), so we can partially apply them.</p>
<pre><code>Prelude&gt; :k Either String  
Either String :: * -&gt; *  
Prelude&gt; :k Either String Int  
Either String Int :: *
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>When we wanted to make Either a part of the Functor typeclass, we had to partially apply it because Functor wants types that take only one parameter while Either takes two. In other words, Functor wants types of kind * -&gt; * and so we had to partially apply Either to get a type of kind * -&gt; * instead of its original kind * -&gt; * -&gt; *. If we look at the definition of Functor again</p>
<pre><code>class Functor f where   
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>we see that the f type variable is used as a type that takes one concrete type to produce a concrete type. We know it has to produce a concrete type because it's used as the type of a value in a function. And from that, we can deduce that types that want to be friends with Functor have to be of kind * -&gt; *.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>class Tofu t where  
    tofu :: j a -&gt; t a j
</code></pre>
<p>Man, that looks weird. How would we make a type that could be an instance of that strange typeclass? Well, let's look at what its kind would have to be. Because j a is used as the type of a value that the tofu function takes as its parameter, j a has to have a kind of <em>. We assume * for a and so we can infer that j has to have a kind of * -&gt; </em>. We see that t has to produce a concrete value too and that it takes two types. And knowing that a has a kind of * and j has a kind of * -&gt; <em>, we infer that t has to have a kind of * -&gt; (</em> -&gt; <em>) -&gt; </em>. So it takes a concrete type (a), a type constructor that takes one concrete type (j) and produces a concrete type. Wow.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>OK, so let's make a type with a kind of * -&gt; (<em> -&gt; </em>) -&gt; *. Here's one way of going about it.</p>
<pre><code>data Frank a b  = Frank {frankField :: b a} deriving (Show)
</code></pre>
<p>How do we know this type has a kind of * -&gt; (<em> -&gt; </em>) - &gt; <em>? Well, fields in ADTs are made to hold values, so they must be of kind </em>, obviously. We assume * for a, which means that b takes one type parameter and so its kind is * -&gt; <em>. Now we know the kinds of both a and b and because they're parameters for Frank, we see that Frank has a kind of * -&gt; (</em> -&gt; <em>) -&gt; * The first * represents a and the (</em> -&gt; *) represents b. Let's make some Frank values and check out their types.</p>
<pre><code>Prelude&gt; :t Frank {frankField = Just "HAHA"}  
Frank {frankField = Just "HAHA"} :: Frank [Char] Maybe  
Prelude&gt; :t Frank {frankField = Node 'a' EmptyTree EmptyTree}  
Frank {frankField = Node 'a' EmptyTree EmptyTree} :: Frank Char Tree  
Prelude&gt; :t Frank {frankField = "YES"}  
Frank {frankField = "YES"} :: Frank Char []
</code></pre>
<p>Hmm. Because frankField has a type of form a b, its values must have types that are of a similar form as well. So they can be Just "HAHA", which has a type of Maybe [Char] or it can have a value of ['Y','E','S'], which has a type of [Char] (if we used our own list type for this, it would have a type of List Char). And we see that the types of the Frank values correspond with the kind for Frank. [Char] has a kind of * and Maybe has a kind of * -&gt; <em>. Because in order to have a value, it has to be a concrete type and thus has to be fully applied, every value of Frank blah blaah has a kind of </em>.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <p>Making Frank an instance of Tofu is pretty simple. We see that tofu takes a j a (so an example type of that form would be Maybe Int) and returns a t a j. So if we replace Frank with j, the result type would be Frank Int Maybe.</p>
<pre><code>instance Tofu Frank where  
    tofu x = Frank x

Prelude&gt; tofu (Just 'a') :: Frank Char Maybe  
Frank {frankField = Just 'a'}  
Prelude&gt; tofu ["HELLO"] :: Frank [Char] []  
Frank {frankField = ["HELLO"]}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>data Barry t k p = Barry { yabba :: p, dabba :: t k }
</code></pre>
<p>And now we want to make it an instance of Functor. Functor wants types of kind * -&gt; * but Barry doesn't look like it has that kind. What is the kind of Barry? Well, we see it takes three type parameters, so it's going to be something -&gt; something -&gt; something -&gt; <em>. It's safe to say that p is a concrete type and thus has a kind of </em>. For k, we assume * and so by extension, t has a kind of * -&gt; <em>. Now let's just replace those kinds with the somethings that we used as placeholders and we see it has a kind of (</em> -&gt; <em>) -&gt; * -&gt; * -&gt; </em>. Let's check that with GHCI.</p>
<pre><code>Prelude&gt; :k Barry  
Barry :: (* -&gt; *) -&gt; * -&gt; * -&gt; *
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre><code>instance Functor (Barry a b) where  
    fmap f (Barry {yabba = x, dabba = y}) = Barry {yabba = f x, dabba = y}
</code></pre>
<p>There we go! We just mapped the f over the first field.</p>
<p>In this section, we took a good look at how type parameters work and kind of formalized them with kinds, just like we formalized function parameters with type declarations. We saw that there are interesting parallels between functions and type constructors. They are, however, two completely different things. When working on real Haskell, you usually won't have to mess with kinds and do kind inference by hand like we did now. Usually, you just have to partially apply your own type to * -&gt; * or * when making it an instance of one of the standard typeclasses, but it's good to know how and why that actually works. It's also interesting to see that types have little types of their own. Again, you don't really have to understand everything we did here to read on, but if you understand how kinds work, chances are that you have a very solid grasp of Haskell's type system.</p></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2></h2>
      <h3></h3>
    </hgroup>
    <article >
      </article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>