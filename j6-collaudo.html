<!--
Google IO 2012 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahe <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
-->
<!DOCTYPE html>
<html>
<head>
  <title>Collaudo del software</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="stylesheet" media="all" href="theme/css/default.css">
  <link rel="stylesheet" media="all" href="theme/css/java.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="theme/css/phone.css">
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  <script data-main="js/slides" src="js/require-1.0.8.min.js"></script>
</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

<slide class="title-slide segue nobackground">
  <aside class="gdbar"><img src="images/java-logo.png"></aside>
  <!-- The content of this hgroup is replaced programmatically through the slide_config.json. -->
  <h1 data-config-title><!-- populated from slide_config.json --></h1>
  <figure><img src="images/dev/bug-feature.jpg"></figure>
  <hgroup>
    <h2>Programmazione ad oggetti in Java</h2>
    <p>Michele Tomaiuolo<br>Ingegneria dell'Informazione, UniPR</p>
  </hgroup>
</slide>


<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/java-logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Ingegneria del software</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Ingegneria del software</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Realizzazione di sistemi software di dimensioni e <strong>complessità</strong> tali da richiedere uno o più <strong>team</strong> di persone</li>
<li>Approccio <strong>sistematico</strong> allo sviluppo, all’operatività, alla manutenzione ed al ritiro del software</li>
<li>Disciplina <strong>tecnologica e manageriale</strong> che riguarda la produzione sistematica e la manutenzione dei prodotti software che vengono sviluppati e modificati entro <strong>tempi e costi</strong> preventivati</li>
<li>Teorie, metodi e strumenti, sia di tipo tecnologico che organizzativo, che consentono di produrre applicazioni con le desiderate caratteristiche di <strong>qualità</strong></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Software e ingegneria classica</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Creatività e metodo</strong><ul>
<li>Il software è un prodotto dell’ingegno e non di un processo industriale</li>
</ul>
</li>
<li><strong>Prodotto e processo</strong><ul>
<li>L’ingegneria classica (civile, meccanica) progetta il prodotto e anche il processo industriale</li>
<li>L’ingegneria del software (spesso) progetta solo il prodotto e non utilizza un processo industriale formalizzato</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Sw engineering, cenni storici</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Nascita con conferenza NATO del 1968<ul>
<li>Sw crisis, sw reuse → sw engineering</li>
</ul>
</li>
<li>Anni 1990, sviluppo delle tecnologie orientate agli oggetti<ul>
<li>UML (Unified Modeling Language)</li>
<li>Design pattern</li>
</ul>
</li>
<li>Metà anni 1990, Java<ul>
<li>Prospettive: Web, e-commerce, interoperabilità</li>
<li>Linguaggio orientato agli oggetti</li>
<li>Multi-piattaforma</li>
<li>Web-oriented</li>
<li>Ben accettato dalla comunità dell’open source</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Qualità del software</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Le qualità su cui si basa la valutazione di un sistema software possono essere:<ul>
<li><strong>Interne</strong>, riguardano le caratteristiche legate al <strong>processo</strong> di sviluppo e non sono direttamente visibili agli utenti</li>
<li><strong>Esterne</strong>, riguardano le funzionalità fornite dal <strong>prodotto</strong> sw e sono direttamente visibili agli utenti</li>
</ul>
</li>
<li>Le categorie sono legate:<ul>
<li><em>Product quality is process quality</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Qualità esterne</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Correttezza e affidabilità</strong>: il sistema rispetta le specifiche, l'utente può affidarsi al programma</li>
<li><strong>Robustezza</strong>: il sistema si comporta in modo ragionevole anche fuori dalle specifiche</li>
<li><strong>Efficienza</strong>: usa bene le risorse di calcolo</li>
<li><strong>Scalabilità</strong>: migliori prestazioni con più risorse</li>
<li><strong>Sicurezza</strong>: riservatezza, autenticazione, autorizzazione, accounting</li>
<li><strong>Facilità d’uso</strong>: interfaccia utente permette di interagire in modo naturale</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Qualità interne</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Verificabilità</strong>: sistema basato su modello formale</li>
<li><strong>Riusabilità</strong>: parti per costruire nuovi sistemi</li>
<li><strong>Manutenibilità</strong>: riparabilità, evolvibilità (nuove specifiche), adattabilità (cambiamenti ambiente)</li>
<li><strong>Interoperabilità</strong>: capacità di co-operare con altri sistemi, anche di altri produttori</li>
<li><strong>Portabilità</strong>: adatto a più piattaforme hw/sw</li>
<li><strong>Comprensibilità</strong>: codice leggibile, documentato</li>
<li><strong>Modularità</strong>: interazione tra componenti coesi</li>
</ul></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Ciclo di vita del software</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/waterfall-model.svg">
        
      </figure><ul>
<li><strong>Analisi</strong><ul>
<li>Modello, requisiti, fattibilità</li>
</ul>
</li>
<li><strong>Progetto e implementazione</strong><ul>
<li>Componenti architetturali, dettaglio classi</li>
</ul>
</li>
<li><strong>Collaudo</strong><ul>
<li>Rispetto dei requisiti, qualità del sw</li>
</ul>
</li>
<li><strong>Rilascio e manutenzione</strong><ul>
<li>70-75% del costo totale (fonti DoD USA, HP)</li>
<li>Anomalie ed errori (manutenzione <em>correttiva</em>, ~20%)</li>
<li>Prestazioni, qualità, funzionalità (m. <em>perfettiva</em>, ~60%)</li>
<li>Mutamenti dell’ambiente (m. <em>adattativa</em>, ~20%)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Evoluzione di un sistema sw</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/rup-cycle.png">
        
      </figure><ul>
<li>Evoluzione ineliminabile per molti sistemi<ul>
<li>Non noti o non colti correttamente i requisiti</li>
<li>Cambiano le condizioni operative …</li>
</ul>
</li>
<li>Sviluppo iterativo e metodologie agili<ul>
<li>Rilascio frequente ed incrementale</li>
<li><a href="http://agilemanifesto.org/">http://agilemanifesto.org/</a></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Specifiche</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/gearwheel.png">
        
      </figure><ul>
<li>Rispetto a cosa valutiamo <strong>correttezza</strong> o <strong>affidabilità</strong> di un programma?</li>
<li>Idea del programmatore<ul>
<li>Non formulata, non documentata</li>
<li>Incompleta, mutevole, facilmente dimenticata</li>
</ul>
</li>
<li>Specifiche (formali o informali)<ul>
<li>Formulate, scritte, studiate e condivise <br> → Parte del progetto e del programma</li>
<li>Spec. assiomatiche: espressioni logiche o asserzioni <br> → <strong>Precondizioni, postcondizioni e invarianti</strong></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/java-logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Design by Contract (DbC)</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Pre- e post-condizioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Precondizioni</strong><ul>
<li>Stabiliscono se è possibile chiamare un metodo</li>
<li>Prerequisiti per l’attivazione</li>
</ul>
</li>
<li><strong>Postcondizioni</strong><ul>
<li>Stabiliscono se il metodo restituisce il valore atteso, cioè se produce l’effetto desiderato</li>
<li>… In relazione ai parametri (che soddisfano le precondizioni)</li>
<li>Definiscono il significato del metodo</li>
</ul>
</li>
<li><strong>Divisione delle responsabilità</strong> tra moduli<ul>
<li>Errore del codice <em>chiamante</em> (<em>client</em>) se precondizioni non soddisfatte</li>
<li>Errore del codice <em>chiamato</em> (<em>server</em>), se postcondizioni non soddisfatte</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Responsabilità e contratti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li><strong>Precondizioni + postcondizioni = contratto</strong><ul>
<li>… tra modulo chiamante e modulo chiamato</li>
</ul>
</li>
<li>Infrazione di un contratto: problema serio<ul>
<li>Errore rispetto alle specifiche</li>
<li>Eccezione e/o terminazione</li>
</ul>
</li>
<li>No <strong>divisione responsabilità</strong> → sovrapposizioni<ul>
<li>Tutti i moduli assumono molte responsabilità</li>
<li>Programmazione difensiva: tutte le parti del programma controllano tutte le condizioni</li>
<li>Grosso programma → ancora più grosso</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio di contratto</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Java"><code>public double sqrt(double x) { /* ... */ }
</code></pre>
<ul>
<li>Precondizioni: <code>x &gt;= 0</code></li>
<li>Postcondizioni: <code>abs(result * result - x) &lt;= 0.00001</code></li>
<li>Codice chiamante<ul>
<li>Obblighi: deve passare un numero non negativo</li>
<li>Benefici: riceve la radice del numero</li>
</ul>
</li>
<li>Codice chiamato<ul>
<li>Obblighi: restituisce un numero <code>r</code> tale che <code>r * r ≃ x</code></li>
<li>Benefici: può assumere che <code>x</code> non è negativo</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Invariante di classe</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Vincolo che deve valere per ogni stato stabile di un oggetto, durante tutto il suo ciclo di vita</li>
<li>Rafforzamento generale di pre- e post-condizioni</li>
<li>“Criterio di sanità” dell’oggetto</li>
<li>Deve essere soddisfatto dal costruttore</li>
<li>Deve essere mantenuto dai metodi pubblici</li>
<li>Ma non necessariamente da metodi privati o protetti</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Ereditarietà e contratti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <p><img alt="" src="images/dev/contract-inherit.svg" /></p>
<ul>
<li><em>Che relazione c’è tra le asserzioni di una classe e quelle dei suoi discendenti?</em></li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Principio di sostituibilità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Polimorfismo: possibile esecuzione metodo di una sottoclasse, anziché della classe base<ul>
<li>I metodi delle sottoclassi possono ridefinire i metodi delle classi base... ma non arbitrariamente</li>
</ul>
</li>
<li>I contratti della sottoclasse devono <em>rispettare i contratti della classe base</em> (“sottocontratti”)<ul>
<li>Precondizioni: non devono essere più forti</li>
<li>Postcondizioni: non devono essere più deboli</li>
<li>Invarianti di classe: non devono essere più deboli</li>
</ul>
</li>
</ul>
<blockquote>
<p>Require no more, promise no less</p>
</blockquote></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Design by Contract</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Paradigma proposto nel linguaggio <em>Eiffel</em> (Betrand <em>Meyer</em>, 1986)</li>
<li>Uso di asserzioni in varie fasi di sviluppo<ul>
<li>Progetto: approccio pragmatico alle specifiche</li>
<li>Implementazione: guida per la programmazione</li>
<li>Documentazione: interfacce con info aggiuntive</li>
<li>Collaudo: DbC delimita i casi da testare (per affidabilità)</li>
<li>Manutenzione: DbC fa emergere prima gli errori</li>
<li>Uso finale: sollevate eccezioni se violazioni</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Asserzioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Espressioni booleane, simili a predicati matematici</li>
<li>Esprimono proprietà semantiche di classi e metodi</li>
<li>Utili per collaudo e debugging, ma anche documentazione</li>
<li>Violazione → <strong>AssertionError</strong> (e normalmente <em>abort</em>, terminazione programma)</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>assert age &gt;= 0;
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Asserzioni e contratti</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Asserzioni in genere utili per:<ul>
<li>Precondizioni, postcondizioni, invarianti di classe</li>
<li>Invarianti interne e di controllo del flusso</li>
</ul>
</li>
<li>Argomenti di metodi pubblici sbagliati → eccezione<ul>
<li><code>IllegalArgumentException</code> o sottoclasse</li>
<li>Asserzioni normalmente disabilitate, usate solo per debug</li>
<li>Attivate con il flag <code>-ea</code> del comando <code>java</code> </li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Pre- e post-condizioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Java"><code>/**
 * Precondition: x &gt;= 0
 * Postcondition: abs(result * result - x) &lt;= 0.00001
 */
public double sqrt(double x) {
    if (x &lt; 0) throw new IllegalArgumentException("sqrt: arg &lt; 0");

    // ...

    assert Math.abs(result * result - x) &lt;= 0.00001;
    return result;
}
</code></pre></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/java-logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Verifica e validazione</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Verifica e validazione</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/v-model.png">
        
      </figure><ul>
<li>Mostrare che il sistema...<ul>
<li>È conforme alle specifiche</li>
<li>Soddisfa i bisogni dell’utente</li>
</ul>
</li>
<li>Comprende revisione e collaudo del sistema</li>
<li><strong>Test case</strong>, derivati dalle specifiche</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Costo dei bug</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/first-bug.jpg">
        
      </figure><ul>
<li>Scovare bug non è un compito facile, e nemmeno una esperienza eccitante…<ul>
<li>Costoso: non è insolito dedicare al testing il 40% del tempo e delle risorse di un progetto</li>
</ul>
</li>
<li><strong>Far emergere</strong> bug in prime fasi dello sviluppo!<ul>
<li>B. Boehm: se trovare e correggere un problema in fase di specifica dei requisiti costa 1$...</li>
<li>5$ in progetto, $10 in programmazione,</li>
<li>$20 in unit testing, fino a $200 dopo consegna</li>
<li>Bug possibili già a causa di specifiche non ben chiare e capite</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Prove formali</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Dimostrazione matematica di un programma: alternativa (~ accademica) al testing<ul>
<li>Annotazione del programma con asserzioni matematiche: comportamento atteso</li>
<li>Proprietà valide per i vari costrutti del programma</li>
</ul>
</li>
<li>Prova che post-condizioni verificate, se:<ul>
<li>Precondizioni verificate</li>
<li>Programma termina</li>
</ul>
</li>
<li>Dimostrazioni automatiche<ul>
<li>Se a mano → errori (più che nel programma?)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Revisione del software</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Analisi del codice (o pseudocodice) per capirne le caratteristiche e le funzionalità</li>
<li><strong>Code walk-through</strong><ul>
<li>Selezione porzioni di codice e valori di input</li>
<li>Simulazione su carta comportamento del sistema</li>
</ul>
</li>
<li><strong>Code inspection</strong>, più formale e focalizzato<ul>
<li>Uso di variabili non inizializzate</li>
<li>Loop infiniti</li>
<li>Letture di porzioni di memoria non allocata</li>
<li>Rilascio improprio della memoria</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Testing</h2>
      <h3></h3>
    </hgroup>
    <article >
      <blockquote>
<p>Le operazioni di testing possono individuare la presenza di errori nel software ma non ne possono dimostrare la correttezza. <em>(E. Dijkstra)</em></p>
<p>Eseguire un programma con l'intento di trovare errori. <em>(Glen Myers, “The art of Software Testing”)</em></p>
</blockquote>
<ul>
<li>Verificare sistema in un insieme abbastanza ampio di casi... → plausibile comportamento analogo anche nelle restanti situazioni</li>
</ul></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Classificazione dei test</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/v-model.png">
        
      </figure><ul>
<li>Tipi di test<ul>
<li><strong>White box</strong> (<em>in the small</em>)</li>
<li><strong>Black box</strong> (<em>in the large</em>)</li>
</ul>
</li>
<li>Livelli di test<ul>
<li><em>Unit test</em></li>
<li><em>Integration test</em></li>
<li><em>System test</em></li>
</ul>
</li>
<li>Ripetizione di test<ul>
<li><em>Regression test</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Testabilità</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Qualità software che facilitano rilevazione errori<ul>
<li><strong>Osservabilità</strong> – Disponibili i risultati dei test</li>
<li><strong>Controllabilità</strong> – Possibilità di impostare ingressi e stato del programma prima di eseguire un test</li>
<li><strong>Decomponibilità</strong> – Programma diviso in parti che possono essere testate individualmente</li>
<li><strong>Comprensibilità</strong> – Si capisce il comportamento corretto (desiderato) del programma</li>
</ul>
</li>
<li>→ Sviluppo per testabilità</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/java-logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>White-box testing</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>White-box testing</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Test basati sulla conoscenza della struttura interna del codice</li>
<li>Un errore non può essere scoperto se la parte di codice che lo contiene non viene mai eseguita</li>
<li><strong>Statement test</strong><ul>
<li>Insieme di test T tali che, eseguendo su tutti i casi di T il programma P, ogni istruzione di P venga eseguita almeno una volta (test utopia?)</li>
<li><strong>Branch test</strong> (copertura delle decisioni)</li>
<li><strong>Branch &amp; condition test</strong> (… condizioni)</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Basic path testing</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Scelto insieme minimo di percorsi per coprire tutte le istruzioni e condizioni (<em>white box</em>)<ul>
<li>Tracciare diagramma di flusso</li>
<li>Astrarre il diagramma in un grafo di flusso</li>
<li>Complessità ciclomatica <code>n</code> = metrica di test</li>
<li>Trovare <code>n</code> casi di test che seguono ciascun cammino indipendente</li>
</ul>
</li>
<li><strong>Cammino</strong>: sequenza di comandi, da inizio a fine</li>
<li><strong>Cammino indipendente</strong>: aggiunge almeno una nuova istruzione rispetto ai cammini già identificati</li>
</ul></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Diagramma di flusso</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/flow-chart.png">
        
      </figure><pre class="prettyprint" data-lang="Java"><code>void f() {
    // entry 
    while (a) {
        x();
        if (b) {
            if (z) y();
            else z();
            // p
        } else {
            v();
            w();
        }
        // q
    }
    // exit: r
}
</code></pre></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Grafo di flusso</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/dev/flow-graph.png">
        
      </figure><ul>
<li>Piccola astrazione da diagramma di flusso</li>
<li><strong>Complessità ciclomatica</strong> (teoria dei grafi):<ul>
<li>Numero di possibili cammini indipendenti, o...</li>
<li>Numero di regioni del grafo, o...</li>
<li>Numero di nodi predicato + 1 <br> &nbsp;</li>
</ul>
</li>
<li><code>A, r</code></li>
<li><code>A, X, B, C, Y, p, q, A, r</code></li>
<li><code>A, X, B, C, Z, p, q, A, r</code></li>
<li><code>A, X, B, V, W, q, A, r</code></li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/java-logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Black box testing</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Black box testing</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Sistema = scatola nera; si verificano le corrispondenze di input e output<ul>
<li>White-box testing: impossibile per grandi sistemi</li>
<li>Test case scelti in base alle specifiche dei requisiti</li>
</ul>
</li>
<li>Desiderata: trovare errori...<ul>
<li>Funzionali: otteniamo i risultati attesi per dati input di un metodo?</li>
<li>Interfaccia: dati passati correttamente tra i metodi?</li>
<li>Efficienza: il metodo è abbastanza veloce?</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Partizioni d’equivalenza</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Partizionamento ingressi in <strong>classi di equivalenza</strong><ul>
<li>Irrealistico testare tutti i possibili ingressi (es. <code>sqrt</code>)</li>
<li>Ipotesi: sufficiente testare un solo caso per classe</li>
<li>Si includono casi limite e valori non validi</li>
<li>Precondizioni: riducono il numero di casi di test</li>
</ul>
</li>
<li>Es. Scambio di elementi <code>i</code> e <code>j</code> in lista <code>v</code><ul>
<li><code>v</code>: vuota, un elemento, più elementi</li>
<li><code>i</code>, <code>j</code>: uno o entrambi gli indici fuori range... <br> oppure entrambi in range: <code>i &lt; j</code>, <code>i &gt; j</code>, <code>i = j</code></li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>void swapElements(List v, int i, int j) { /* ... */ }
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Regression testing</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Scopo: trovare errori di regressione<ul>
<li>Errori in un programma che prima era corretto, ed è stato modificato di recente</li>
<li>Un errore di regressione è un errore che prima non c’era</li>
</ul>
</li>
<li>Dopo la modifica di una parte <code>P</code> nel programma <code>Q</code><ul>
<li>Testare che la parte <code>P</code> funzioni correttamente</li>
<li>Testare che l’intero programma <code>Q</code> non sia stato danneggiato dalla modifica</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="segue dark" >
  
    <aside class="gdbar"><img src="images/java-logo.png"></aside>
    <hgroup class="auto-fadein">
      <h2>Junit</h2>
      <h3></h3>
    </hgroup>
  
</slide>

<slide  >
  
    <hgroup>
      <h2>Come collaudare il codice?</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Usare un <em>debugger</em> per valutare espressioni in fase di esecuzione<ul>
<li>Si può decidere cosa valutare a seconda del flusso di esecuzione e dei valori generati, senza ricompilare</li>
</ul>
</li>
<li>Istruzioni di <em>stampa</em> all'interno del programma<ul>
<li>Valore di espressioni scritto a console o su file di log</li>
</ul>
</li>
<li>Entrambi gli stili, scarsamente <em>automatizzati</em><ul>
<li>Necessità di intervento attivo durante l'esecuzione dei test</li>
<li>Giudizio dei risultati da parte dell'utente</li>
<li>Quali valori analizzare? Sono coerenti?</li>
</ul>
</li>
<li>Scarsamente <em>componibili</em><ul>
<li>Difficile controllare molte espressioni nel debugger</li>
<li>"<em>Scroll blindness</em>": troppe istruzioni di stampa ⇒ codice poco leggibile</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Testing con JUnit</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I test JUnit non richiedono continuo intervento o giudizio da parte dell'utente</li>
<li>Facile eseguire molti test assieme, su un certo progetto</li>
<li>Come definire un test?<ul>
<li>Annotare un metodo di test con <code>@org.junit.Test</code></li>
<li>Per controllare la validità di una espressione, usare <code>assertTrue(boolean)</code></li>
<li>Import statico: <code>import org.junit.Assert.*</code></li>
<li>Non è richiesto di estendere nessuna classe</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio di test</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Controllare che una pallina rimbalzi correttamente contro il bordo inferiore</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>@Test
public void testBounceDown() {
    Ball b = new Ball(8, 11); // dx = 1, dy = 1, w = 16, h = 12
    b.move();
    assertTrue(b.getX() == 9 &amp;&amp; b.getY() == 10);
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fixture</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Due o più test operano su insiemi di oggetti uguali o simili<ul>
<li>Questa configurazione iniziale comune si definisce <em>fixture</em></li>
<li>Ogni test: operazioni o parametri leggermente diversi sulla fixture e risultati diversi</li>
</ul>
</li>
<li>Spesso più tempo per scrivere il codice della fixture che i test veri e propri<ul>
<li>Creazione della fixture facilitata da attenzione in fase di progetto</li>
<li>Ancora meglio se il codice della fixture non è ripetuto</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Definire una fixture</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Se ci sono diversi test con una fixture comune...<ul>
<li>Aggiungere dei campi per le varie parti della fixture</li>
<li>Inizializzare questi campi, in un metodo annotato con <code>@org.junit.Before</code></li>
<li>Liberare evenutali risorse allocate, in un metodo annotato con <code>@org.junit.After</code></li>
</ul>
</li>
<li>Una volta creata la fixture, può essere usata da tutti i test case<ul>
<li>Aggiungere metodi di test (annotati con <code>@Test</code>) alla classe</li>
</ul>
</li>
<li>Si possono specificare più fixture per una stessa classe di test<ul>
<li>Marcare con <code>@Before</code> diversi metodi</li>
</ul>
</li>
<li>Non si può specificare l’ordine di esecuzione<ul>
<li>Vengono però eseguite prima le fixture delle classi base</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio di fixture</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Numerosi metodi di test che operano su stessi dati iniziali<ul>
<li>Esempio, una combinazione di palline in posizioni predefinite</li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>public class SimpleBallTest { 
    private Ball b1; 
    private Ball b2; 
    private Ball b3;

    @Before public void setUp() { 
        b1 = new Ball(8, 4); 
        b2 = new Ball(4, 8); 
        b3 = new Ball(12, 2); 
    }
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esecuzione dei test</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>JUnit fornisce meccanismi per definire l'insieme di test da eseguire e organizzare i risultati</li>
<li>Esecuzione di test dalla linea di comando<ul>
<li>Classe di test e junit nel <em>classpath</em></li>
<li>Risultati sulla console</li>
<li><code>java org.junit.runner.JUnitCore TestClass1 [...other test classes...]</code></li>
</ul>
</li>
<li>Esecuzione di test da un programma Java<ul>
<li><code>JUnitCore.runClasses(TestClass1.class, ...);</code></li>
</ul>
</li>
<li>Annotazione <code>@Ignore</code><ul>
<li>Indica al framework di ignorare un certo metodo di test</li>
<li>Si può anche passare un messaggio per documentare la decisione</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide class="large-figure" >
  
    <hgroup>
      <h2>Integrazione con Eclipse</h2>
      <h3></h3>
    </hgroup>
    <article >
      <figure>
        <img src="images/java/junit-time.png">
        
      </figure><ul>
<li>JUnit integrato nei principali ambienti di sviluppo</li>
<li>Creare un test case in Eclipse<ul>
<li><em>New -&gt; JUnit Test Case</em></li>
</ul>
</li>
<li>Eseguire una classe di test da Eclipse<ul>
<li><em>Run As -&gt; JUnit Test</em></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Controllare le eccezioni</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Mestiere del programmatore<ul>
<li>Codice che completa correttamente l'esecuzione nei casi normali...</li>
<li>Ma che anche in situazioni eccezionali mostra il comportamento atteso</li>
</ul>
</li>
<li>Come verificare che una eccezione attesa sia effettivamente sollevata?<ul>
<li>Annotazione <code>@Test</code> con parametro opzionale <code>expected</code> (assegnare un sottotipo di <code>Throwable</code>)</li>
</ul>
</li>
<li>Esempio: <code>Ball</code> solleva effettivamente una eccezione attesa?</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>@Test(expected = IndexOutOfBoundsException.class)
public void testOutOfArena() { 
    new Ball(-1, -1);
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Test temporizzati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Un test può prendere un valore di timeout come parametro (<em>millis</em>)</li>
<li>Massimo intervallo di tempo che l’esecuzione del test può impiegare</li>
<li>Se il tempo scade, il test fallisce</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>@Test(timeout=1)
public void testBounceDown() {
    Ball b = new Ball(8, 11);
    b.move();
    assertTrue(b.getX() == 9 &amp;&amp; b.getY() == 10);
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Test suite</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Meccanismo per <em>raggruppare</em> logicamente dei test ed <em>eseguirli assieme</em></li>
<li>L’annotazione <code>@SuiteClasses</code> crea una test suite<ul>
<li>Lista di classi di test passate come parametro</li>
</ul>
</li>
<li>L’annotazione <code>@RunWith</code> permette di impostare diversi esecutori di test<ul>
<li>Di solito si usa <code>Suite</code>, già incluso nel framework</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio di test suite</h2>
      <h3></h3>
    </hgroup>
    <article >
      <pre class="prettyprint" data-lang="Java"><code>import org.junit.runner.RunWith;
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;

@RunWith(Suite.class)
@SuiteClasses({
    SimpleBallTest.class,
    ParamBallTest.class
})
public class BallTestSuite {
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Test parametrizzati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Ripetere un test con diversi parametri<ul>
<li>Un test case per ogni gruppo di parametri?</li>
<li>In alcune applicazioni, enorme quantità di test!</li>
</ul>
</li>
<li>JUnit: test parametrizzati, eseguiti su parametri modificabili<ul>
<li>Si crea un unico test case, da eseguire più volte</li>
<li>Ogni volta eseguito su un gruppo di parametri diversi</li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Creare un test parametrizzato</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Creare un normale test, senza parametri</li>
<li>Creare un metodo static di <em>fornitura dati</em><ul>
<li>Annotato con <code>@Parameters</code></li>
<li>Restituisce una <code>Collection</code></li>
</ul>
</li>
<li>Scrivere un <em>costruttore</em> che riceve dei parametri<ul>
<li>Aggiungere campi di classe per i parametri</li>
<li>Inizializzati dal costruttore</li>
</ul>
</li>
<li>Eseguire il test in maniera <em>parametrizzata</em>, con la classe <code>Parameterized</code><ul>
<li>Può essere specificato con la annotazione <code>@RunWith</code></li>
</ul>
</li>
</ul></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esempio di test parametrizzato</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Muovere una pallina a partire da diverse posizioni</li>
<li>I valori dei parametri non sono definiti nel metodo</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>@Test
public void moveTest() throws Exception {
    int w = 16, h = 12;
    Ball b = new Ball(x0, y0, dx, dy, w, h);       // params
    b.move();
    assertTrue(b.getX() == x1 &amp;&amp; b.getY() == y1);  // params
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Fornitura dei parametri</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Il passo successivo è creare un <em>metodo di fornitura</em></li>
<li>Deve essere <code>static</code> e deve restituire una <code>Collection</code></li>
<li>Deve essere associato all’annotazione <code>@Parameters</code></li>
<li>Es. Convertire una matrice di <code>Object</code> in una <code>List</code> (di array, righe)</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>@Parameters
public static Collection values() {
    return Arrays.asList(new Object[][] {
        {8, 4, 1, 1, 9, 5},
        {8, 11, 1, 1, 9, 10},
        {15, 4, 1, 1, 14, 5},
        {0, 4, -1, 1, 1, 5},
        {8, 0, 1, -1, 9, 1}
    });
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Creare i campi e il costruttore</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>I parametri devono corrispondere ai campi della classe<ul>
<li>In questo caso tutti interi</li>
</ul>
</li>
<li>Costruttore per assegnare i parametri ai campi</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>int x0, y0, dx, dy, x1, y1;

public ParamBallTest(int x0, int y0,
                     int dx, int dy,
                     int x1, int y1) {
    this.x0 = x0; this.y0 = y0;
    this.dx = dx; this.dy = dy;
    this.x1 = x1; this.y1 = y1;
}
</code></pre></article>
 
</slide>

<slide  >
  
    <hgroup>
      <h2>Esecuzione di test parametrizzati</h2>
      <h3></h3>
    </hgroup>
    <article >
      <ul>
<li>Infine, specificare che classe di test eseguita in maniera parametrizzata<ul>
<li>Indicare la classe <code>Parameterized</code>, usando l’annotazione <code>@RunWith</code></li>
</ul>
</li>
<li>Nel test precedente, il metodo <code>moveTest()</code> viene eseguito 5 volte<ul>
<li>Una volta per ciascuna riga di dati generata dal metodo <code>values()</code></li>
</ul>
</li>
</ul>
<pre class="prettyprint" data-lang="Java"><code>@RunWith(Parameterized.class)
public class ParamBallTest {
    // ParamBallTest(...)
    // values()
    // moveTest()
}
</code></pre></article>
 
</slide>


<slide class="thank-you-slide segue nobackground">
  <aside class="gdbar right"><img src="images/java-logo.png"></aside>
  <article class="flexbox vleft auto-fadein">
    <h2>&lt;Domande?&gt;</h2>
  </article>
  <p class="auto-fadein" data-config-contact>
    Michele Tomaiuolo
    <br>
    Palazzina 1, int. 5708
    <br>
    Ingegneria dell'Informazione, UniPR
    <br>
    <a href="http://www.ce.unipr.it/people/tomamic">www.ce.unipr.it/people/tomamic</a>
  </p>
</slide>

<slide class="backdrop"></slide>

</slides>

</body>
</html>
